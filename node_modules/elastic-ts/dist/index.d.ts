interface MatchAllQuery {
    match_all: {
        boost?: number;
    };
}
interface MatchNoneQuery {
    match_none: {};
}
interface MatchQueryFieldConfig {
    match: string | {
        query: string;
        analyzer?: string;
        boost?: number;
        auto_generate_synonyms_phrase_query?: boolean;
        cutoff_frequency?: number;
        fuzziness?: number | string;
        fuzzy_transpositions?: boolean;
        lenient?: boolean;
        max_expansions?: number;
        minimum_should_match?: number | string;
        operator?: 'and' | 'or';
        prefix_length?: number;
        rewrite?: any;
        zero_terms_query?: 'none' | 'all';
    };
}
interface MatchQuery {
    match: {
        [field: string]: MatchQueryFieldConfig['match'];
    };
}
interface MatchPhraseFieldConfig {
    match_phrase: string | {
        query: string;
        analyzer?: string;
        boost?: number;
        slop?: number;
    };
}
interface MatchPhraseQuery {
    match_phrase: {
        [field: string]: MatchPhraseFieldConfig['match_phrase'];
    };
}
interface MatchPhrasePrefixFieldConfig {
    match_phrase_prefix: string | {
        query: string;
        analyzer?: string;
        slop?: number;
        max_expansions?: number;
    };
}
interface MatchPhrasePrefixQuery {
    match_phrase_prefix: {
        [field: string]: MatchPhrasePrefixFieldConfig['match_phrase_prefix'];
    };
}
interface MultiMatchQuery {
    multi_match: {
        query: string;
        fields: string[];
        analyzer?: string;
        auto_generate_synonyms_phrase_query?: boolean;
        boost?: number;
        cutoff_frequency?: number;
        fuzziness?: number | string;
        fuzzy_transpositions?: boolean;
        lenient?: boolean;
        max_expansions?: number;
        minimum_should_match?: number | string;
        operator?: 'and' | 'or';
        prefix_length?: number;
        rewrite?: any;
        slop?: number;
        tie_breaker?: number | string;
        type?: 'best_fields' | 'most_fields' | 'cross_fields' | 'phrase' | 'phrase_prefix' | 'bool_prefix';
        zero_terms_query?: 'none' | 'all';
    };
}
interface CommonTermsFieldConfig {
    common: {
        query: string;
        cutoff_frequency?: number;
        analyzer?: string;
        boost?: number;
        minimum_should_match?: number | string | {
            low_freq: number | string;
            high_freq: number | string;
        };
        low_freq_operator?: 'and' | 'or';
        high_freq_operator?: 'and' | 'or';
    };
}
interface CommonTermsQuery {
    common: {
        [field: string]: CommonTermsFieldConfig['common'];
    };
}
interface QueryStringQuery {
    query_string: {
        default_field?: string;
        query: string;
        analyzer?: string;
        quote_analyzer?: string;
        allow_leading_wildcard?: boolean;
        enable_position_increments?: boolean;
        fuzzy_match_expansions?: number;
        fuzziness?: number | string;
        fuzzy_prefix_length?: number;
        fuzzy_transpositions?: boolean;
        phrase_slop?: number;
        boost?: number;
        auto_generate_phrase_queries?: boolean;
        analyze_wildcard?: boolean;
        max_determined_states?: number;
        minimum_should_match?: number | string;
        lenient?: boolean;
        time_zone?: string;
        quote_field_suffix?: string;
        auto_generate_synonyms_phrase_query?: boolean;
        rewrite?: any;
        fields?: string[];
        tie_breaker?: number;
        default_operator?: 'and' | 'or';
    };
}
interface SimpleQueryStringQuery {
    simple_query_string: {
        query: string;
        fields?: string[];
        default_operator?: 'and' | 'or';
        analyzer?: string;
        flags?: string;
        analyze_wildcard?: boolean;
        lenient?: boolean;
        minimum_should_match?: number | string;
        quote_field_suffix?: string;
        auto_generate_synonyms_phrase_query?: boolean;
        fuzzy_prefix_length?: number;
        fuzzy_max_expansions?: number;
        fuzzy_transpositions?: boolean;
    };
}
declare type FullTextQuery = MatchQuery | MatchPhraseQuery | MatchPhrasePrefixQuery | MultiMatchQuery | CommonTermsQuery | QueryStringQuery | SimpleQueryStringQuery;
declare type AllFullTextQueries = MatchQuery & MatchPhraseQuery & MatchPhrasePrefixQuery & MultiMatchQuery & CommonTermsQuery & QueryStringQuery & SimpleQueryStringQuery;
interface TermFieldConfig {
    term: PrimitiveValue | {
        value: PrimitiveValue;
        boost?: number;
    };
}
interface TermQuery {
    term: {
        [field: string]: TermFieldConfig['term'];
    };
}
interface TermsFieldConfig {
    terms: PrimitiveValueArray | {
        index: string;
        type: string;
        id: string;
        path: string;
        routing?: string;
    };
}
interface TermsQuery {
    terms: {
        [field: string]: TermsFieldConfig['terms'];
    };
}
interface TermsSetFieldConfig {
    terms_set: {
        terms: PrimitiveValueArray;
        minimum_should_match_field?: string;
        minimum_should_match_script?: {
            source?: string;
        };
    };
}
interface TermsSetQuery {
    terms_set: {
        [field: string]: TermsSetFieldConfig['terms_set'];
    };
}
interface RangeFieldConfig {
    range: {
        gt?: string | number;
        gte?: string | number;
        lt?: string | number;
        lte?: string | number;
        from?: string | number;
        to?: string | number;
        format?: string;
        time_zone?: string;
        boost?: number;
    };
}
interface RangeQuery {
    range: {
        [field: string]: RangeFieldConfig['range'];
    };
}
interface ExistsQuery {
    exists: {
        field: string;
    };
}
interface PrefixFieldConfig {
    prefix: string | {
        value: string;
        boost?: number;
    };
}
interface PrefixQuery {
    prefix: {
        [field: string]: PrefixFieldConfig['prefix'];
    };
}
interface WildcardFieldConfig {
    wildcard: string | {
        value: string;
        boost?: number;
    } | {
        wildcard: string;
        boost?: number;
    };
}
interface WildcardQuery {
    wildcard: {
        [field: string]: WildcardFieldConfig['wildcard'];
    };
}
interface RegexpFieldConfig {
    regexp: string | {
        value: string;
        flags?: string;
        boost?: number;
        max_determinized_states?: number;
    };
}
interface RegexpQuery {
    regexp: {
        [field: string]: RegexpFieldConfig['regexp'];
    };
}
interface FuzzyFieldConfig {
    fuzzy: string | {
        value: string;
        boost?: number;
        fuzziness: number | string;
        prefix_length?: number;
        max_expansions?: number;
        transpositions?: boolean;
    };
}
interface FuzzyQuery {
    fuzzy: {
        [field: string]: FuzzyFieldConfig['fuzzy'];
    };
}
interface TypeQuery {
    type: {
        value: string;
    };
}
interface IdsQuery {
    ids: {
        type?: string | string[];
        values: string[];
    };
}
declare type TermLevelQuery = TermQuery | TermsQuery | TermsSetQuery | RangeQuery | ExistsQuery | PrefixQuery | WildcardQuery | RegexpQuery | FuzzyQuery | TypeQuery | IdsQuery;
declare type AllTermLevelQueries = TermQuery & TermsQuery & TermsSetQuery & RangeQuery & ExistsQuery & PrefixQuery & WildcardQuery & RegexpQuery & FuzzyQuery & TypeQuery & IdsQuery;
interface ConstantScoreQuery {
    constant_score: {
        filter: Query;
        boost?: number;
    };
}
interface BoolQueryConfig {
    must?: Query | Query[];
    filter?: Query | Query[];
    should?: Query | Query[];
    must_not?: Query | Query[];
    minimum_should_match?: number | string;
    boost?: number;
}
interface BoolQuery {
    bool: BoolQueryConfig;
}
interface DisMaxQuery {
    dis_max: {
        tie_breaker?: number | string;
        boost?: number;
        queries: Query[];
    };
}
/** @deprecated Deprecated in Elasticsearch 7.9 */
interface FunctionScoreQuery {
    function_score: {
        functions?: (FunctionScoreQuery['function_score'] & {
            filter?: Query;
        })[];
        query?: Query;
        max_boost?: number;
        boost?: number | string;
        score_mode?: 'multiply' | 'sum' | 'avg' | 'first' | 'max' | 'min';
        boost_mode?: 'multiply' | 'replace' | 'sum' | 'avg' | 'max' | 'min';
        min_score?: number;
        script_score?: {
            script: Script;
        };
        weight?: number;
        random_score?: {
            seed?: number;
            field?: string;
        };
        field_value_factor?: {
            field: string;
            factor?: number;
            modifier?: 'none' | 'log' | 'log1p' | 'log2p' | 'ln' | 'ln1p' | 'ln2p' | 'square' | 'sqrt' | 'reciprocal';
            missing?: PrimitiveValue;
        };
        gauss?: {
            [field: string]: {
                origin?: string;
                scale: string;
                offset?: string | number;
                decay?: number;
            };
        };
        linear?: {
            [field: string]: {
                origin?: string;
                scale: string;
                offset?: string | number;
                decay?: number;
            };
        };
        exp?: {
            [field: string]: {
                origin?: string;
                scale: string;
                offset?: string | number;
                decay?: number;
            };
        };
    };
}
interface BoostingQuery {
    boosting: {
        positive: Query;
        negative: Query;
        negative_boost: number;
    };
}
declare type CompoundQuery = ConstantScoreQuery | BoolQuery | DisMaxQuery | FunctionScoreQuery | BoostingQuery;
declare type AllCompoundQueries = ConstantScoreQuery & BoolQuery & DisMaxQuery & FunctionScoreQuery & BoostingQuery;
interface NestedQuery {
    nested: {
        path: string;
        query: Query;
        score_mode?: 'avg' | 'sum' | 'min' | 'max' | 'none';
        ignore_unmapped?: boolean;
    };
}
interface HasChildQuery {
    has_child: {
        type: string;
        query: Query;
        score_mode?: 'none' | 'min' | 'max' | 'sum' | 'avg';
        min_children?: number;
        max_children?: number;
        ignore_unmapped?: boolean;
    };
}
interface HasParentQuery {
    has_parent: {
        parent_type: string;
        query: Query;
        score?: boolean;
        ignore_unmapped?: boolean;
    };
}
interface ParentIdQuery {
    parent_id: {
        type: string;
        id: string;
        ignore_unmapped?: boolean;
    };
}
declare type JoiningQuery = NestedQuery | HasChildQuery | HasParentQuery | ParentIdQuery;
declare type AllJoiningQueries = NestedQuery & HasChildQuery & HasParentQuery & ParentIdQuery;
interface GeoShapeQuery {
    geo_shape: {
        location: {
            shape?: {
                type: string;
                coordinates: [number, number][];
            };
            indexed_shape?: {
                index: string;
                type: string;
                id: string;
                path: string;
            };
            relation?: 'intersects' | 'disjoint' | 'within' | 'contains';
            ignore_unmapped?: boolean;
        };
    };
}
interface GeoBoundingBoxFieldConfig {
    geo_bounding_box: {
        _name?: string;
        type?: 'memory' | 'indexed';
        validation_method?: 'strict' | 'ignore_malformed' | 'coerce';
        bottom_left?: Coordinate;
        bottom_right?: Coordinate;
        bottom?: Coordinate;
        bottomLeft?: Coordinate;
        bottomRight?: Coordinate;
        left?: Coordinate;
        right?: Coordinate;
        top_left?: Coordinate;
        top_right?: Coordinate;
        top?: Coordinate;
        topLeft?: Coordinate;
        topRight?: Coordinate;
        wkt?: string;
    };
}
interface GeoBoundingBoxQuery {
    geo_bounding_box: {
        [field: string]: GeoBoundingBoxFieldConfig['geo_bounding_box'];
    };
}
interface GeoDistanceQuery {
    geo_distance: {
        distance: string;
        distance_type?: 'arc' | 'plane';
        _name?: string;
        validation_method?: 'strict' | 'ignore_malformed' | 'coerce';
        ignore_unmapped?: boolean;
    } | {
        [field: string]: Coordinate;
    };
}
interface GeoPolygonFieldConfig {
    geo_polygon: {
        points: Coordinate[];
        _name?: string;
        validation_method?: 'strict' | 'ignore_malformed' | 'coerce';
        ignore_unmapped?: boolean;
    };
}
interface GeoPolygonQuery {
    geo_polygon: {
        [field: string]: GeoPolygonFieldConfig['geo_polygon'];
    };
}
declare type GeoQuery = GeoShapeQuery | GeoBoundingBoxQuery | GeoDistanceQuery | GeoPolygonQuery;
declare type AllGeoQueries = GeoShapeQuery & GeoBoundingBoxQuery & GeoDistanceQuery & GeoPolygonQuery;
interface MoreLikeThisQuery {
    more_like_this: {
        fields?: string[];
        like: string | (object | string)[];
        like_text?: string;
        unlike?: string | (object | string)[];
        ids?: string[];
        docs?: object[];
        max_query_terms?: number;
        min_term_freq?: number;
        min_doc_freq?: number;
        max_doc_freq?: number;
        min_word_length?: number;
        max_word_length?: number;
        stop_words?: string[];
        analyzer?: string;
        minimum_should_match?: string;
        boost_terms?: number;
        include?: boolean;
        boost?: number;
    };
}
interface ScriptQuery {
    script: {
        script: Script;
    };
}
interface ScriptScoreQuery {
    script_score: {
        query: Query;
        script: Script;
    };
}
interface PercolateQuery {
    percolate: {
        field: string;
        name?: string;
    } & ({
        document?: object;
        documents?: object[];
    } | {
        index: string;
        type: string;
        id: string;
        routing?: string;
        preference?: string;
        version?: string | number;
    });
}
interface WrapperQuery {
    wrapper: {
        query: string;
    };
}
interface RankFeatureQuery {
    rank_feature: {
        field: string;
        boost?: number;
    } & ({
        saturation: {
            pivot?: number;
        };
    } | {
        log: {
            scaling_factor: number;
        };
    } | {
        sigmoid: {
            pivot: number;
            exponent: number;
        };
    } | {});
}
declare type SpecializedQuery = MoreLikeThisQuery | ScriptQuery | ScriptScoreQuery | PercolateQuery | WrapperQuery | RankFeatureQuery;
declare type AllSpecializedQueries = MoreLikeThisQuery & ScriptQuery & ScriptScoreQuery & PercolateQuery & WrapperQuery & RankFeatureQuery;
declare type Query = MatchAllQuery | MatchNoneQuery | FullTextQuery | TermLevelQuery | CompoundQuery | JoiningQuery | GeoQuery | SpecializedQuery;
declare type AllQueries = MatchAllQuery & MatchNoneQuery & AllFullTextQueries & AllTermLevelQueries & AllCompoundQueries & AllJoiningQueries & AllGeoQueries & AllSpecializedQueries;
declare type QueryType = keyof AllQueries;
declare type FieldQueryConfig = MatchQueryFieldConfig | MatchPhraseFieldConfig | MatchPhrasePrefixFieldConfig | CommonTermsFieldConfig | TermFieldConfig | TermsFieldConfig | TermsSetFieldConfig | RangeFieldConfig | PrefixFieldConfig | WildcardFieldConfig | RegexpFieldConfig | FuzzyFieldConfig | GeoBoundingBoxFieldConfig | GeoPolygonFieldConfig;
declare type AllFieldQueryConfigs = MatchQueryFieldConfig & MatchPhraseFieldConfig & MatchPhrasePrefixFieldConfig & CommonTermsFieldConfig & TermFieldConfig & TermsFieldConfig & TermsSetFieldConfig & RangeFieldConfig & PrefixFieldConfig & WildcardFieldConfig & RegexpFieldConfig & FuzzyFieldConfig & GeoBoundingBoxFieldConfig & GeoPolygonFieldConfig;
declare type FieldQueryType = keyof AllFieldQueryConfigs;

declare type Script = string | {
    source: string;
    lang?: string;
    params?: {
        [param: string]: any;
    };
} | {
    id: string;
    params?: {
        [param: string]: any;
    };
};
declare type PrimitiveValue = null | number | string | boolean;
declare type PrimitiveValueArray = null[] | number[] | string[] | boolean[];
declare type Coordinate = string | number | [number, number] | {
    lat: number;
    lon: number;
};
declare type SortOrder = 'asc' | 'desc';
interface NestedSort {
    path: string;
    filter: Query;
    nested?: NestedSort;
}
interface FieldSortOptions {
    order?: SortOrder;
    mode?: 'min' | 'max' | 'sum' | 'avg' | 'median';
    nested?: NestedSort;
    missing?: PrimitiveValue;
    unmapped_type?: string;
}
declare type SortType = string | {
    _geo_distance: {
        order?: SortOrder;
        distance_type?: 'arc' | 'plane';
        mode: 'min' | 'max' | 'median' | 'avg';
        unit?: string;
        distance: string;
        _name?: string;
        validation_method?: 'strict' | 'ignore_malformed' | 'coerce';
        ignore_unmapped?: boolean;
    } | {
        [field: string]: Coordinate | Coordinate[];
    };
} | {
    _script: {
        type: string;
        script: Script;
        order: SortOrder;
    };
} | {
    [field: string]: SortOrder | FieldSortOptions;
};
declare type Sort = SortType | SortType[];

declare type CollectMode = 'breadth_first' | 'depth_first';
interface AvgAggregation {
    avg: ({
        field: string;
    } | {
        script: Script;
    }) & {
        missing?: PrimitiveValue;
    };
}
interface CardinalityAggregation {
    cardinality: ({
        field: string;
    } | {
        script: Script;
    }) & {
        precision_threshold?: number;
        missing?: PrimitiveValue;
    };
}
interface ExtendedStatsAggregation {
    extended_stats: ({
        field: string;
    } | {
        script: Script;
    }) & {
        sigma?: number;
        missing?: PrimitiveValue;
    };
}
interface GeoBoundsAggregation {
    geo_bounds: {
        field: string;
        wrap_longitude?: boolean;
    };
}
interface GeoCentroidAggregation {
    geo_centroid: {
        field: string;
    };
}
interface MaxAggregation {
    max: ({
        field: string;
    } | {
        script: Script;
    }) & {
        missing?: PrimitiveValue;
    };
}
interface MinAggregation {
    min: ({
        field: string;
    } | {
        script: Script;
    }) & {
        missing?: PrimitiveValue;
    };
}
interface PercentilesAggregation {
    percentiles: ({
        field: string;
    } | {
        script: Script;
    }) & {
        percents?: number[];
        keyed?: boolean;
        tdigest?: {
            compression?: number;
        };
        hdr?: {
            number_of_significant_value_digits?: number;
        };
        missing?: PrimitiveValue;
    };
}
interface PercentileRanksAggregation {
    percentile_ranks: ({
        field: string;
    } | {
        script: Script;
    }) & {
        values: number[];
        keyed?: boolean;
        hdr?: {
            number_of_significant_value_digits?: number;
        };
        missing?: PrimitiveValue;
    };
}
interface ScriptedMetricAggregation {
    scripted_metric: {
        init_script?: Script;
        map_script: Script;
        combine_script?: Script;
        reduce_script?: Script;
        params?: {
            [param: string]: any;
        };
    };
}
interface StatsAggregation {
    stats: ({
        field?: string;
    } | {
        script?: Script;
    }) & {
        sigma?: number;
        missing?: PrimitiveValue;
    };
}
interface SumAggregation {
    sum: ({
        field: string;
    } | {
        script: Script;
    }) & {
        missing?: PrimitiveValue;
    };
}
interface TopHitsAggregation {
    top_hits: {
        from?: number;
        size?: number;
        sort?: Sort;
        _source?: any;
    };
}
interface ValueCountAggregation {
    value_count: {
        field: string;
    } | {
        script: Script;
    };
}
declare type MetricsAggregation = AvgAggregation | CardinalityAggregation | ExtendedStatsAggregation | GeoBoundsAggregation | GeoCentroidAggregation | MaxAggregation | MinAggregation | PercentilesAggregation | PercentileRanksAggregation | ScriptedMetricAggregation | StatsAggregation | SumAggregation | TopHitsAggregation | ValueCountAggregation;
declare type AllMetricsAggregations = AvgAggregation & CardinalityAggregation & ExtendedStatsAggregation & GeoBoundsAggregation & GeoCentroidAggregation & MaxAggregation & MinAggregation & PercentilesAggregation & PercentileRanksAggregation & ScriptedMetricAggregation & StatsAggregation & SumAggregation & TopHitsAggregation & ValueCountAggregation;
interface AdjacencyMatrixAggregation {
    adjacency_matrix: {
        filters: {
            [name: string]: Query;
        };
        separator?: string;
    };
}
interface ChildrenAggregation {
    children: {
        type: string;
    };
}
interface CompositeAggregation {
    composite: {
        size?: number;
        sources: {
            [name: string]: {
                terms: ({
                    field: string;
                } | {
                    script: Script;
                }) & {
                    order?: SortOrder;
                };
            } | {
                histogram: ({
                    field: string;
                } | {
                    script: Script;
                }) & {
                    interval: number;
                    order?: SortOrder;
                };
            } | {
                date_histogram: ({
                    field: string;
                } | {
                    script: Script;
                }) & {
                    interval: string;
                    time_zone?: string;
                    order?: SortOrder;
                };
            };
        }[];
        after?: {
            [source: string]: PrimitiveValue;
        };
    };
}
interface DateHistogramAggregation {
    date_histogram: {
        field: string;
        interval: string;
        offset?: string;
        format?: string;
        time_zone?: string;
        keyed?: boolean;
        missing?: PrimitiveValue;
    };
}
interface DateRangeAggregation {
    date_range: {
        field: string;
        ranges: ({
            from: string;
            key?: string;
        } | {
            to: string;
            key?: string;
        } | {
            from: string;
            to: string;
            key?: string;
        })[];
        format?: string;
        time_zone?: string;
        keyed?: boolean;
        missing?: string;
    };
}
interface DiversifiedSamplerAggregation {
    diversified_sampler: ({
        field: string;
    } | {
        script: Script;
    }) & {
        max_docs_per_value?: number;
        shard_size?: number;
        execution_hint?: 'map' | 'global_ordinals' | 'bytes_hash';
    };
}
interface FilterAggregation {
    filter: Query;
}
interface FiltersAggregation {
    filters: {
        other_bucket_key?: string;
        filters: {
            [name: string]: Query;
        } | Query[];
    };
}
interface GeoDistanceAggregation {
    geo_distance: {
        field: string;
        origin: Coordinate;
        unit?: string;
        distance_type?: 'arc' | 'plane';
        keyed?: boolean;
        ranges: ({
            to: number;
            key?: string;
        } | {
            from: number;
            key?: string;
        } | {
            from: number;
            to: number;
            key?: string;
        })[];
    };
}
interface GeoHashGridAggregation {
    geohash_grid: {
        field: string;
        precision?: number;
        size?: number;
        shard_size?: number;
    };
}
interface GlobalAggregation {
    global: {};
}
interface HistogramAggregation {
    histogram: {
        field: string;
        interval: number;
        offset?: number;
        min_doc_count?: number;
        extended_bounds?: {
            min: number;
            max: number;
        };
        order?: {
            [field: string]: SortOrder;
        };
        missing?: PrimitiveValue;
        keyed?: boolean;
    };
}
interface IPRangeAggregation {
    ip_range: {
        field: string;
        ranges: ({
            to: string;
            key?: string;
        } | {
            from: string;
            key?: string;
        } | {
            mask: string;
            key?: string;
        })[];
        keyed?: boolean;
    };
}
interface MissingAggregation {
    missing: {
        field: string;
    };
}
interface NestedAggregation {
    nested: {
        path: string;
    };
}
interface RangeAggregation {
    range: ({
        field: string;
    } | {
        script: Script;
    }) & {
        ranges: ({
            from: string | number;
            key?: string;
        } | {
            to: string | number;
            key?: string;
        } | {
            from: string | number;
            to: string | number;
            key?: string;
        })[];
        keyed?: boolean;
    };
}
interface ReverseNestedAggregation {
    reverse_nested: {
        path?: string;
    };
}
interface SamplerAggregation {
    sampler: {
        field?: string;
        size?: number;
        exclude?: string[];
        shard_size?: number;
    };
}
interface SignificantTermsAggregation {
    significant_terms: {
        field: string;
        script_heuristic?: Script;
        min_doc_count?: number;
        shard_min_doc_count?: number;
        background_filter?: Query;
        execution_hint?: 'global_ordinals' | 'map';
        include?: string | string[];
        exclude?: string | string[];
        size?: number;
        shard_size?: number;
    };
}
interface SignificantTextAggregation {
    significant_text: {
        field: string;
        filter_duplicate_text?: boolean;
        size?: number;
        shard_size?: number;
        min_doc_count?: number;
        shard_min_doc_count?: number;
        background_filter?: Query;
        source_fields?: string[];
        include?: PrimitiveValueArray;
        exclude?: PrimitiveValueArray;
    };
}
interface TermsAggregation {
    terms: ({
        field?: string;
    } | {
        script?: Script;
    }) & {
        size?: number;
        shard_size?: number;
        show_term_doc_count_error?: boolean;
        order?: {
            [field: string]: SortOrder;
        } | {
            [field: string]: SortOrder;
        }[];
        min_doc_count?: number;
        shard_min_doc_count?: number;
        include?: string | string[] | {
            partition: number;
            num_partitions: number;
        };
        exclude?: string | string[];
        collect_mode?: CollectMode;
        execution_hint?: 'map' | 'global_ordinals';
        missing?: any;
    };
}
declare type BucketAggregation = AdjacencyMatrixAggregation | ChildrenAggregation | CompositeAggregation | DateHistogramAggregation | DateRangeAggregation | DiversifiedSamplerAggregation | FilterAggregation | FiltersAggregation | GeoDistanceAggregation | GeoHashGridAggregation | GlobalAggregation | HistogramAggregation | IPRangeAggregation | MissingAggregation | NestedAggregation | RangeAggregation | ReverseNestedAggregation | SamplerAggregation | SignificantTermsAggregation | SignificantTextAggregation | TermsAggregation;
declare type AllBucketAggregations = AdjacencyMatrixAggregation & ChildrenAggregation & CompositeAggregation & DateHistogramAggregation & DateRangeAggregation & DiversifiedSamplerAggregation & FilterAggregation & FiltersAggregation & GeoDistanceAggregation & GeoHashGridAggregation & GlobalAggregation & HistogramAggregation & IPRangeAggregation & MissingAggregation & NestedAggregation & RangeAggregation & ReverseNestedAggregation & SamplerAggregation & SignificantTermsAggregation & SignificantTextAggregation & TermsAggregation;
interface AvgBucketAggregation {
    avg_bucket: {
        buckets_path: string;
        gap_policy?: 'skip' | 'insert_zeros';
        format?: string;
    };
}
interface DerivativeAggregation {
    derivative: {
        buckets_path: string;
        gap_policy?: 'skip' | 'insert_zeros';
        format?: string;
        unit?: string;
    };
}
interface MaxBucketAggregation {
    max_bucket: {
        buckets_path: string;
        gap_policy?: 'skip' | 'insert_zeros';
        format?: string;
    };
}
interface MinBucketAggregation {
    min_bucket: {
        buckets_path: string;
        gap_policy?: 'skip' | 'insert_zeros';
        format?: string;
    };
}
interface SumBucketAggregation {
    sum_bucket: {
        buckets_path: string;
        gap_policy?: 'skip' | 'insert_zeros';
        format?: string;
    };
}
interface StatsBucketAggregation {
    stats_bucket: {
        buckets_path: string;
        gap_policy?: 'skip' | 'insert_zeros';
        format?: string;
    };
}
interface ExtendedStatsBucketAggregation {
    extended_stats_bucket: {
        buckets_path: string;
        gap_policy?: 'skip' | 'insert_zeros';
        format?: string;
        sigma?: number;
    };
}
interface PercentilesBucketAggregation {
    percentiles_bucket: {
        buckets_path: string;
        gap_policy?: 'skip' | 'insert_zeros';
        format?: string;
        percents?: number[];
    };
}
interface MovingAverageBucketAggregation {
    moving_avg: {
        buckets_path: string;
        gap_policy?: 'skip' | 'insert_zeros';
        window?: number;
        maximize?: boolean;
        minimize?: boolean;
        predict?: number;
    } & ({
        model?: 'simple';
    } | {
        model: 'linear';
    } | {
        model: 'ewma';
        settings?: {
            alpha?: number;
        };
    } | {
        model: 'holt';
        settings?: {
            alpha?: number;
            beta?: number;
        };
    } | {
        model: 'holt_winters';
        settings?: {
            type?: 'add' | 'mult';
            alpha?: number;
            beta?: number;
            gamma?: number;
            period?: number;
            pad?: boolean;
        };
    });
}
interface CumulativeSumAggregation {
    cumulative_sum: {
        buckets_path: string;
        format?: string;
    };
}
interface BucketScriptAggregation {
    bucket_script: {
        script: Script;
        buckets_path: {
            [variable: string]: string;
        };
        gap_policy?: 'skip' | 'insert_zeros';
        format?: string;
    };
}
interface BucketSelectorAggregation {
    bucket_selector: {
        script: Script;
        buckets_path: {
            [variable: string]: string;
        };
        gap_policy?: 'skip' | 'insert_zeros';
    };
}
interface BucketSortAggregation {
    bucket_sort: {
        sort?: Sort;
        from?: number;
        size?: number;
        gap_policy?: 'skip' | 'insert_zeros';
    };
}
interface SerialDifferencingAggregation {
    serial_diff: {
        buckets_path: string;
        lag?: number;
        gap_policy?: 'skip' | 'insert_zeros';
        format?: string;
    };
}
declare type PipelineAggregation = AvgBucketAggregation | DerivativeAggregation | MaxBucketAggregation | MinBucketAggregation | SumBucketAggregation | StatsBucketAggregation | ExtendedStatsBucketAggregation | PercentilesBucketAggregation | MovingAverageBucketAggregation | CumulativeSumAggregation | BucketScriptAggregation | BucketSelectorAggregation | BucketSortAggregation | SerialDifferencingAggregation;
declare type AllPipelineAggregations = AvgBucketAggregation & DerivativeAggregation & MaxBucketAggregation & MinBucketAggregation & SumBucketAggregation & StatsBucketAggregation & ExtendedStatsBucketAggregation & PercentilesBucketAggregation & MovingAverageBucketAggregation & CumulativeSumAggregation & BucketScriptAggregation & BucketSelectorAggregation & BucketSortAggregation & SerialDifferencingAggregation;
interface MatrixStatsAggregation {
    matrix_stats: {
        fields: string[];
        mode?: 'avg' | 'min' | 'max' | 'sum' | 'median';
        missing?: {
            [field: string]: PrimitiveValue;
        };
    };
}
declare type MatrixAggregation = MatrixStatsAggregation;
declare type AllMatrixAggregations = MatrixStatsAggregation;
declare type Aggregation = MetricsAggregation | BucketAggregation | PipelineAggregation | MatrixAggregation;
declare type AllAggregations = AllMetricsAggregations & AllBucketAggregations & AllPipelineAggregations & AllMatrixAggregations;
declare type AggregationType = keyof AllAggregations;
interface Aggregations {
    [name: string]: Aggregation & {
        filter?: Query;
        aggs?: Aggregations;
        aggregations?: Aggregations;
    };
}

declare type NotFunction<T> = T extends Function ? never : T;
declare type PlainObject = NotFunction<object>;
declare type Primitive = null | undefined | string | number | boolean | symbol;
declare type Optional<T, K extends string> = Omit<T, K> & {
    [P in Extract<keyof T, K>]?: T[P] | undefined;
};

/** Represents a function that returns a builder of arbitrary type */
declare type BuilderFn = () => ESBaseBuilder;
/** Takes a tuple type and replaces ES builder functions with `BuilderFn` */
declare type WithBuilderFns<T> = {
    [K in keyof T]: Extract<T[K], ESSubAggregationBuilderFn | ESSubFilterBuilderFn | ESSubQueryBuilderFn> extends never ? T[K] : Exclude<T[K], ESSubAggregationBuilderFn | ESSubFilterBuilderFn | ESSubQueryBuilderFn> | BuilderFn;
};
interface QueryData {
    aggregations: WithBuilderFns<AggregationArgs>[];
    filter: {
        and: WithBuilderFns<FilterArgs>[];
        or: WithBuilderFns<FilterArgs>[];
        not: WithBuilderFns<FilterArgs>[];
        minimumShouldMatch?: number | string;
    };
    from?: number;
    inChildContext: boolean;
    parent?: 'filter' | 'query';
    size?: number;
    sort: SortArgs[];
    query: {
        and: WithBuilderFns<QueryArgs>[];
        or: WithBuilderFns<QueryArgs>[];
        not: WithBuilderFns<QueryArgs>[];
        minimumShouldMatch?: number | string;
    };
    rawOption: {
        [key: string]: unknown;
    };
}
interface BuiltQuery {
    aggs?: {
        [name: string]: object;
    };
    filter?: object;
    from?: number;
    size?: number;
    sort?: object[];
    query?: object;
}
/** Represents all the different argument variations to the aggregation methods */
declare type AggregationArgs = [string, string, string | PlainObject] | [string, string, string, ESSubAggregationBuilderFn] | [string, string, string, PlainObject] | [string, string, PlainObject, ESSubAggregationBuilderFn] | [string, string, string, PlainObject, ESSubAggregationBuilderFn];
interface ESAggregationBuilder<B = ESBuilder> {
    agg<K extends AggregationType>(name: string, type: K, field: string): B;
    agg<K extends AggregationType>(name: string, type: K, config: AllAggregations[K]): B;
    agg<K extends AggregationType>(name: string, type: K, field: string, subBuilder: ESSubAggregationBuilderFn): B;
    agg<K extends AggregationType>(name: string, type: K, field: string, config: Omit<AllAggregations[K], 'field'>): B;
    agg<K extends AggregationType>(name: string, type: K, config: AllAggregations[K], subBuilder: ESSubAggregationBuilderFn): B;
    agg<K extends AggregationType>(name: string, type: K, field: string, config: Omit<AllAggregations[K], 'field'>, subBuilder: ESSubAggregationBuilderFn): B;
    aggregation<K extends AggregationType>(name: string, type: K, field: string): B;
    aggregation<K extends AggregationType>(name: string, type: K, config: AllAggregations[K]): B;
    aggregation<K extends AggregationType>(name: string, type: K, field: string, subBuilder: ESSubAggregationBuilderFn): B;
    aggregation<K extends AggregationType>(name: string, type: K, field: string, config: Omit<AllAggregations[K], 'field'>): B;
    aggregation<K extends AggregationType>(name: string, type: K, config: AllAggregations[K], subBuilder: ESSubAggregationBuilderFn): B;
    aggregation<K extends AggregationType>(name: string, type: K, field: string, config: Omit<AllAggregations[K], 'field'>, subBuilder: ESSubAggregationBuilderFn): B;
}
interface ESBaseBuilder {
    build(): BuiltQuery;
}
/** Represents all the different argument variations to the filter methods */
declare type FilterArgs = [ESSubFilterBuilderFn] | [string, string | PlainObject] | [string, string, Primitive | Primitive[] | PlainObject | ESSubFilterBuilderFn] | [string, PlainObject, ESSubFilterBuilderFn] | [string, string, Primitive | Primitive[], PlainObject | ESSubFilterBuilderFn] | [string, string, Primitive | Primitive[], PlainObject, ESSubFilterBuilderFn];
interface ESFilterBuilder<B = ESBuilder> {
    filter(subBuilder: ESSubFilterBuilderFn): B;
    filter<K extends QueryType>(type: K, field: string): B;
    filter<K extends QueryType>(type: K, config: AllQueries[K]): B;
    filter<K extends QueryType>(type: K, field: string, value: Primitive | Primitive[]): B;
    filter<K extends QueryType>(type: K, field: string, subBuilder: ESSubFilterBuilderFn): B;
    filter<K extends QueryType>(type: K, field: string, config: Omit<AllQueries[K], 'field'>): B;
    filter<K extends QueryType>(type: K, config: Optional<AllQueries[K], keyof BuiltQuery>, subBuilder: ESSubFilterBuilderFn): B;
    filter<K extends QueryType>(type: K, field: string, value: Primitive | Primitive[], subBuilder: ESSubFilterBuilderFn): B;
    filter<K extends QueryType>(type: K, field: string, value: Primitive | Primitive[], config: Omit<AllQueries[K], 'field'>): B;
    filter<K extends QueryType>(type: K, field: string, value: Primitive | Primitive[], config: Optional<Omit<AllQueries[K], 'field'>, keyof BuiltQuery>, subBuilder: ESSubFilterBuilderFn): B;
    andFilter(subBuilder: ESSubFilterBuilderFn): B;
    andFilter<K extends QueryType>(type: K, field: string): B;
    andFilter<K extends QueryType>(type: K, config: AllQueries[K]): B;
    andFilter<K extends QueryType>(type: K, field: string, value: Primitive | Primitive[]): B;
    andFilter<K extends QueryType>(type: K, field: string, subBuilder: ESSubFilterBuilderFn): B;
    andFilter<K extends QueryType>(type: K, field: string, config: Omit<AllQueries[K], 'field'>): B;
    andFilter<K extends QueryType>(type: K, config: Optional<AllQueries[K], keyof BuiltQuery>, subBuilder: ESSubFilterBuilderFn): B;
    andFilter<K extends QueryType>(type: K, field: string, value: Primitive | Primitive[], subBuilder: ESSubFilterBuilderFn): B;
    andFilter<K extends QueryType>(type: K, field: string, value: Primitive | Primitive[], config: Omit<AllQueries[K], 'field'>): B;
    andFilter<K extends QueryType>(type: K, field: string, value: Primitive | Primitive[], config: Optional<Omit<AllQueries[K], 'field'>, keyof BuiltQuery>, subBuilder: ESSubFilterBuilderFn): B;
    orFilter(subBuilder: ESSubFilterBuilderFn): B;
    orFilter<K extends QueryType>(type: K, field: string): B;
    orFilter<K extends QueryType>(type: K, config: AllQueries[K]): B;
    orFilter<K extends QueryType>(type: K, field: string, value: Primitive | Primitive[]): B;
    orFilter<K extends QueryType>(type: K, field: string, subBuilder: ESSubFilterBuilderFn): B;
    orFilter<K extends QueryType>(type: K, field: string, config: Omit<AllQueries[K], 'field'>): B;
    orFilter<K extends QueryType>(type: K, config: Optional<AllQueries[K], keyof BuiltQuery>, subBuilder: ESSubFilterBuilderFn): B;
    orFilter<K extends QueryType>(type: K, field: string, value: Primitive | Primitive[], subBuilder: ESSubFilterBuilderFn): B;
    orFilter<K extends QueryType>(type: K, field: string, value: Primitive | Primitive[], config: Omit<AllQueries[K], 'field'>): B;
    orFilter<K extends QueryType>(type: K, field: string, value: Primitive | Primitive[], config: Optional<Omit<AllQueries[K], 'field'>, keyof BuiltQuery>, subBuilder: ESSubFilterBuilderFn): B;
    notFilter(subBuilder: ESSubFilterBuilderFn): B;
    notFilter<K extends QueryType>(type: K, field: string): B;
    notFilter<K extends QueryType>(type: K, config: AllQueries[K]): B;
    notFilter<K extends QueryType>(type: K, field: string, value: Primitive | Primitive[]): B;
    notFilter<K extends QueryType>(type: K, field: string, subBuilder: ESSubFilterBuilderFn): B;
    notFilter<K extends QueryType>(type: K, field: string, config: Omit<AllQueries[K], 'field'>): B;
    notFilter<K extends QueryType>(type: K, config: Optional<AllQueries[K], keyof BuiltQuery>, subBuilder: ESSubFilterBuilderFn): B;
    notFilter<K extends QueryType>(type: K, field: string, value: Primitive | Primitive[], subBuilder: ESSubFilterBuilderFn): B;
    notFilter<K extends QueryType>(type: K, field: string, value: Primitive | Primitive[], config: Omit<AllQueries[K], 'field'>): B;
    notFilter<K extends QueryType>(type: K, field: string, value: Primitive | Primitive[], config: Optional<Omit<AllQueries[K], 'field'>, keyof BuiltQuery>, subBuilder: ESSubFilterBuilderFn): B;
    filterMinimumShouldMatch(param: string | number): B;
}
/** Represents all the different argument variations to the query methods */
declare type QueryArgs = [ESSubQueryBuilderFn] | [string, string | PlainObject] | [string, string, Primitive | Primitive[] | PlainObject | ESSubQueryBuilderFn] | [string, PlainObject, ESSubQueryBuilderFn] | [string, string, Primitive | Primitive[], PlainObject | ESSubFilterBuilderFn] | [string, string, Primitive | Primitive[], PlainObject, ESSubQueryBuilderFn];
interface ESQueryBuilder<B = ESBuilder> {
    query(subBuilder: ESSubQueryBuilderFn): B;
    query<K extends QueryType>(type: K, field: string): B;
    query<K extends QueryType>(type: K, config: AllQueries[K]): B;
    query<K extends FieldQueryType>(type: K, field: string, config: AllFieldQueryConfigs[K]): B;
    query<K extends QueryType>(type: K, field: string, value: Primitive | Primitive[]): B;
    query<K extends QueryType>(type: K, field: string, subBuilder: ESSubQueryBuilderFn): B;
    query<K extends QueryType>(type: K, config: Optional<AllQueries[K], keyof BuiltQuery>, subBuilder: ESSubQueryBuilderFn): B;
    query<K extends QueryType>(type: K, field: string, value: Primitive | Primitive[], subBuilder: ESSubQueryBuilderFn): B;
    query<K extends QueryType, F extends string>(type: K, field: F, value: Primitive | Primitive[], config: Omit<AllQueries[K], F>): B;
    query<K extends QueryType, F extends string>(type: K, field: F, value: Primitive | Primitive[], config: Optional<Omit<AllQueries[K], F>, keyof BuiltQuery>, subBuilder: ESSubQueryBuilderFn): B;
    andQuery(subBuilder: ESSubQueryBuilderFn): B;
    andQuery<K extends QueryType>(type: K, field: string): B;
    andQuery<K extends QueryType>(type: K, config: AllQueries[K]): B;
    andQuery<K extends FieldQueryType>(type: K, field: string, config: AllFieldQueryConfigs[K]): B;
    andQuery<K extends QueryType>(type: K, field: string, value: Primitive | Primitive[]): B;
    andQuery<K extends QueryType>(type: K, field: string, subBuilder: ESSubQueryBuilderFn): B;
    andQuery<K extends QueryType>(type: K, config: Optional<AllQueries[K], keyof BuiltQuery>, subBuilder: ESSubQueryBuilderFn): B;
    andQuery<K extends QueryType>(type: K, field: string, value: Primitive | Primitive[], subBuilder: ESSubQueryBuilderFn): B;
    andQuery<K extends QueryType, F extends string>(type: K, field: F, value: Primitive | Primitive[], config: Omit<AllQueries[K], F>): B;
    andQuery<K extends QueryType, F extends string>(type: K, field: F, value: Primitive | Primitive[], config: Optional<Omit<AllQueries[K], F>, keyof BuiltQuery>, subBuilder: ESSubQueryBuilderFn): B;
    orQuery(subBuilder: ESSubQueryBuilderFn): B;
    orQuery<K extends QueryType>(type: K, field: string): B;
    orQuery<K extends QueryType>(type: K, config: AllQueries[K]): B;
    orQuery<K extends FieldQueryType>(type: K, field: string, config: AllFieldQueryConfigs[K]): B;
    orQuery<K extends QueryType>(type: K, field: string, value: Primitive | Primitive[]): B;
    orQuery<K extends QueryType>(type: K, field: string, subBuilder: ESSubQueryBuilderFn): B;
    orQuery<K extends QueryType>(type: K, config: Optional<AllQueries[K], keyof BuiltQuery>, subBuilder: ESSubQueryBuilderFn): B;
    orQuery<K extends QueryType>(type: K, field: string, value: Primitive | Primitive[], subBuilder: ESSubQueryBuilderFn): B;
    orQuery<K extends QueryType, F extends string>(type: K, field: F, value: Primitive | Primitive[], config: Omit<AllQueries[K], F>): B;
    orQuery<K extends QueryType, F extends string>(type: K, field: F, value: Primitive | Primitive[], config: Optional<Omit<AllQueries[K], F>, keyof BuiltQuery>, subBuilder: ESSubQueryBuilderFn): B;
    notQuery(subBuilder: ESSubQueryBuilderFn): B;
    notQuery<K extends QueryType>(type: K, field: string): B;
    notQuery<K extends QueryType>(type: K, config: AllQueries[K]): B;
    notQuery<K extends FieldQueryType>(type: K, field: string, config: AllFieldQueryConfigs[K]): B;
    notQuery<K extends QueryType>(type: K, field: string, value: Primitive | Primitive[]): B;
    notQuery<K extends QueryType>(type: K, field: string, subBuilder: ESSubQueryBuilderFn): B;
    notQuery<K extends QueryType>(type: K, config: Optional<AllQueries[K], keyof BuiltQuery>, subBuilder: ESSubQueryBuilderFn): B;
    notQuery<K extends QueryType>(type: K, field: string, value: Primitive | Primitive[], subBuilder: ESSubQueryBuilderFn): B;
    notQuery<K extends QueryType, F extends string>(type: K, field: F, value: Primitive | Primitive[], config: Omit<AllQueries[K], F>): B;
    notQuery<K extends QueryType, F extends string>(type: K, field: F, value: Primitive | Primitive[], config: Optional<Omit<AllQueries[K], F>, keyof BuiltQuery>, subBuilder: ESSubQueryBuilderFn): B;
    queryMinimumShouldMatch(param: string | number): B;
}
/** Represents all the different argument variations to the sort method */
declare type SortArgs = [string] | [SortType[]] | [string, string] | [string, PlainObject];
interface ESBuilder extends ESBaseBuilder, ESAggregationBuilder, ESFilterBuilder, ESQueryBuilder {
    from(quantity: number): ESBuilder;
    rawOption(key: string, value: unknown): ESBuilder;
    size(quantity: number): ESBuilder;
    sort(field: string): ESBuilder;
    sort(field: string, direction: string): ESBuilder;
    sort(field: string, body: object): ESBuilder;
    sort(fields: SortType[]): ESBuilder;
}
interface ESSubAggregationBuilder extends ESBaseBuilder, ESAggregationBuilder<ESSubAggregationBuilder>, ESFilterBuilder<ESSubAggregationBuilder> {
}
declare type ESSubAggregationBuilderFn = (builder: ESSubAggregationBuilder) => ESSubAggregationBuilder;
interface ESSubFilterBuilder extends ESBaseBuilder, ESFilterBuilder<ESSubFilterBuilder>, ESQueryBuilder<ESSubFilterBuilder> {
}
declare type ESSubFilterBuilderFn = (builder: ESSubFilterBuilder) => ESSubFilterBuilder;
interface ESSubQueryBuilder extends ESBaseBuilder, ESFilterBuilder<ESSubQueryBuilder>, ESQueryBuilder<ESSubQueryBuilder> {
}
declare type ESSubQueryBuilderFn = (builder: ESSubQueryBuilder) => ESSubQueryBuilder;

/** Returns a new Elasticsearch query builder instance */
declare function esBuilder(): ESBuilder;

interface BinaryField {
    binary: {
        doc_values?: boolean;
        store?: boolean;
    };
}
interface BooleanField {
    boolean: {
        boost?: number;
        doc_values?: boolean;
        index?: boolean;
        null_value?: boolean;
        store?: boolean;
        meta?: Record<string, string>;
    };
}
interface KeywordField {
    keyword: {
        boost?: number;
        doc_values?: boolean;
        eager_global_ordinals?: boolean;
        fields?: Record<string, FieldMapping>;
        ignore_above?: number;
        index?: boolean;
        index_options?: 'docs' | 'freqs';
        norms?: boolean;
        null_value?: string;
        store?: boolean;
        similarity?: 'BM25' | 'classic' | 'boolean';
        normalizer?: string;
        split_queries_on_whitespace?: boolean;
        meta?: Record<string, string>;
    };
}
interface ConstantKeywordField {
    constant_keyword: {
        meta?: Record<string, string>;
        value?: string;
    };
}
interface WildcardField {
    wildcard: {
        ignore_above?: number;
    };
}
interface NumericFieldParameters {
    coerce?: boolean;
    boost?: number;
    doc_values?: boolean;
    ignore_malformed?: boolean;
    index?: boolean;
    null_value?: number;
    store?: boolean;
    meta?: Record<string, string>;
}
interface LongField {
    long: NumericFieldParameters;
}
interface IntegerField {
    integer: NumericFieldParameters;
}
interface ShortField {
    short: NumericFieldParameters;
}
interface ByteField {
    byte: NumericFieldParameters;
}
interface DoubleField {
    double: NumericFieldParameters;
}
interface FloatField {
    float: NumericFieldParameters;
}
interface HalfFloatField {
    half_float: NumericFieldParameters;
}
interface ScaledFloatField {
    scaled_float: NumericFieldParameters & {
        scaling_factor?: number;
    };
}
interface DateField {
    date: {
        boost?: number;
        doc_values?: boolean;
        format?: string;
        locale?: string;
        ignore_malformed?: boolean;
        index?: boolean;
        null_value?: string;
        store?: boolean;
        meta?: Record<string, string>;
    };
}
interface DateNanosField {
    date_nanos: {
        boost?: number;
        doc_values?: boolean;
        format?: string;
        locale?: string;
        ignore_malformed?: boolean;
        index?: boolean;
        null_value?: string;
        store?: boolean;
        meta?: Record<string, string>;
    };
}
interface AliasField {
    alias: {
        path: string;
    };
}
interface ObjectField {
    object: {
        dynamic?: boolean;
        enabled?: boolean;
        properties?: Record<string, FieldMapping>;
    };
}
interface FlattenedField {
    flattened: {
        boost?: number;
        depth_limit?: number;
        doc_values?: boolean;
        eager_global_ordinals?: boolean;
        ignore_above?: number;
        index?: boolean;
        index_options?: 'docs' | 'freqs';
        null_value?: string;
        similarity?: 'BM25' | 'classic' | 'boolean';
        split_queries_on_whitespace?: boolean;
    };
}
interface NestedField {
    nested: {
        dynamic?: boolean;
        properties?: Record<string, FieldMapping>;
        include_in_parent?: boolean;
        include_in_root?: boolean;
    };
}
interface JoinField {
    join: {
        relations: Record<string, string | string[]>;
        eager_global_ordinals?: boolean;
    };
}
interface RangeFieldParameters {
    coerce?: boolean;
    boost?: number;
    index?: boolean;
    store?: boolean;
}
interface IntegerRangeField {
    integer_range: RangeFieldParameters;
}
interface FloatRangeField {
    float_range: RangeFieldParameters;
}
interface LongRangeField {
    long_range: RangeFieldParameters;
}
interface DoubleRangeField {
    double_range: RangeFieldParameters;
}
interface DateRangeField {
    date_range: RangeFieldParameters;
}
interface IpRangeField {
    ip_range: RangeFieldParameters;
}
interface IpField {
    ip: {
        boost?: number;
        doc_values?: boolean;
        index?: boolean;
        null_value?: string;
        store?: boolean;
    };
}
interface HistogramField {
    histogram: {};
}
interface TextField {
    text: {
        analyzer?: string;
        boost?: number;
        eager_global_ordinals?: boolean;
        fielddata?: boolean;
        fielddata_frequency_filter?: {
            min?: number;
            max?: number;
            min_segment_size?: number;
        };
        fields?: Record<string, FieldMapping>;
        index?: boolean;
        index_options?: 'docs' | 'freq' | 'positions' | 'offsets';
        index_prefixes?: {
            min_chars?: number;
            max_chars?: number;
        };
        index_phrases?: boolean;
        norms?: boolean;
        position_increment_gap?: number;
        store?: boolean;
        search_analyzer?: string;
        search_quote_analyzer?: string;
        similarity?: 'BM25' | 'classic' | 'boolean';
        term_vector?: boolean;
        meta?: Record<string, string>;
    };
}
interface AnnotatedTextField {
    annotated_text: {};
}
interface CompletionField {
    completion: {
        analyzer?: string;
        search_analyzer?: string;
        preserve_separators?: boolean;
        preserve_position_increments?: boolean;
        max_input_length?: number;
    };
}
interface SearchAsYouTypeField {
    search_as_you_type: {
        max_shingle_size?: number;
        analyzer?: string;
        index?: boolean;
        index_options?: 'docs' | 'freq' | 'positions' | 'offsets';
        norms?: boolean;
        store?: boolean;
        search_analyzer?: string;
        search_quote_analyzer?: string;
        similarity?: 'BM25' | 'classic' | 'boolean';
        term_vector?: boolean;
    };
}
interface TokenCountField {
    token_count: {
        analyzer?: string;
        enable_position_increments?: boolean;
        boost?: number;
        doc_values?: boolean;
        index?: boolean;
        null_value?: number;
        store?: boolean;
    };
}
interface DenseVectorField {
    dense_vector: {
        dims: number;
    };
}
interface RankFeatureField {
    rank_feature: {
        positive_score_impact?: boolean;
    };
}
interface RankFeaturesField {
    rank_features: {};
}
interface GeoPointField {
    geo_point: {
        ignore_malformed?: boolean;
        ignore_z_value?: boolean;
        null_value?: unknown;
    };
}
interface GeoShapeField {
    geo_shape: {
        tree?: 'quadtree' | 'geohash';
        precision?: string;
        tree_levels?: number;
        strategy?: 'recursive' | 'term';
        distance_error_pct?: number;
        orientation?: 'right' | 'ccw' | 'counterclockwise' | 'left' | 'cw' | 'clockwise';
        points_only?: boolean;
        ignore_malformed?: boolean;
        ignore_z_value?: boolean;
        coerce?: boolean;
    };
}
interface PointField {
    point: {
        ignore_malformed?: boolean;
        ignore_z_value?: boolean;
        null_value?: unknown;
    };
}
interface ShapeField {
    shape: {
        orientation?: 'right' | 'ccw' | 'counterclockwise' | 'left' | 'cw' | 'clockwise';
        ignore_malformed?: boolean;
        ignore_z_value?: boolean;
        coerce?: boolean;
    };
}
interface PercolatorField {
    percolator: {};
}
declare type Fields = BinaryField | BooleanField | KeywordField | ConstantKeywordField | WildcardField | LongField | IntegerField | ShortField | ByteField | DoubleField | FloatField | HalfFloatField | ScaledFloatField | DateField | DateNanosField | AliasField | ObjectField | FlattenedField | NestedField | JoinField | IntegerRangeField | FloatRangeField | LongRangeField | DoubleRangeField | DateRangeField | IpRangeField | IpField | HistogramField | TextField | AnnotatedTextField | CompletionField | SearchAsYouTypeField | TokenCountField | DenseVectorField | RankFeatureField | RankFeaturesField | GeoPointField | GeoShapeField | PointField | ShapeField | PercolatorField;
declare type AllFields = BinaryField & BooleanField & KeywordField & ConstantKeywordField & WildcardField & LongField & IntegerField & ShortField & ByteField & DoubleField & FloatField & HalfFloatField & ScaledFloatField & DateField & DateNanosField & AliasField & ObjectField & FlattenedField & NestedField & JoinField & IntegerRangeField & FloatRangeField & LongRangeField & DoubleRangeField & DateRangeField & IpRangeField & IpField & HistogramField & TextField & AnnotatedTextField & CompletionField & SearchAsYouTypeField & TokenCountField & DenseVectorField & RankFeatureField & RankFeaturesField & GeoPointField & GeoShapeField & PointField & ShapeField & PercolatorField;
declare type FieldType = keyof AllFields;
declare type FieldMapping<T extends FieldType = FieldType> = {
    type: T;
} & AllFields[T];

interface Highlight {
    type?: 'unified' | 'plain' | 'fvh';
    boundary_chars?: string;
    boundary_max_scan?: number;
    boundary_scanner?: 'chars' | 'sentence' | 'word';
    boundary_scanner_locale?: 'string';
    encoder?: 'default' | 'html';
    fields?: {
        [field: string]: Highlight;
    } | {
        [field: string]: Highlight;
    }[];
    force_source?: boolean;
    fragmenter?: 'span' | 'simple';
    fragment_offset?: number;
    fragment_size?: number;
    highlight_query?: Query;
    matched_fields?: string[];
    no_match_size?: number;
    number_of_fragments?: number;
    order?: 'score';
    phrase_limit?: number;
    pre_tags?: string[];
    post_tags?: string[];
    require_field_match?: boolean;
    tags_schema?: 'styled';
}
interface Rescore {
    window_size?: number;
    query: {
        score_mode?: 'total' | 'multiply' | 'avg' | 'max' | 'min';
        rescore_query: Query;
        query_weight?: number;
        rescore_query_weight?: number;
    };
}
interface SearchBody {
    from?: number;
    size?: number;
    aggregations?: Aggregations;
    aggs?: Aggregations;
    query?: Query;
    highlight?: Highlight;
    track_total_hits?: boolean;
    track_scores?: boolean;
    sort?: Sort;
    rescore?: Rescore | Rescore[];
    search_type?: 'query_then_fetch' | 'dfs_query_then_fetch';
    stored_fields?: '_none_' | string[];
    script_fields?: {
        [field: string]: Script;
    };
    docvalue_fields?: string[];
    post_filter?: Query;
    _source?: false | string | string[] | {
        includes: string[];
    } | {
        excludes: string[];
    } | {
        includes: string[];
        excludes: string[];
    };
    slide?: {
        field?: string;
        id: number;
        max: number;
    };
    version?: boolean;
    indices_boost?: {
        [index: string]: number;
    }[];
    min_score?: number;
    collapse?: {
        field: string;
        inner_hits?: {
            name: string;
            size: number;
            sort: Sort;
        }[];
        max_concurrent_group_searches?: number;
    };
    search_after?: PrimitiveValue[];
}

export { AdjacencyMatrixAggregation, Aggregation, AggregationArgs, AggregationType, Aggregations, AliasField, AllAggregations, AllBucketAggregations, AllCompoundQueries, AllFieldQueryConfigs, AllFields, AllFullTextQueries, AllGeoQueries, AllJoiningQueries, AllMatrixAggregations, AllMetricsAggregations, AllPipelineAggregations, AllQueries, AllSpecializedQueries, AllTermLevelQueries, AnnotatedTextField, AvgAggregation, AvgBucketAggregation, BinaryField, BoolQuery, BoolQueryConfig, BooleanField, BoostingQuery, BucketAggregation, BucketScriptAggregation, BucketSelectorAggregation, BucketSortAggregation, BuilderFn, BuiltQuery, ByteField, CardinalityAggregation, ChildrenAggregation, CollectMode, CommonTermsFieldConfig, CommonTermsQuery, CompletionField, CompositeAggregation, CompoundQuery, ConstantKeywordField, ConstantScoreQuery, Coordinate, CumulativeSumAggregation, DateField, DateHistogramAggregation, DateNanosField, DateRangeAggregation, DateRangeField, DenseVectorField, DerivativeAggregation, DisMaxQuery, DiversifiedSamplerAggregation, DoubleField, DoubleRangeField, ESAggregationBuilder, ESBaseBuilder, ESBuilder, ESFilterBuilder, ESQueryBuilder, ESSubAggregationBuilder, ESSubAggregationBuilderFn, ESSubFilterBuilder, ESSubFilterBuilderFn, ESSubQueryBuilder, ESSubQueryBuilderFn, ExistsQuery, ExtendedStatsAggregation, ExtendedStatsBucketAggregation, FieldMapping, FieldQueryConfig, FieldQueryType, FieldSortOptions, FieldType, Fields, FilterAggregation, FilterArgs, FiltersAggregation, FlattenedField, FloatField, FloatRangeField, FullTextQuery, FunctionScoreQuery, FuzzyFieldConfig, FuzzyQuery, GeoBoundingBoxFieldConfig, GeoBoundingBoxQuery, GeoBoundsAggregation, GeoCentroidAggregation, GeoDistanceAggregation, GeoDistanceQuery, GeoHashGridAggregation, GeoPointField, GeoPolygonFieldConfig, GeoPolygonQuery, GeoQuery, GeoShapeField, GeoShapeQuery, GlobalAggregation, HalfFloatField, HasChildQuery, HasParentQuery, Highlight, HistogramAggregation, HistogramField, IPRangeAggregation, IdsQuery, IntegerField, IntegerRangeField, IpField, IpRangeField, JoinField, JoiningQuery, KeywordField, LongField, LongRangeField, MatchAllQuery, MatchNoneQuery, MatchPhraseFieldConfig, MatchPhrasePrefixFieldConfig, MatchPhrasePrefixQuery, MatchPhraseQuery, MatchQuery, MatchQueryFieldConfig, MatrixAggregation, MatrixStatsAggregation, MaxAggregation, MaxBucketAggregation, MetricsAggregation, MinAggregation, MinBucketAggregation, MissingAggregation, MoreLikeThisQuery, MovingAverageBucketAggregation, MultiMatchQuery, NestedAggregation, NestedField, NestedQuery, NestedSort, NumericFieldParameters, ObjectField, ParentIdQuery, PercentileRanksAggregation, PercentilesAggregation, PercentilesBucketAggregation, PercolateQuery, PercolatorField, PipelineAggregation, PointField, PrefixFieldConfig, PrefixQuery, PrimitiveValue, PrimitiveValueArray, Query, QueryArgs, QueryData, QueryStringQuery, QueryType, RangeAggregation, RangeFieldConfig, RangeFieldParameters, RangeQuery, RankFeatureField, RankFeatureQuery, RankFeaturesField, RegexpFieldConfig, RegexpQuery, Rescore, ReverseNestedAggregation, SamplerAggregation, ScaledFloatField, Script, ScriptQuery, ScriptScoreQuery, ScriptedMetricAggregation, SearchAsYouTypeField, SearchBody, SerialDifferencingAggregation, ShapeField, ShortField, SignificantTermsAggregation, SignificantTextAggregation, SimpleQueryStringQuery, Sort, SortArgs, SortOrder, SortType, SpecializedQuery, StatsAggregation, StatsBucketAggregation, SumAggregation, SumBucketAggregation, TermFieldConfig, TermLevelQuery, TermQuery, TermsAggregation, TermsFieldConfig, TermsQuery, TermsSetFieldConfig, TermsSetQuery, TextField, TokenCountField, TopHitsAggregation, TypeQuery, ValueCountAggregation, WildcardField, WildcardFieldConfig, WildcardQuery, WithBuilderFns, WrapperQuery, esBuilder };
