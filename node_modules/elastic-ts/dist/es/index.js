import is from '@sindresorhus/is';

/** buildAggregation takes arguments passed to a query or filter and transforms them into a query clause */
function buildAggregation(args) {
    switch (args.length) {
        case 3:
            return buildAggregation3(args);
        case 4:
            return buildAggregation4(args);
        case 5:
            return buildAggregation5(args);
        default:
            throw new TypeError('invalid arguments');
    }
}
function buildAggregation3([name, type, fieldOrConfig]) {
    if (is.string(fieldOrConfig)) {
        const field = fieldOrConfig;
        return { [name]: { [type]: { field } } };
    }
    const config = fieldOrConfig;
    return { [name]: { [type]: { ...config } } };
}
function buildAggregation4([name, type, fieldOrConfig, configOrBuilder]) {
    if (is.string(fieldOrConfig)) {
        const field = fieldOrConfig;
        if (is.function_(configOrBuilder)) {
            const builder = configOrBuilder;
            return { [name]: { [type]: { field }, ...builder().build() } };
        }
        const config = configOrBuilder;
        return { [name]: { [type]: { field, ...config } } };
    }
    if (is.function_(configOrBuilder)) {
        const config = fieldOrConfig;
        const builder = configOrBuilder;
        return { [name]: { [type]: { ...config }, ...builder().build() } };
    }
    throw new TypeError('invalid arguments');
}
function buildAggregation5([name, type, field, config, builder]) {
    return { [name]: { [type]: { field, ...config }, ...builder().build() } };
}

/** buildClause takes arguments passed to a query or filter and transforms them into a query clause */
function buildClause(data, args) {
    switch (args.length) {
        case 1:
            return buildClause1(data, args);
        case 2:
            return buildClause2(args);
        case 3:
            return buildClause3(args);
        case 4:
            return buildClause4(args);
        case 5:
            return buildClause5(args);
        default:
            throw new TypeError('invalid args');
    }
}
function buildClause1(data, [builder]) {
    const built = builder().build();
    return (data.parent ? built[data.parent] : built.filter || built.query) || {};
}
function buildClause2([type, fieldOrConfig]) {
    if (is.string(fieldOrConfig)) {
        const field = fieldOrConfig;
        return { [type]: { field } };
    }
    const config = fieldOrConfig;
    return { [type]: { ...config } };
}
function buildClause3([type, fieldOrConfig, valueOrConfigOrBuilder]) {
    if (is.string(fieldOrConfig)) {
        const field = fieldOrConfig;
        if (is.function_(valueOrConfigOrBuilder)) {
            const builder = valueOrConfigOrBuilder;
            return { [type]: { [field]: builder().build() } };
        }
        if (is.plainObject(valueOrConfigOrBuilder)) {
            const config = valueOrConfigOrBuilder;
            return { [type]: { [field]: config } };
        }
        const value = valueOrConfigOrBuilder;
        return { [type]: { [field]: value } };
    }
    if (is.function_(valueOrConfigOrBuilder)) {
        const config = fieldOrConfig;
        const builder = valueOrConfigOrBuilder;
        return { [type]: { ...config, ...builder().build() } };
    }
    throw new TypeError('invalid argument');
}
function buildClause4([type, field, value, configOrBuilder]) {
    if (is.function_(configOrBuilder)) {
        const builder = configOrBuilder;
        return { [type]: { [field]: value, ...builder().build() } };
    }
    const config = configOrBuilder;
    return { [type]: { [field]: value, ...config } };
}
function buildClause5([type, field, value, config, builder]) {
    return { [type]: { [field]: value, ...config, ...builder().build() } };
}

function deduplicateSort(configs) {
    const seenFields = new Set();
    return configs
        .reverse()
        .filter((config) => {
        const field = Object.keys(config)[0];
        if (seenFields.has(field) && field !== '_geo_distance') {
            return false;
        }
        seenFields.add(field);
        return true;
    })
        .reverse();
}
/** buildSort takes arguments passed to the sort function and transforms them into configs */
function buildSort(args) {
    switch (args.length) {
        case 1:
            return buildSort1(args);
        case 2:
            return buildSort2(args);
        default:
            throw new TypeError('invalid arguments');
    }
}
function buildSort1([fieldOrConfigArray]) {
    if (is.string(fieldOrConfigArray)) {
        const field = fieldOrConfigArray;
        return { [field]: { order: 'asc' } };
    }
    const configArray = fieldOrConfigArray;
    return configArray.map((item) => {
        if (is.string(item)) {
            const field = item;
            return { [field]: { order: 'asc' } };
        }
        else {
            const keys = Object.keys(item);
            if (keys.length !== 1) {
                throw new TypeError('invalid argument');
            }
            const field = keys[0];
            const orderOrConfig = item[field];
            if (is.string(orderOrConfig)) {
                const order = orderOrConfig;
                return { [field]: { order } };
            }
            else {
                const config = orderOrConfig;
                return { [field]: { ...config } };
            }
        }
    });
}
function buildSort2([field, orderOrConfig]) {
    if (is.string(orderOrConfig)) {
        const order = orderOrConfig;
        return { [field]: { order } };
    }
    const config = orderOrConfig;
    return { [field]: { ...config } };
}

function flatMap(items, callbackfn) {
    const results = [];
    let idx = 0;
    for (const item of items) {
        const result = callbackfn(item, idx++, items);
        if (Array.isArray(result)) {
            for (const r of result) {
                results.push(r);
            }
        }
        else {
            results.push(result);
        }
    }
    return results;
}

/**
 * simplifyClauses transforms an array into a single value if length === 1,
 * otherwise it returns the original array.
 */
function simplifyClauses(items) {
    if (items.length === 1) {
        return items[0];
    }
    return items;
}
function buildBool(data) {
    if (data.or.length === 0 && data.not.length === 0 && !data.filter) {
        if (data.and.length === 1) {
            return data.and[0];
        }
        else if (data.and.length === 0) {
            return undefined;
        }
    }
    const totalCount = data.and.length + data.or.length + data.not.length;
    return {
        bool: {
            ...(data.and.length ? { must: simplifyClauses(data.and) } : {}),
            ...(data.or.length ? { should: simplifyClauses(data.or) } : {}),
            ...(data.not.length ? { must_not: simplifyClauses(data.not) } : {}),
            ...(data.filter ? { filter: data.filter } : {}),
            ...(data.minimumShouldMatch != null && totalCount > 1 ? { minimum_should_match: data.minimumShouldMatch } : {}),
        },
    };
}
function buildBody(data) {
    const built = {};
    const { aggregations, filter, query } = data;
    function buildClauses(clauses) {
        return clauses.map((args) => buildClause(data, args)).filter((c) => c);
    }
    const builtFilter = buildBool({
        and: buildClauses(filter.and),
        or: buildClauses(filter.or),
        not: buildClauses(filter.not),
        minimumShouldMatch: filter.minimumShouldMatch,
    });
    if (data.inChildContext) {
        if (builtFilter) {
            built.filter = builtFilter;
        }
    }
    const builtQuery = buildBool({
        and: buildClauses(query.and),
        or: buildClauses(query.or),
        not: buildClauses(query.not),
        filter: data.inChildContext ? undefined : builtFilter,
        minimumShouldMatch: query.minimumShouldMatch,
    });
    if (builtQuery) {
        built.query = builtQuery;
    }
    if (data.from != null) {
        built.from = data.from;
    }
    if (data.size != null) {
        built.size = data.size;
    }
    if (data.sort.length) {
        built.sort = deduplicateSort(flatMap(data.sort, (args) => buildSort(args)));
    }
    if (is.nonEmptyObject(aggregations)) {
        built.aggs = aggregations.reduce((acc, args) => ({
            ...acc,
            ...buildAggregation(args),
        }), {});
    }
    return { ...built, ...data.rawOption };
}

/** Returns a new Elasticsearch query builder instance */
function esBuilder() {
    return builderBuilder();
}
function defaultData() {
    return {
        aggregations: [],
        filter: {
            and: [],
            or: [],
            not: [],
            minimumShouldMatch: undefined,
        },
        from: undefined,
        inChildContext: false,
        size: undefined,
        sort: [],
        query: {
            and: [],
            or: [],
            not: [],
            minimumShouldMatch: undefined,
        },
        rawOption: {},
    };
}
function prepareSubBuilderArgs(args, replacement) {
    args.forEach((arg, i) => {
        if (is.function_(arg)) {
            args[i] = () => arg(replacement());
        }
    });
    return args;
}
/** Returns the entire ES query builder */
function builderBuilder(data = defaultData()) {
    return {
        from(quantity) {
            return builderBuilder({ ...data, from: quantity });
        },
        size(quantity) {
            return builderBuilder({ ...data, size: quantity });
        },
        rawOption(key, value) {
            return builderBuilder({ ...data, rawOption: { ...data.rawOption, [key]: value } });
        },
        sort(...args) {
            return builderBuilder({ ...data, sort: [...data.sort, args] });
        },
        ...aggregationBuilder(data),
        ...baseBuilder(data),
        ...filterBuilder(data),
        ...queryBuilder(data),
    };
}
/** Returns builder functions for aggregations */
function aggregationBuilder(data) {
    const { aggregations } = data;
    function bindSubBuilder(args) {
        return prepareSubBuilderArgs(args, () => {
            const next = { ...defaultData(), inChildContext: true };
            return { ...aggregationBuilder(next), ...baseBuilder(next), ...filterBuilder(next), ...queryBuilder(next) };
        });
    }
    const aggregation = (...args) => {
        return builderBuilder({
            ...data,
            aggregations: [...aggregations, bindSubBuilder(args)],
        });
    };
    return {
        agg: aggregation,
        aggregation,
    };
}
/** Returns base builder function */
function baseBuilder(data) {
    return {
        build() {
            return buildBody(data);
        },
    };
}
/** Returns builder functions for filters */
function filterBuilder(data) {
    const { filter } = data;
    function bindSubBuilder(args) {
        return prepareSubBuilderArgs(args, () => {
            const next = { parent: 'filter', ...defaultData(), inChildContext: true };
            return { ...baseBuilder(next), ...filterBuilder(next), ...(data.parent === 'query' ? queryBuilder(next) : {}) };
        });
    }
    return {
        filter(...args) {
            return builderBuilder({
                ...data,
                filter: { ...filter, and: [...filter.and, bindSubBuilder(args)] },
            });
        },
        andFilter(...args) {
            return builderBuilder({
                ...data,
                filter: { ...filter, and: [...filter.and, bindSubBuilder(args)] },
            });
        },
        orFilter(...args) {
            return builderBuilder({
                ...data,
                filter: { ...filter, or: [...filter.or, bindSubBuilder(args)] },
            });
        },
        notFilter(...args) {
            return builderBuilder({
                ...data,
                filter: { ...filter, not: [...filter.not, bindSubBuilder(args)] },
            });
        },
        filterMinimumShouldMatch(minimumShouldMatch) {
            return builderBuilder({ ...data, filter: { ...filter, minimumShouldMatch } });
        },
    };
}
/** Returns builder functions for queries */
function queryBuilder(data) {
    const { query } = data;
    function bindSubBuilder(args) {
        return prepareSubBuilderArgs(args, () => {
            const next = { parent: 'query', ...defaultData(), inChildContext: true };
            return { ...baseBuilder(next), ...filterBuilder(next), ...queryBuilder(next) };
        });
    }
    return {
        query(...args) {
            return builderBuilder({ ...data, query: { ...query, and: [...query.and, bindSubBuilder(args)] } });
        },
        andQuery(...args) {
            return builderBuilder({ ...data, query: { ...query, and: [...query.and, bindSubBuilder(args)] } });
        },
        orQuery(...args) {
            return builderBuilder({ ...data, query: { ...query, or: [...query.or, bindSubBuilder(args)] } });
        },
        notQuery(...args) {
            return builderBuilder({ ...data, query: { ...query, not: [...query.not, bindSubBuilder(args)] } });
        },
        queryMinimumShouldMatch(minimumShouldMatch) {
            return builderBuilder({ ...data, query: { ...query, minimumShouldMatch } });
        },
    };
}

export { esBuilder };
//# sourceMappingURL=index.js.map
