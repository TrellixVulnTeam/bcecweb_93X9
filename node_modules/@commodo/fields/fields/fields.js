"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _objectWithoutProperties2 = _interopRequireDefault(require("@babel/runtime/helpers/objectWithoutProperties"));

var _WithFieldsError = _interopRequireDefault(require("./../WithFieldsError"));

var _repropose = require("repropose");

var _fields = require("@commodo/fields");

var _name = require("@commodo/name");

var _withFieldDataTypeValidation = _interopRequireDefault(require("./withFieldDataTypeValidation"));

var _createField = _interopRequireDefault(require("./createField"));

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

const prepareValue = ({
  value,
  instanceOf,
  instanceOfModels,
  instanceOfModelField
}) => {
  if (!value) {
    return null;
  }

  let returnValue;

  if ((0, _fields.hasFields)(value)) {
    // We already know the value is a valid model instance (see "withFieldDataTypeValidation" below).
    returnValue = value;

    if (instanceOfModelField) {
      returnValue[instanceOfModelField] = (0, _name.getName)(returnValue);
    }
  } else {
    let Model = instanceOf;

    if (instanceOfModels) {
      const instanceOfModelFieldValue = value[instanceOfModelField];

      if (!instanceOfModelFieldValue) {
        throw new _WithFieldsError.default(`Cannot set value to a "fields" field - the "${instanceOfModelField}" property of the received plain object is missing.`, _WithFieldsError.default.RECEIVED_DATA_OBJECT_TYPE_VALUE_IS_MISSING);
      }

      Model = instanceOfModels.find(Model => {
        return (0, _name.getName)(Model) === instanceOfModelFieldValue;
      });

      if (!Model) {
        throw new _WithFieldsError.default(`Cannot set value to a "fields" field - the "${instanceOfModelField}" property of the received plain object contains an invalid value ${instanceOfModelFieldValue}.`, _WithFieldsError.default.RECEIVED_DATA_OBJECT_CONTAINS_INVALID_TYPE_VALUE);
      }
    }

    returnValue = new Model();

    if (typeof returnValue.populate === "function") {
      returnValue.populate(value);
    } else {
      throw new _WithFieldsError.default(`Cannot populate model "${instanceOf}" - "populate" method missing. Forgot to use "withFields"?`, _WithFieldsError.default.MODEL_POPULATE_MISSING);
    }

    if (instanceOfModelField) {
      returnValue[instanceOfModelField] = (0, _name.getName)(returnValue);
    }
  } // We did already assign a value to the "instanceOfModelField" field on the "returnValue" model instance above.
  // But, was that really a field that was defined on the model instance? Let's just try to get the field, and
  // ensure that was really a field that we were assigning a value to.


  if (instanceOfModelField) {
    if (!returnValue.getField(instanceOfModelField)) {
      throw new _WithFieldsError.default(`Cannot set value to a "fields" field - the "${(0, _name.getName)(returnValue)}" should contain the "${instanceOfModelField}" string field, but it does not.`, _WithFieldsError.default.DATA_MODEL_MODEL_TYPE_FIELD_DOES_NOT_EXIST);
    }
  }

  return returnValue;
};

const fields = (_ref) => {
  let {
    list,
    instanceOf
  } = _ref,
      rest = (0, _objectWithoutProperties2.default)(_ref, ["list", "instanceOf"]);

  if (!instanceOf) {
    throw new _WithFieldsError.default(`When defining a "fields" field, "instanceOf" argument must be set.`, _WithFieldsError.default.MODEL_FIELD_INSTANCEOF_NOT_SET);
  }

  let instanceOfModels;
  let instanceOfModelField;

  if (Array.isArray(instanceOf)) {
    instanceOfModels = [...instanceOf];
    [instanceOfModelField] = instanceOfModels.splice(-1, 1);

    if (typeof instanceOfModelField !== "string") {
      throw new _WithFieldsError.default(`Invalid "fields" field - when passing "instanceOf" as an array, the last item must be a string, marking the field name that will contain the model type.`, _WithFieldsError.default.INSTANCE_OF_ARRAY_LAST_ITEM_NOT_STRING);
    }
  }

  const field = (0, _createField.default)(_objectSpread(_objectSpread({}, rest), {}, {
    list,
    type: "fields"
  }));
  (0, _repropose.withProps)(instance => {
    const {
      setValue,
      validate,
      isDirty,
      clean
    } = instance;
    return {
      instanceOf,
      instanceOfModels,
      instanceOfModelField,

      async getJSONValue() {
        if (!instance.current) {
          return null;
        }

        if (instance.list) {
          const output = [];

          for (let i = 0; i < instance.current.length; i++) {
            output.push(await instance.current[i].toJSON());
          }

          return output;
        }

        return instance.current.toJSON();
      },

      isDirty() {
        if (isDirty.call(this)) {
          return true;
        }

        if (instance.current === null) {
          return false;
        }

        if (instance.list) {
          for (let i = 0; i < instance.current.length; i++) {
            let currentElement = instance.current[i];

            if (currentElement.isDirty()) {
              return true;
            }
          }

          return false;
        }

        return (0, _fields.hasFields)(instance.current) && instance.current.isDirty();
      },

      clean() {
        clean.call(this);

        if (instance.current === null) {
          return this;
        }

        if (instance.list) {
          for (let i = 0; i < instance.current.length; i++) {
            let currentElement = instance.current[i];

            if (currentElement.isDirty()) {
              currentElement.clean();
            }
          }

          return this;
        }

        if (instance.current.isDirty()) {
          instance.current.clean();
        }

        return this;
      },

      setValue(value) {
        if (value === null) {
          return setValue.call(this, null);
        }

        if (this.list) {
          const preparedValues = [];
          value.forEach(item => preparedValues.push(prepareValue({
            value: item,
            instanceOf,
            instanceOfModels,
            instanceOfModelField
          })));
          return setValue.call(this, preparedValues);
        }

        const preparedValue = prepareValue({
          value,
          instanceOf,
          instanceOfModels,
          instanceOfModelField
        });
        return setValue.call(this, preparedValue);
      },

      async validate() {
        await validate.call(this);

        if (this.current === null) {
          return;
        }

        if (this.list) {
          const errors = [];

          for (let i = 0; i < this.current.length; i++) {
            const current = this.current[i];

            try {
              current && (await current.validate());
            } catch (e) {
              errors.push({
                code: e.code,
                data: _objectSpread({
                  index: i
                }, e.data),
                message: e.message
              });
            }
          }

          if (errors.length > 0) {
            throw new _WithFieldsError.default("Validation failed.", _WithFieldsError.default.VALIDATION_FAILED_INVALID_FIELD, errors);
          }

          return;
        }

        this.current && (await this.current.validate());
      }

    };
  })(field);
  (0, _withFieldDataTypeValidation.default)(value => {
    if (typeof value !== "object") {
      return false;
    } // If a plain object was set, just return true (the data will be used to populate a new model instance).


    if (!(0, _fields.hasFields)(value)) {
      return true;
    }

    let normalizedInstanceOf = instanceOfModels || [instanceOf];
    return Boolean(normalizedInstanceOf.find(Model => {
      // If both received value and instanceOf has a name attached, let's compare by it.
      if ((0, _name.hasName)(value) && (0, _name.hasName)(Model)) {
        return (0, _name.getName)(value) === (0, _name.getName)(Model);
      } // Otherwise, just do a good old instanceof check.


      return value instanceof Model;
    }));
  })(field);
  return field;
};

var _default = fields;
exports.default = _default;
//# sourceMappingURL=fields.js.map