{"version":3,"sources":["../../src/fields/fields.js"],"names":["prepareValue","value","instanceOf","instanceOfModels","instanceOfModelField","returnValue","Model","instanceOfModelFieldValue","WithFieldsError","RECEIVED_DATA_OBJECT_TYPE_VALUE_IS_MISSING","find","RECEIVED_DATA_OBJECT_CONTAINS_INVALID_TYPE_VALUE","populate","MODEL_POPULATE_MISSING","getField","DATA_MODEL_MODEL_TYPE_FIELD_DOES_NOT_EXIST","fields","list","rest","MODEL_FIELD_INSTANCEOF_NOT_SET","Array","isArray","splice","INSTANCE_OF_ARRAY_LAST_ITEM_NOT_STRING","field","type","instance","setValue","validate","isDirty","clean","getJSONValue","current","output","i","length","push","toJSON","call","currentElement","preparedValues","forEach","item","preparedValue","errors","e","code","data","index","message","VALIDATION_FAILED_INVALID_FIELD","normalizedInstanceOf","Boolean"],"mappings":"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","sourcesContent":["import type { FieldFactory } from \"@commodo/fields/types\";\nimport WithFieldsError from \"./../WithFieldsError\";\nimport { withProps } from \"repropose\";\nimport { hasFields } from \"@commodo/fields\";\nimport { getName, hasName } from \"@commodo/name\";\nimport withFieldDataTypeValidation from \"./withFieldDataTypeValidation\";\nimport createField from \"./createField\";\n\nconst prepareValue = ({ value, instanceOf, instanceOfModels, instanceOfModelField }) => {\n    if (!value) {\n        return null;\n    }\n\n    let returnValue;\n\n    if (hasFields(value)) {\n        // We already know the value is a valid model instance (see \"withFieldDataTypeValidation\" below).\n        returnValue = value;\n        if (instanceOfModelField) {\n            returnValue[instanceOfModelField] = getName(returnValue);\n        }\n    } else {\n        let Model = instanceOf;\n        if (instanceOfModels) {\n            const instanceOfModelFieldValue = value[instanceOfModelField];\n            if (!instanceOfModelFieldValue) {\n                throw new WithFieldsError(\n                    `Cannot set value to a \"fields\" field - the \"${instanceOfModelField}\" property of the received plain object is missing.`,\n                    WithFieldsError.RECEIVED_DATA_OBJECT_TYPE_VALUE_IS_MISSING\n                );\n            }\n\n            Model = instanceOfModels.find(Model => {\n                return getName(Model) === instanceOfModelFieldValue;\n            });\n\n            if (!Model) {\n                throw new WithFieldsError(\n                    `Cannot set value to a \"fields\" field - the \"${instanceOfModelField}\" property of the received plain object contains an invalid value ${instanceOfModelFieldValue}.`,\n                    WithFieldsError.RECEIVED_DATA_OBJECT_CONTAINS_INVALID_TYPE_VALUE\n                );\n            }\n        }\n\n        returnValue = new Model();\n\n        if (typeof returnValue.populate === \"function\") {\n            returnValue.populate(value);\n        } else {\n            throw new WithFieldsError(\n                `Cannot populate model \"${instanceOf}\" - \"populate\" method missing. Forgot to use \"withFields\"?`,\n                WithFieldsError.MODEL_POPULATE_MISSING\n            );\n        }\n\n        if (instanceOfModelField) {\n            returnValue[instanceOfModelField] = getName(returnValue);\n        }\n    }\n\n    // We did already assign a value to the \"instanceOfModelField\" field on the \"returnValue\" model instance above.\n    // But, was that really a field that was defined on the model instance? Let's just try to get the field, and\n    // ensure that was really a field that we were assigning a value to.\n    if (instanceOfModelField) {\n        if (!returnValue.getField(instanceOfModelField)) {\n            throw new WithFieldsError(\n                `Cannot set value to a \"fields\" field - the \"${getName(\n                    returnValue\n                )}\" should contain the \"${instanceOfModelField}\" string field, but it does not.`,\n                WithFieldsError.DATA_MODEL_MODEL_TYPE_FIELD_DOES_NOT_EXIST\n            );\n        }\n    }\n\n    return returnValue;\n};\n\nconst fields: FieldFactory = ({ list, instanceOf, ...rest }: Object) => {\n    if (!instanceOf) {\n        throw new WithFieldsError(\n            `When defining a \"fields\" field, \"instanceOf\" argument must be set.`,\n            WithFieldsError.MODEL_FIELD_INSTANCEOF_NOT_SET\n        );\n    }\n\n    let instanceOfModels;\n    let instanceOfModelField;\n    if (Array.isArray(instanceOf)) {\n        instanceOfModels = [...instanceOf];\n        [instanceOfModelField] = instanceOfModels.splice(-1, 1);\n        if (typeof instanceOfModelField !== \"string\") {\n            throw new WithFieldsError(\n                `Invalid \"fields\" field - when passing \"instanceOf\" as an array, the last item must be a string, marking the field name that will contain the model type.`,\n                WithFieldsError.INSTANCE_OF_ARRAY_LAST_ITEM_NOT_STRING\n            );\n        }\n    }\n\n    const field = createField({ ...rest, list, type: \"fields\" });\n    withProps(instance => {\n        const { setValue, validate, isDirty, clean } = instance;\n\n        return {\n            instanceOf,\n            instanceOfModels,\n            instanceOfModelField,\n            async getJSONValue() {\n                if (!instance.current) {\n                    return null;\n                }\n\n                if (instance.list) {\n                    const output = [];\n                    for (let i = 0; i < instance.current.length; i++) {\n                        output.push(await instance.current[i].toJSON());\n                    }\n                    return output;\n                }\n\n                return instance.current.toJSON();\n            },\n            isDirty() {\n                if (isDirty.call(this)) {\n                    return true;\n                }\n\n                if (instance.current === null) {\n                    return false;\n                }\n\n                if (instance.list) {\n                    for (let i = 0; i < instance.current.length; i++) {\n                        let currentElement = instance.current[i];\n                        if (currentElement.isDirty()) {\n                            return true;\n                        }\n                    }\n                    return false;\n                }\n\n                return hasFields(instance.current) && instance.current.isDirty();\n            },\n            clean() {\n                clean.call(this);\n                if (instance.current === null) {\n                    return this;\n                }\n\n                if (instance.list) {\n                    for (let i = 0; i < instance.current.length; i++) {\n                        let currentElement = instance.current[i];\n                        if (currentElement.isDirty()) {\n                            currentElement.clean();\n                        }\n                    }\n                    return this;\n                }\n\n                if (instance.current.isDirty()) {\n                    instance.current.clean();\n                }\n\n                return this;\n            },\n            setValue(value) {\n                if (value === null) {\n                    return setValue.call(this, null);\n                }\n\n                if (this.list) {\n                    const preparedValues = [];\n                    value.forEach(item =>\n                        preparedValues.push(\n                            prepareValue({\n                                value: item,\n                                instanceOf,\n                                instanceOfModels,\n                                instanceOfModelField\n                            })\n                        )\n                    );\n                    return setValue.call(this, preparedValues);\n                }\n\n                const preparedValue = prepareValue({\n                    value,\n                    instanceOf,\n                    instanceOfModels,\n                    instanceOfModelField\n                });\n                return setValue.call(this, preparedValue);\n            },\n            async validate() {\n                await validate.call(this);\n\n                if (this.current === null) {\n                    return;\n                }\n\n                if (this.list) {\n                    const errors = [];\n                    for (let i = 0; i < this.current.length; i++) {\n                        const current = this.current[i];\n                        try {\n                            current && (await current.validate());\n                        } catch (e) {\n                            errors.push({\n                                code: e.code,\n                                data: { index: i, ...e.data },\n                                message: e.message\n                            });\n                        }\n                    }\n\n                    if (errors.length > 0) {\n                        throw new WithFieldsError(\n                            \"Validation failed.\",\n                            WithFieldsError.VALIDATION_FAILED_INVALID_FIELD,\n                            errors\n                        );\n                    }\n                    return;\n                }\n\n                this.current && (await this.current.validate());\n            }\n        };\n    })(field);\n\n    withFieldDataTypeValidation(value => {\n        if (typeof value !== \"object\") {\n            return false;\n        }\n\n        // If a plain object was set, just return true (the data will be used to populate a new model instance).\n        if (!hasFields(value)) {\n            return true;\n        }\n\n        let normalizedInstanceOf = instanceOfModels || [instanceOf];\n        return Boolean(\n            normalizedInstanceOf.find(Model => {\n                // If both received value and instanceOf has a name attached, let's compare by it.\n                if (hasName(value) && hasName(Model)) {\n                    return getName(value) === getName(Model);\n                }\n\n                // Otherwise, just do a good old instanceof check.\n                return value instanceof Model;\n            })\n        );\n    })(field);\n\n    return field;\n};\n\nexport default fields;\n"],"file":"fields.js"}