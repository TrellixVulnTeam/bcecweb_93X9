"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Tenancy = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _mdbid = _interopRequireDefault(require("mdbid"));

var _TenantPlugin = require("./plugins/TenantPlugin");

var _TenancyLoaders = require("./TenancyLoaders");

var _dbArgs = require("./dbArgs");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

const tenantCache = {};

class Tenancy {
  constructor(context) {
    (0, _defineProperty2.default)(this, "_context", void 0);
    (0, _defineProperty2.default)(this, "_currentTenant", void 0);
    (0, _defineProperty2.default)(this, "_loaders", void 0);
    this._context = context;
    this._loaders = new _TenancyLoaders.TenancyLoaders(context);
  }

  get plugins() {
    return this._context.plugins.byType(_TenantPlugin.TenantPlugin.type);
  }

  async init() {
    await this.determineCurrentTenant();
  }

  async getRootTenant() {
    return this._loaders.getTenant.load("root");
  }

  getCurrentTenant() {
    return this._currentTenant;
  }
  /**
   * Get tenant by ID
   * @param id
   */


  getTenantById(id) {
    return this._loaders.getTenant.load(id);
  }

  setCurrentTenant(tenant) {
    this._currentTenant = tenant;
  }

  async listTenants({
    parent
  }) {
    const [tenants] = await this._context.db.read(_objectSpread(_objectSpread({}, _dbArgs.dbArgs), {}, {
      query: {
        GSI1_PK: `T#${parent}`,
        GSI1_SK: {
          $beginsWith: "T#"
        }
      },
      sort: {
        SK: -1
      }
    }));
    return tenants;
  }

  async createTenant(data) {
    var _data$id;

    const tenant = _objectSpread(_objectSpread({}, data), {}, {
      id: (_data$id = data.id) !== null && _data$id !== void 0 ? _data$id : (0, _mdbid.default)()
    });

    await this.executeCallback("beforeCreate", {
      tenant,
      context: this._context
    });
    await this._context.db.create(_objectSpread(_objectSpread({}, _dbArgs.dbArgs), {}, {
      data: _objectSpread({
        PK: `T#${tenant.id}`,
        SK: "A",
        TYPE: "security.tenant",
        GSI1_PK: data.parent ? `T#${data.parent}` : undefined,
        GSI1_SK: data.parent ? `T#${tenant.id}` : undefined
      }, tenant)
    }));
    await this.executeCallback("afterCreate", {
      tenant,
      context: this._context
    });
    return tenant;
  }

  async updateTenant(id, data) {
    const [[tenant]] = await this._context.db.read(_objectSpread(_objectSpread({}, _dbArgs.dbArgs), {}, {
      query: {
        PK: `T#${id}`,
        SK: "A"
      }
    }));
    await this.executeCallback("beforeUpdate", {
      inputData: data,
      updateData: _objectSpread({}, data),
      tenant,
      context: this._context
    });
    await this._context.db.update(_objectSpread(_objectSpread({}, _dbArgs.dbArgs), {}, {
      query: {
        PK: `T#${id}`,
        SK: "A"
      },
      data
    }));
    await this.executeCallback("afterUpdate", {
      inputData: data,
      tenant,
      context: this._context
    });
    return true;
  }

  async deleteTenant(id) {
    const [[tenant]] = await this._context.db.read(_objectSpread(_objectSpread({}, _dbArgs.dbArgs), {}, {
      query: {
        PK: `T#${id}`,
        SK: "A"
      }
    }));
    await this.executeCallback("beforeDelete", {
      tenant,
      context: this._context
    });
    await this._context.db.delete(_objectSpread(_objectSpread({}, _dbArgs.dbArgs), {}, {
      query: {
        PK: `T#${id}`,
        SK: "A"
      }
    }));
    await this.executeCallback("afterDelete", {
      tenant,
      context: this._context
    });
    return true;
  }

  async determineCurrentTenant() {
    const {
      headers = {}
    } = this._context.http.request;
    let tenantId = headers["X-Tenant"] || headers["x-tenant"];

    if (!tenantId) {
      tenantId = "root";
    }

    if (!tenantCache[tenantId]) {
      const tenant = await this.getTenantById(tenantId);

      if (tenant) {
        tenantCache[tenantId] = tenant;
      }
    }

    this.setCurrentTenant(tenantCache[tenantId]);
  }

  async executeCallback(callback, params) {
    for (const plugin of this.plugins) {
      if (typeof plugin[callback] === "function") {
        await plugin[callback](params);
      }
    }
  }

}

exports.Tenancy = Tenancy;
//# sourceMappingURL=Tenancy.js.map