{"version":3,"sources":["../src/PluginsContainer.ts"],"names":["isOptionsObject","item","Array","isArray","type","name","normalizeArgs","args","options","length","splice","assign","plugins","target","i","plugin","_name","skipExisting","init","PluginsContainer","constructor","register","byName","byType","_byTypeCache","from","findByType","atLeastOneByType","list","Error","oneByType","all","Object","values","unregister","filter","pl"],"mappings":"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","sourcesContent":["import { Plugin } from \"./types\";\nimport uniqid from \"uniqid\";\n\nconst isOptionsObject = item => item && !Array.isArray(item) && !item.type && !item.name;\nconst normalizeArgs = args => {\n    let options = {};\n\n    // Check if last item in the plugins array is actually an options object.\n    if (isOptionsObject(args[args.length - 1])) {\n        [options] = args.splice(-1, 1);\n    }\n\n    return [args, options];\n};\n\nconst assign = (plugins: any, options, target: Object): void => {\n    for (let i = 0; i < plugins.length; i++) {\n        const plugin = plugins[i];\n        if (Array.isArray(plugin)) {\n            assign(plugin, options, target);\n            continue;\n        }\n\n        let name = plugin._name || plugin.name;\n        if (!name) {\n            plugin.name = name = uniqid(plugin.type + \"-\");\n        }\n\n        // If skip existing was set to true, and a plugin with the same name was already registered, skip registration.\n        if (!options.skipExisting || !target[name]) {\n            target[name] = plugin;\n            plugin.init && plugin.init();\n        }\n    }\n};\n\nexport class PluginsContainer {\n    private plugins: Record<string, Plugin> = {};\n    private _byTypeCache: Record<string, Plugin[]> = {};\n\n    constructor(...args) {\n        this.register(...args);\n    }\n\n    public byName<T extends Plugin>(name: T[\"name\"]): T {\n        return this.plugins[name] as T;\n    }\n\n    public byType<T extends Plugin>(type: T[\"type\"]): T[] {\n        if (this._byTypeCache[type]) {\n            return Array.from(this._byTypeCache[type]) as T[];\n        }\n        const plugins = this.findByType<T>(type);\n        this._byTypeCache[type] = plugins;\n        return Array.from(plugins);\n    }\n\n    public atLeastOneByType<T extends Plugin>(type: T[\"type\"]): T[] {\n        const list = this.byType<T>(type);\n        if (list.length === 0) {\n            throw new Error(`There are no plugins by type \"${type}\".`);\n        }\n        return list;\n    }\n\n    public oneByType<T extends Plugin>(type: T[\"type\"]): T {\n        const list = this.atLeastOneByType<T>(type);\n        if (list.length > 1) {\n            throw new Error(\n                `There is a requirement for plugin of type \"${type}\" to be only one registered.`\n            );\n        }\n        return list[0];\n    }\n\n    public all<T extends Plugin>(): T[] {\n        return Object.values(this.plugins) as T[];\n    }\n\n    public register(...args: any): void {\n        // reset the cache when adding new plugins\n        this._byTypeCache = {};\n        const [plugins, options] = normalizeArgs(args);\n        assign(plugins, options, this.plugins);\n    }\n\n    public unregister(name: string): void {\n        // reset the cache when removing a plugin\n        this._byTypeCache = {};\n        delete this.plugins[name];\n    }\n\n    private findByType<T extends Plugin>(type: T[\"type\"]): T[] {\n        return Object.values(this.plugins).filter((pl: Plugin) => pl.type === type) as T[];\n    }\n}\n"],"file":"PluginsContainer.js"}