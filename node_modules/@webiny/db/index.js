"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Db = exports.Batch = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

// Generates a short and sortable ID, e.g. "1607677774994.tfz58m".
const shortId = () => {
  const time = new Date().getTime();
  const uniqueId = Math.random().toString(36).slice(-6);
  return `${time}.${uniqueId}`;
}; // Picks necessary data from received args, ready to be stored in the log table.


const getCreateLogData = args => {
  const {
    table,
    meta,
    limit,
    sort,
    data,
    query,
    keys
  } = args;
  const logData = {
    table,
    meta,
    limit,
    sort,
    data,
    query,
    keys,
    batch: null
  };

  if (args.__batch) {
    logData.batch = {
      id: args.__batch.instance.id,
      type: args.__batch.instance.type
    };
  }

  return logData;
};

class Db {
  constructor({
    driver,
    table,
    logTable
  }) {
    (0, _defineProperty2.default)(this, "driver", void 0);
    (0, _defineProperty2.default)(this, "table", void 0);
    (0, _defineProperty2.default)(this, "logTable", void 0);
    this.driver = driver;
    this.table = table;
    this.logTable = logTable;
  }

  async create(args) {
    const createArgs = _objectSpread(_objectSpread({}, args), {}, {
      table: args.table || this.table
    });

    await this.createLog("create", createArgs);
    return this.driver.create(createArgs);
  }

  async read(args) {
    const readArgs = _objectSpread(_objectSpread({}, args), {}, {
      table: args.table || this.table
    });

    await this.createLog("read", readArgs);
    return this.driver.read(readArgs);
  }

  async update(args) {
    const updateArgs = _objectSpread(_objectSpread({}, args), {}, {
      table: args.table || this.table
    });

    await this.createLog("update", updateArgs);
    return this.driver.update(updateArgs);
  }

  async delete(args) {
    const deleteArgs = _objectSpread(_objectSpread({}, args), {}, {
      table: args.table || this.table
    });

    await this.createLog("delete", deleteArgs);
    return this.driver.delete(deleteArgs);
  } // Logging functions.


  async createLog(operation, args) {
    if (!this.logTable) {
      return;
    }

    const data = getCreateLogData(args);
    return this.driver.createLog({
      operation,
      data,
      table: this.logTable,
      id: shortId()
    });
  }

  async readLogs() {
    if (!this.logTable) {
      return;
    }

    return this.driver.readLogs({
      table: this.logTable
    });
  }

  batch() {
    return new Batch(this);
  }

}

exports.Db = Db;

class Batch {
  constructor(db) {
    (0, _defineProperty2.default)(this, "db", void 0);
    (0, _defineProperty2.default)(this, "type", void 0);
    (0, _defineProperty2.default)(this, "id", void 0);
    (0, _defineProperty2.default)(this, "meta", void 0);
    (0, _defineProperty2.default)(this, "operations", void 0);
    this.db = db;
    this.type = "batch";
    this.id = shortId();
    this.meta = {};
    this.operations = [];
  }

  push(...operations) {
    for (let i = 0; i < operations.length; i++) {
      const item = operations[i];
      this.operations.push(item);
    }

    return this;
  }

  create(...args) {
    for (let i = 0; i < args.length; i++) {
      this.push(["create", args[i]]);
    }

    return this;
  }

  read(...args) {
    for (let i = 0; i < args.length; i++) {
      this.push(["read", args[i]]);
    }

    return this;
  }

  update(...args) {
    for (let i = 0; i < args.length; i++) {
      this.push(["update", args[i]]);
    }

    return this;
  }

  delete(...args) {
    for (let i = 0; i < args.length; i++) {
      this.push(["delete", args[i]]);
    }

    return this;
  }

  async execute() {
    const promises = [];

    for (let i = 0; i < this.operations.length; i++) {
      const [operation, args] = this.operations[i];
      promises.push(this.db[operation](_objectSpread(_objectSpread({}, args), {}, {
        __batch: {
          instance: this,
          operation: this.operations[i]
        }
      })));
    }

    const result = Promise.all(promises);
    return result;
  }

}

exports.Batch = Batch;
//# sourceMappingURL=index.js.map