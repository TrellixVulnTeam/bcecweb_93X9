"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DateTimeZScalar = void 0;

var _graphqlScalars = require("graphql-scalars");

var _graphql = require("graphql");

var _error = _interopRequireDefault(require("@webiny/error"));

const validateTimeZone = value => {
  const timeWithTimezone = value.split("T")[1];

  if (!timeWithTimezone) {
    throw new _error.default("Could not extract time with timezone from value.", "DATE_TIME_TIMEZONE_ERROR", {
      value
    });
  }

  const separator = timeWithTimezone.includes("-") ? "-" : "+";
  const zone = timeWithTimezone.split(separator)[1];

  if (!zone) {
    throw new _error.default("Could not extract timezone from value.", "DATE_TIME_TIMEZONE_ERROR", {
      value: timeWithTimezone
    });
  }

  const hoursMinutes = zone.split(":");
  const [hours, minutes] = hoursMinutes;

  if (hours === undefined || minutes === undefined || hoursMinutes.length !== 2) {
    throw new _error.default("Could not extract hours or minutes from value.", "DATE_TIME_TIMEZONE_ERROR", {
      value: zone
    });
  }
};
/**
 * A custom type for dateTime with the timezone.
 * Must be in format "YYYY-MM-ddTHH:mm:ss+HH:mm".
 */


const DateTimeZScalar = new _graphql.GraphQLScalarType({
  name: "DateTimeZ",
  description: "A custom type for dateTime with the timezone.",
  parseValue: value => {
    // this serves as validator
    _graphqlScalars.DateTimeResolver.parseValue(value);

    validateTimeZone(value);
    return value;
  },
  serialize: value => {
    return value;
  }
});
exports.DateTimeZScalar = DateTimeZScalar;
//# sourceMappingURL=DateTimeZScalar.js.map