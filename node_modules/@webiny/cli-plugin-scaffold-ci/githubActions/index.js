"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _octokit = require("octokit");

var _chalk = _interopRequireDefault(require("chalk"));

var _commitWorkflows = _interopRequireDefault(require("./commitWorkflows"));

var _fetchAllRepositories = _interopRequireDefault(require("./fetchAllRepositories"));

var _validateNpmPackageName = _interopRequireDefault(require("validate-npm-package-name"));

var _open = _interopRequireDefault(require("open"));

let octokit;
let user;
let repo;
const NEW_TOKEN_URL = "https://github.com/settings/tokens/new?scopes=repo,workflow&description=webiny-cicd-token";
const LONG_LIVED_BRANCHES = ["dev", "staging", "prod"];
let generateErrorsCount = 0;
const plugin = {
  type: "cli-plugin-scaffold-ci",
  name: "cli-plugin-scaffold-ci-github",
  provider: "githubActions",
  questions: () => {
    return [{
      name: "githubAccessTokenCreate",
      message: () => {
        return `In order to proceed, you will need a GitHub personal access token. Do you want to create a new one?`;
      },
      type: "list",
      default: true,
      choices: async () => {
        return [{
          name: "No, I already have my GitHub personal access token",
          value: false
        }, {
          name: "Yes, I want to create a new GitHub personal access token",
          value: true
        }];
      }
    }, {
      name: "githubAccessToken",
      type: "password",
      message: () => {
        return `Your GitHub personal access token:`;
      },
      required: true,
      when: answers => {
        answers.githubAccessTokenCreate && (0, _open.default)(NEW_TOKEN_URL);
        return true;
      },
      validate: async answer => {
        octokit = new _octokit.Octokit({
          auth: answer
        });

        try {
          user = await octokit.rest.users.getAuthenticated().then(({
            data
          }) => data);
        } catch (e) {
          return "Invalid GitHub personal access token provided.";
        }

        return true;
      }
    }, {
      name: "newOrExistingRepo",
      message: `Would you like to create a new code repository or select an existing one?`,
      type: "list",
      default: "newRepo",
      choices: [{
        name: "Create a new repository",
        value: "newRepo"
      }, {
        name: "Choose existing repository",
        value: "existingRepo"
      }]
    }, {
      name: "newRepoOrgName",
      when: answers => answers.newOrExistingRepo === "newRepo",
      message: "Select an organization within which the new repository will be created (optional):",
      type: "list",
      default: null,
      choices: async () => {
        const organizations = await octokit.rest.orgs.listForAuthenticatedUser();
        return [{
          name: "Create within my own account",
          value: null
        }, {
          type: "separator"
        }, ...organizations.data.map(item => item.login)];
      }
    }, {
      name: "newRepoName",
      message: `Enter your code repository name:`,
      required: true,
      when: answers => answers.newOrExistingRepo === "newRepo",
      validate: async (answer, answers) => {
        const repositories = await (0, _fetchAllRepositories.default)({
          octokit
        });

        for (let i = 0; i < repositories.length; i++) {
          const repository = repositories[i];
          const owner = answers.newRepoOrgName || user.login;

          if (repository.name === answer && repository.owner.login === owner) {
            return "A code repository with given name already exists.";
          }
        }

        if (!(0, _validateNpmPackageName.default)(answer).validForNewPackages) {
          return "An invalid repository name provided.";
        }

        return true;
      }
    }, {
      name: "newRepoPrivacyType",
      message: "Please select the type of code repository to create:",
      when: answers => answers.newOrExistingRepo === "newRepo",
      type: "list",
      default: "private",
      choices: [{
        name: "Public",
        value: "public"
      }, {
        name: "Private",
        value: "private"
      }]
    }, {
      name: "existingRepo",
      message: "Please select your code repository:",
      when: answers => answers.newOrExistingRepo === "existingRepo",
      type: "list",
      choices: async () => {
        return (0, _fetchAllRepositories.default)({
          octokit
        }).then(repositories => repositories.map(repository => ({
          name: repository.full_name,
          value: {
            name: repository.name,
            owner: repository.owner.login
          }
        })));
      }
    }];
  },
  onGenerate: async ({
    input,
    inquirer
  }) => {
    const {
      newRepoName,
      newRepoOrgName,
      existingRepo,
      newRepoPrivacyType
    } = input;
    const prompt = inquirer.createPromptModule();
    console.log();
    console.log(`${_chalk.default.bold("The following operations will be performed on your behalf:")}`); // 1. Create a new repo or get existing.

    if (newRepoName) {
      let message = `- create a new ${_chalk.default.green(input.newRepoName)} ${newRepoPrivacyType} code repository`;

      if (newRepoOrgName) {
        message += ` (within ${_chalk.default.green(newRepoOrgName)} organization)`;
      }

      console.log(message);
    } else {
      console.log(`- select existing ${_chalk.default.green(existingRepo.name)} code repository (owned by ${_chalk.default.green(existingRepo.owner)})`);
    }

    console.log(`- push GitHub actions workflow files (located in ${_chalk.default.green(".github/workflows")})`);
    console.log(`- create protected ${_chalk.default.green("dev")}, ${_chalk.default.green("staging")}, and ${_chalk.default.green("prod")} branches`);
    console.log(`- set ${_chalk.default.green("dev")} as the default branch`);
    console.log(`- create ${_chalk.default.green("pr")}, ${_chalk.default.green("dev")}, ${_chalk.default.green("staging")}, and ${_chalk.default.green("prod")} code repository environments`);
    const {
      proceed
    } = await prompt({
      name: "proceed",
      message: `Are you sure you want to continue?`,
      type: "confirm",
      default: false
    });

    if (!proceed) {
      process.exit(0);
    }

    console.log();
  },
  generate: async ({
    input,
    ora
  }) => {
    const {
      newRepoName,
      newRepoOrgName,
      existingRepo,
      newRepoPrivacyType
    } = input; // 1. Create a new repo or get existing.

    if (newRepoName) {
      ora.start(`Creating ${_chalk.default.green(newRepoName)} code repository...`);

      if (newRepoOrgName) {
        repo = await octokit.rest.repos.createInOrg({
          org: newRepoOrgName,
          name: newRepoName,
          private: newRepoPrivacyType === "private"
        }).then(response => response.data);
      } else {
        repo = await octokit.rest.repos.createForAuthenticatedUser({
          name: newRepoName,
          private: newRepoPrivacyType === "private"
        }).then(response => response.data);
      }

      ora.stopAndPersist({
        symbol: _chalk.default.green("✔"),
        text: `${_chalk.default.green(newRepoName)} code repository created.`
      });
    } else {
      repo = await octokit.rest.repos.get({
        repo: existingRepo.name,
        owner: existingRepo.owner
      }).then(response => response.data);
    } // 2. Let's commit GitHub Actions workflows.


    ora.start(`Creating GitHub Actions workflows...`);

    try {
      await (0, _commitWorkflows.default)({
        octokit,
        owner: repo.owner.login,
        repo: repo.name,
        branch: repo.default_branch,
        author: {
          name: user.name,
          email: user.email
        }
      });
      ora.stopAndPersist({
        symbol: _chalk.default.green("✔"),
        text: `GitHub Actions workflows created.`
      });
    } catch (e) {
      generateErrorsCount++;
      ora.stopAndPersist({
        symbol: _chalk.default.red("✘"),
        text: `Creation of GitHub Actions workflows failed with the following message: ${e.message}`
      });
    } // 3. Create protected (long-lived) branches.


    ora.start(`Creating long-lived ${_chalk.default.green("dev")}, ${_chalk.default.green("staging")}, and ${_chalk.default.green("prod")} branches...`);

    try {
      const latestCommitSha = await octokit.rest.git.getRef({
        owner: repo.owner.login,
        repo: repo.name,
        ref: `heads/${repo.default_branch}`
      }).then(({
        data
      }) => data.object.sha);

      for (let i = 0; i < LONG_LIVED_BRANCHES.length; i++) {
        const longLivedBranch = LONG_LIVED_BRANCHES[i];
        await octokit.rest.git.createRef({
          owner: repo.owner.login,
          repo: repo.name,
          ref: `refs/heads/${longLivedBranch}`,
          sha: latestCommitSha
        });
      }

      ora.stopAndPersist({
        symbol: _chalk.default.green("✔"),
        text: `Long-lived ${_chalk.default.green("dev")}, ${_chalk.default.green("staging")}, and ${_chalk.default.green("prod")} branches created.`
      });
    } catch (e) {
      generateErrorsCount++;
      ora.stopAndPersist({
        symbol: _chalk.default.red("✘"),
        text: `Creation of long-lived ${_chalk.default.green("dev")}, ${_chalk.default.green("staging")}, and ${_chalk.default.green("prod")} branches failed with the following message: ${e.message}`
      });
    } // 4. Protecting branches...


    ora.start(`Enabling protection for created long-lived branches...`);

    try {
      for (let i = 0; i < LONG_LIVED_BRANCHES.length; i++) {
        const longLivedBranch = LONG_LIVED_BRANCHES[i];
        await octokit.rest.repos.updateBranchProtection({
          owner: repo.owner.login,
          repo: repo.name,
          branch: longLivedBranch,
          allow_force_pushes: false,
          allow_deletions: false,
          enforce_admins: null,
          required_pull_request_reviews: null,
          restrictions: null,
          required_status_checks: {
            strict: true,
            contexts: []
          }
        });
      }

      ora.stopAndPersist({
        symbol: _chalk.default.green("✔"),
        text: `Protection enabled for created long-lived branches.`
      });
    } catch (e) {
      generateErrorsCount++;
      ora.stopAndPersist({
        symbol: _chalk.default.red("✘"),
        text: `Enabling protection for long-lived branches failed with the following message: ${e.message}`
      });
    } // 5. Make "dev" branch the default one.


    ora.start(`Setting ${_chalk.default.green("dev")} as the default branch.`);

    try {
      await octokit.rest.repos.update({
        owner: repo.owner.login,
        repo: repo.name,
        branch: repo.default_branch,
        default_branch: "dev"
      });
      ora.stopAndPersist({
        symbol: _chalk.default.green("✔"),
        text: `Set ${_chalk.default.green("dev")} as the default branch.`
      });
    } catch (e) {
      generateErrorsCount++;
      ora.stopAndPersist({
        symbol: _chalk.default.red("✘"),
        text: `Setting ${_chalk.default.green("dev")} as the default branch failed with the following message: ${e.message}`
      });
    } // 6. Create code repository environments


    ora.start(`Creating ${_chalk.default.green("pr")}, ${_chalk.default.green("dev")}, ${_chalk.default.green("staging")}, and ${_chalk.default.green("prod")} code repository environments...`);
    const REPOSITORY_ENVIRONMENTS = ["pr", ...LONG_LIVED_BRANCHES];

    try {
      for (let i = 0; i < REPOSITORY_ENVIRONMENTS.length; i++) {
        const env = REPOSITORY_ENVIRONMENTS[i];
        await octokit.rest.repos.createOrUpdateEnvironment({
          owner: repo.owner.login,
          repo: repo.name,
          environment_name: env,
          reviewers: [{
            type: "User",
            id: user.id
          }],
          deployment_branch_policy: null
        });
      }

      ora.stopAndPersist({
        symbol: _chalk.default.green("✔"),
        text: `${_chalk.default.green("pr")}, ${_chalk.default.green("dev")}, ${_chalk.default.green("staging")}, and ${_chalk.default.green("prod")} code repository environments created.`
      });
    } catch (e) {
      generateErrorsCount++;
      ora.stopAndPersist({
        symbol: _chalk.default.red("✘"),
        text: `Creation of ${_chalk.default.green("pr")}, ${_chalk.default.green("dev")}, ${_chalk.default.green("staging")}, and ${_chalk.default.green("prod")} code repository environments failed with the following message: ${e.message}`
      });
    }
  },
  onSuccess: async () => {
    console.log();

    if (generateErrorsCount) {
      console.log(`${_chalk.default.yellow("✔")} CI/CD partially set up (total errors: ${_chalk.default.yellow(generateErrorsCount)}).`);
    } else {
      console.log(`${_chalk.default.green("✔")} CI/CD pipeline successfully set up.`);
    }

    console.log();
    console.log(`Check out the created code repository here:`);
    console.log(repo.html_url);
    console.log();
    const url = "https://www.webiny.com/docs/how-to-guides/scaffolding/ci-cd#next-steps";
    console.log(`For next steps, please open the following link:`);
    console.log(url);
    console.log(); // On errors, let's not automatically open next steps. Let's let the
    // user see what were the errors. He can still go to next steps because
    // the link is displayed on the screen in any case.

    generateErrorsCount === 0 && (0, _open.default)(url);
  }
};
var _default = plugin;
exports.default = _default;
//# sourceMappingURL=index.js.map