"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _plugins = require("@webiny/plugins");

var _middleware = _interopRequireDefault(require("./middleware"));

var _default = (...plugins) => async (...args) => {
  const context = {
    plugins: new _plugins.PluginsContainer(plugins),
    args,
    // @ts-ignore
    // this is injected using webpack.DefinePlugin at build time
    WEBINY_VERSION: process.env.WEBINY_VERSION
  };
  const result = await handle(args, context);
  const handlerPlugins = context.plugins.byType("handler-result");

  for (let i = 0; i < handlerPlugins.length; i++) {
    if (handlerPlugins[i].apply) {
      await handlerPlugins[i].apply(result, context);
    }
  }

  return result;
};

exports.default = _default;

async function handle(args, context) {
  try {
    const contextPlugins = context.plugins.byType("context");

    for (let i = 0; i < contextPlugins.length; i++) {
      if (contextPlugins[i].apply) {
        await contextPlugins[i].apply(context);
      }
    }

    const beforeHandlerPlugins = context.plugins.byType("before-handler");

    for (let i = 0; i < beforeHandlerPlugins.length; i++) {
      if (beforeHandlerPlugins[i].apply) {
        await beforeHandlerPlugins[i].apply(context);
      }
    }

    const handlers = context.plugins.byType("handler");
    const handler = (0, _middleware.default)(handlers.map(pl => pl.handle));
    const result = await handler(context);

    if (!result) {
      throw Error(`No result was returned from registered handlers.`);
    }

    return result;
  } catch (error) {
    // Log error to cloud, as these can be extremely annoying to debug!
    console.log(error);
    const handlers = context.plugins.byType("handler-error");
    const handler = (0, _middleware.default)(handlers.map(pl => pl.handle));
    return handler(context, error);
  }
}
//# sourceMappingURL=createHandler.js.map