"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _sanitizeImageTransformations = _interopRequireDefault(require("./sanitizeImageTransformations"));

var _utils = require("../../utils");

var _utils2 = require("../utils");

// @ts-ignore
const IMAGE_TRANSFORMER_FUNCTION = process.env.IMAGE_TRANSFORMER_FUNCTION;

const callImageTransformerLambda = async ({
  key,
  transformations,
  context
}) => {
  return await context.handlerClient.invoke({
    name: IMAGE_TRANSFORMER_FUNCTION,
    payload: {
      body: {
        key,
        transformations
      }
    }
  });
};

var _default = {
  canProcess: opts => {
    return _utils2.SUPPORTED_IMAGES.includes(opts.file.extension);
  },

  async process({
    s3,
    file,
    options,
    context
  }) {
    // Loaders must return {object, params} object.
    let objectParams;
    const transformations = (0, _sanitizeImageTransformations.default)(options);

    if (transformations && _utils2.SUPPORTED_TRANSFORMABLE_IMAGES.includes(file.extension)) {
      objectParams = (0, _utils.getObjectParams)((0, _utils2.getImageKey)({
        key: file.name,
        transformations
      }));

      try {
        return {
          object: await s3.getObject(objectParams).promise(),
          params: objectParams
        };
      } catch (e) {
        const imageTransformerLambdaResponse = await callImageTransformerLambda({
          key: file.name,
          transformations,
          context
        });

        if (imageTransformerLambdaResponse.error) {
          throw Error(imageTransformerLambdaResponse.message);
        }

        return {
          object: await s3.getObject(objectParams).promise(),
          params: objectParams
        };
      }
    }

    objectParams = (0, _utils.getObjectParams)((0, _utils2.getImageKey)({
      key: file.name
    }));

    try {
      return {
        object: await s3.getObject(objectParams).promise(),
        params: objectParams
      };
    } catch (e) {
      const imageTransformerLambdaResponse = await callImageTransformerLambda({
        key: file.name,
        context
      });

      if (imageTransformerLambdaResponse.error) {
        throw Error(imageTransformerLambdaResponse.message);
      }

      return {
        object: await s3.getObject(objectParams).promise(),
        params: objectParams
      };
    }
  }

};
exports.default = _default;
//# sourceMappingURL=imageLoader.js.map