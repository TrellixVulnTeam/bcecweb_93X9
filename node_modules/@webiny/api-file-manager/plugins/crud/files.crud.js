"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _mdbid = _interopRequireDefault(require("mdbid"));

var _handlerGraphql = require("@webiny/handler-graphql");

var _apiSecurity = require("@webiny/api-security");

var _error = _interopRequireDefault(require("@webiny/error"));

var _checkBasePermissions = _interopRequireDefault(require("./utils/checkBasePermissions"));

var _ContextPlugin = require("@webiny/handler/plugins/ContextPlugin");

var _FilePlugin = require("../definitions/FilePlugin");

var _FilesStorageOperationsProviderPlugin = require("../definitions/FilesStorageOperationsProviderPlugin");

var _lifecycleEvents = require("./utils/lifecycleEvents");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

const BATCH_CREATE_MAX_FILES = 20;
/**
 * If permission is limited to "own" files only, check that current identity owns the file.
 */

const checkOwnership = (file, permission, context) => {
  if ((permission === null || permission === void 0 ? void 0 : permission.own) === true) {
    const identity = context.security.getIdentity();

    if (file.createdBy.id !== identity.id) {
      throw new _apiSecurity.NotAuthorizedError();
    }
  }
};

const getLocaleCode = context => {
  if (!context.i18nContent) {
    throw new _error.default("Missing i18nContent on the FileManagerContext.", "MISSING_I18N_CONTENT");
  } else if (!context.i18nContent.locale) {
    throw new _error.default("Missing i18nContent.locale on the FileManagerContext.", "MISSING_I18N_CONTENT_LOCALE");
  } else if (!context.i18nContent.locale.code) {
    throw new _error.default("Missing i18nContent.locale.code on the FileManagerContext.", "MISSING_I18N_CONTENT_LOCALE_CODE");
  }

  return context.i18nContent.locale.code;
};

const filesContextCrudPlugin = new _ContextPlugin.ContextPlugin(async context => {
  const pluginType = _FilesStorageOperationsProviderPlugin.FilesStorageOperationsProviderPlugin.type;
  const providerPlugin = context.plugins.byType(pluginType).find(() => true);

  if (!providerPlugin) {
    throw new _error.default(`Missing "${pluginType}" plugin.`, "PLUGIN_NOT_FOUND", {
      type: pluginType
    });
  }

  const storageOperations = await providerPlugin.provide({
    context
  });

  if (!context.fileManager) {
    context.fileManager = {};
  }

  const filePlugins = context.plugins.byType(_FilePlugin.FilePlugin.type);
  context.fileManager.files = {
    async getFile(id) {
      const permission = await (0, _checkBasePermissions.default)(context, {
        rwd: "r"
      });
      const file = await storageOperations.get(id);

      if (!file) {
        throw new _handlerGraphql.NotFoundError(`File with id "${id}" does not exists.`);
      }

      checkOwnership(file, permission, context);
      return file;
    },

    async createFile(input) {
      await (0, _checkBasePermissions.default)(context, {
        rwd: "w"
      });
      const identity = context.security.getIdentity();
      const tenant = context.tenancy.getCurrentTenant();
      const id = (0, _mdbid.default)();

      const file = _objectSpread(_objectSpread({}, input), {}, {
        id,
        meta: _objectSpread({
          private: false
        }, input.meta || {}),
        tenant: tenant.id,
        createdOn: new Date().toISOString(),
        createdBy: {
          id: identity.id,
          displayName: identity.displayName,
          type: identity.type
        },
        locale: getLocaleCode(context),
        webinyVersion: context.WEBINY_VERSION
      });

      try {
        await (0, _lifecycleEvents.runLifecycleEvent)("beforeCreate", {
          context,
          plugins: filePlugins,
          data: file
        });
        const result = await storageOperations.create({
          file
        });
        await (0, _lifecycleEvents.runLifecycleEvent)("afterCreate", {
          context,
          plugins: filePlugins,
          data: file,
          file: result
        });
        return result;
      } catch (ex) {
        throw new _error.default(ex.message || "Could not create a file.", ex.code || "CREATE_FILE_ERROR", _objectSpread(_objectSpread({}, ex.data || {}), {}, {
          file
        }));
      }
    },

    async updateFile(id, input) {
      const permission = await (0, _checkBasePermissions.default)(context, {
        rwd: "w"
      });
      const original = await storageOperations.get(id);

      if (!original) {
        throw new _handlerGraphql.NotFoundError(`File with id "${id}" does not exists.`);
      }

      checkOwnership(original, permission, context);

      const file = _objectSpread(_objectSpread(_objectSpread({}, original), input), {}, {
        id: original.id,
        webinyVersion: context.WEBINY_VERSION
      });

      try {
        await (0, _lifecycleEvents.runLifecycleEvent)("beforeUpdate", {
          context,
          plugins: filePlugins,
          original,
          data: file
        });
        const result = await storageOperations.update({
          original,
          file
        });
        await (0, _lifecycleEvents.runLifecycleEvent)("afterUpdate", {
          context,
          plugins: filePlugins,
          original,
          data: file,
          file: result
        });
        return result;
      } catch (ex) {
        throw new _error.default(ex.message || "Could not update a file.", ex.code || "UPDATE_FILE_ERROR", _objectSpread(_objectSpread({}, ex.data || {}), {}, {
          original,
          file
        }));
      }
    },

    async deleteFile(id) {
      const permission = await (0, _checkBasePermissions.default)(context, {
        rwd: "d"
      });
      const file = await storageOperations.get(id);

      if (!file) {
        throw new _handlerGraphql.NotFoundError(`File with id "${id}" does not exists.`);
      }

      checkOwnership(file, permission, context);

      try {
        await (0, _lifecycleEvents.runLifecycleEvent)("beforeDelete", {
          context,
          plugins: filePlugins,
          file
        });
        await storageOperations.delete(id);
        await (0, _lifecycleEvents.runLifecycleEvent)("afterDelete", {
          context,
          plugins: filePlugins,
          file
        });
      } catch (ex) {
        throw new _error.default(ex.message || "Could not delete a file.", ex.code || "DELETE_FILE_ERROR", _objectSpread(_objectSpread({}, ex.data || {}), {}, {
          id,
          file
        }));
      }

      return true;
    },

    async createFilesInBatch(inputs) {
      if (!Array.isArray(inputs)) {
        throw new _error.default(`"data" must be an array.`, "CREATE_FILES_NON_ARRAY");
      }

      if (inputs.length === 0) {
        throw new _error.default(`"data" argument must contain at least one file.`, "CREATE_FILES_MIN_FILES");
      }

      if (inputs.length > BATCH_CREATE_MAX_FILES) {
        throw new _error.default(`"data" argument must not contain more than ${BATCH_CREATE_MAX_FILES} files.`, "CREATE_FILES_MAX_FILES");
      }

      await (0, _checkBasePermissions.default)(context, {
        rwd: "w"
      });
      const identity = context.security.getIdentity();
      const tenant = context.tenancy.getCurrentTenant();
      const createdBy = {
        id: identity.id,
        displayName: identity.displayName,
        type: identity.type
      };
      const files = inputs.map(input => {
        return _objectSpread(_objectSpread({}, input), {}, {
          meta: _objectSpread({
            private: false
          }, input.meta || {}),
          id: (0, _mdbid.default)(),
          tenant: tenant.id,
          createdOn: new Date().toISOString(),
          createdBy,
          locale: getLocaleCode(context),
          webinyVersion: context.WEBINY_VERSION
        });
      });

      try {
        await (0, _lifecycleEvents.runLifecycleEvent)("beforeBatchCreate", {
          context,
          plugins: filePlugins,
          data: files
        });
        const results = await storageOperations.createBatch({
          files
        });
        await (0, _lifecycleEvents.runLifecycleEvent)("afterBatchCreate", {
          context,
          plugins: filePlugins,
          data: files,
          files: results
        });
        return results;
      } catch (ex) {
        throw new _error.default(ex.message || "Could not create a batch of files.", ex.code || "CREATE_FILES_ERROR", _objectSpread(_objectSpread({}, ex.data || {}), {}, {
          files
        }));
      }
    },

    async listFiles(params = {}) {
      const permission = await (0, _checkBasePermissions.default)(context, {
        rwd: "r"
      });
      const {
        limit = 40,
        search = "",
        types = [],
        tags = [],
        ids = [],
        after = null
      } = params;
      const {
        i18nContent
      } = context;
      const where = {
        private: false,
        locale: i18nContent.locale.code
      };
      /**
       * Always override the createdBy received from the user, if any.
       */

      if (permission.own === true) {
        const identity = context.security.getIdentity();
        where.createdBy = identity.id;
      }
      /**
       * To have standardized where objects across the applications, we transform the types into type_in.
       */


      if (Array.isArray(types) && types.length > 0) {
        where.type_in = types;
      }
      /**
       * TODO: determine the change of this part.
       * Either assign search keyword to something meaningful or throw it out.
       */


      if (search) {
        where.search = search;
      }
      /**
       * Same as on types/type_in.
       */


      if (Array.isArray(tags) && tags.length > 0) {
        where.tag_in = tags.map(tag => tag.toLowerCase());
      }
      /**
       * Same as on types/type_in.
       */


      if (Array.isArray(ids) && ids.length > 0) {
        where.id_in = ids;
      }

      return storageOperations.list({
        where,
        after,
        limit,
        sort: ["id_DESC"]
      });
    },

    async listTags({
      after,
      limit
    }) {
      await (0, _checkBasePermissions.default)(context);
      const {
        i18nContent
      } = context;
      const where = {
        locale: i18nContent.locale.code
      };
      const params = {
        where,
        limit: limit || 100000,
        after
      };

      try {
        /**
         * There is a meta object on the second key.
         * TODO: use when changing GraphQL output of the tags.
         */
        const [tags] = await storageOperations.tags(params);
        /**
         * just to keep it standardized, sort by the tag ASC
         */

        return tags.sort();
      } catch (ex) {
        throw new _error.default(ex.message || "Could not search for tags.", ex.code || "FILE_TAG_SEARCH_ERROR", _objectSpread(_objectSpread({}, ex.data || {}), {}, {
          params
        }));
      }
    }

  };
});
filesContextCrudPlugin.name = "FileManagerFilesCrud";
var _default = filesContextCrudPlugin;
exports.default = _default;
//# sourceMappingURL=files.crud.js.map