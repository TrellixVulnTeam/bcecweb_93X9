"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.UserStorageOperationsDdb = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _table = require("../../definitions/table");

var _userEntity = require("../../definitions/userEntity");

var _error = _interopRequireDefault(require("@webiny/error"));

var _cleanup = require("@webiny/db-dynamodb/utils/cleanup");

var _query = require("@webiny/db-dynamodb/utils/query");

var _linksEntity = require("../../definitions/linksEntity");

var _batchRead = require("@webiny/db-dynamodb/utils/batchRead");

var _batchWrite = require("@webiny/db-dynamodb/utils/batchWrite");

var _tokenEntity = require("../../definitions/tokenEntity");

var _sort = require("@webiny/db-dynamodb/utils/sort");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

class UserStorageOperationsDdb {
  constructor({
    context
  }) {
    (0, _defineProperty2.default)(this, "context", void 0);
    (0, _defineProperty2.default)(this, "table", void 0);
    (0, _defineProperty2.default)(this, "entity", void 0);
    (0, _defineProperty2.default)(this, "tokenEntity", void 0);
    (0, _defineProperty2.default)(this, "linksEntity", void 0);
    this.context = context;
    this.table = (0, _table.createTable)({
      context
    });
    this.entity = (0, _userEntity.createUserEntity)({
      context,
      table: this.table
    });
    this.tokenEntity = (0, _tokenEntity.createTokenEntity)({
      context,
      table: this.table
    });
    this.linksEntity = (0, _linksEntity.createLinksEntity)({
      context,
      table: this.table
    });
  }

  async getUser(params) {
    const {
      id
    } = params;
    const keys = {
      PK: this.createPartitionKey(id),
      SK: this.createUserSortKey()
    };

    try {
      const result = await this.entity.get(keys);

      if (!result || !result.Item) {
        return null;
      }

      return this.cleanupItem(result.Item);
    } catch (ex) {
      throw new _error.default(ex.message || "Could not load user.", ex.code || "GET_USER_ERROR", {
        keys,
        id
      });
    }
  }

  async getUserByPersonalAccessToken(params) {
    const {
      token
    } = params;
    const queryParams = {
      partitionKey: "PAT",
      entity: this.tokenEntity,
      options: {
        index: "GSI1",
        eq: token,
        limit: 1
      }
    };
    let login = undefined;

    try {
      const result = await (0, _query.queryOne)(queryParams);

      if (!result) {
        throw new _error.default("Could not find token info.", "TOKEN_NOT_FOUND");
      }

      login = result.login;
    } catch (ex) {
      throw new _error.default(ex.message || "Could not find token info.", ex.code || "GET_USER_ERROR", {
        queryParams
      });
    }

    return this.getUser({
      id: login
    });
  }

  async listUsers(params) {
    const {
      where,
      sort
    } = params;

    if (!where.tenant && !where.id_in) {
      throw new _error.default(`There must be either a tenant or id_in sent when querying for list of users.`, "MALFORMED_WHERE_LIST_USERS_ERROR", {
        where
      });
    }

    if (where.id_in) {
      return this.listUsersByIds(where.id_in);
    }

    let userTenantAccessList = [];
    const queryAllParams = {
      entity: this.linksEntity,
      partitionKey: `T#${where.tenant}`,
      options: {
        index: "GSI1",
        beginsWith: "G#"
      }
    };

    try {
      userTenantAccessList = await (0, _query.queryAll)(queryAllParams);
    } catch (ex) {
      throw new _error.default(ex.message || "Cannot load users via secondary index.", ex.code || "LIST_USERS_VIA_SECONDARY_INDEX_ERROR", {
        partitionKey: queryAllParams.partitionKey,
        options: queryAllParams.options
      });
    }

    if (userTenantAccessList.length === 0) {
      return [];
    }

    const batch = userTenantAccessList.map(item => {
      return this.entity.getBatch({
        PK: item.PK,
        SK: "A"
      });
    });
    let users;

    try {
      const results = await (0, _batchRead.batchReadAll)({
        table: this.table,
        items: batch
      });
      users = results.map(user => this.cleanupItem(user));
    } catch (ex) {
      throw new _error.default(ex.message || "Cannot load users.", ex.code || "LIST_USERS_ERROR");
    }

    return (0, _sort.sortItems)({
      context: this.context,
      items: users,
      sort,
      fields: ["createdOn"]
    });
  }

  async createUser(params) {
    const {
      user
    } = params;
    const keys = {
      PK: this.createUserPartitionKey(user),
      SK: this.createUserSortKey()
    };

    try {
      await this.entity.put(_objectSpread(_objectSpread({}, user), {}, {
        TYPE: "security.user"
      }, keys));
      return user;
    } catch (ex) {
      throw new _error.default(ex.message || "Could not store user to the DDB.", ex.code || "CREATE_USER_DDB_ERROR", {
        keys,
        user
      });
    }
  }

  async updateUser(params) {
    const {
      user,
      original
    } = params;
    const keys = {
      PK: this.createUserPartitionKey(user),
      SK: this.createUserSortKey()
    };

    try {
      await this.entity.put(_objectSpread(_objectSpread({}, user), keys));
      return user;
    } catch (ex) {
      throw new _error.default(ex.message || "Could not save user to the DDB.", ex.code || "UPDATE_USER_DDB_ERROR", {
        keys,
        user,
        original
      });
    }
  }

  async deleteUser(params) {
    const {
      user
    } = params;
    let items = [];

    try {
      items = await (0, _query.queryAll)({
        entity: this.entity,
        partitionKey: this.createUserPartitionKey(user),
        options: {
          gt: " "
        }
      });
    } catch (ex) {
      throw new _error.default(ex.message || "Could not load users data.", ex.code || "LIST_USER_DATA_ERROR", {
        user
      });
    }

    try {
      await (0, _batchWrite.batchWriteAll)({
        table: this.table,
        items: items.map(item => {
          return this.entity.deleteBatch({
            PK: item.PK,
            SK: item.SK
          });
        })
      });
      return user;
    } catch (ex) {
      throw new _error.default(ex.message || "Could not delete user data.", ex.code || "DELETE_USER_DATA_ERROR", {
        user
      });
    }
  }

  async linkUserToTenant(params) {
    const {
      user,
      group,
      tenant,
      link
    } = params;
    const keys = {
      PK: this.createUserPartitionKey(user),
      SK: this.createLinkSortKey(tenant, group),
      GSI1_PK: this.createGsiPartitionKey(tenant),
      GSI1_SK: this.createGsiSortKey(group, user)
    };

    try {
      await this.linksEntity.put(_objectSpread(_objectSpread({}, keys), {}, {
        TYPE: "security.user2tenant"
      }, link));
    } catch (ex) {
      throw new _error.default(ex.message || "Could not create user <-> group link.", ex.code || "CREATE_USER_LINK_ERROR", {
        link,
        keys
      });
    }
  }

  async unlinkUserFromTenant(params) {
    const {
      tenant,
      user
    } = params;
    let userTenantAccessList = [];
    const usersPartitionKey = this.createUserPartitionKey(user);
    const usersOptions = {
      beginsWith: `LINK#T#${tenant.id}#G#`,
      limit: 1
    };

    try {
      userTenantAccessList = await (0, _query.queryAll)({
        entity: this.linksEntity,
        partitionKey: usersPartitionKey,
        options: usersOptions
      });
    } catch (ex) {
      throw new _error.default(ex.message || "Cannot load users via secondary index.", ex.code || "LIST_USERS_VIA_SECONDARY_INDEX_ERROR", {
        partitionKey: usersPartitionKey,
        options: usersOptions
      });
    }

    if (userTenantAccessList.length === 0) {
      throw new _error.default("Could not find a relation user <-> tenant");
    }

    const keys = {
      PK: userTenantAccessList[0].PK,
      SK: userTenantAccessList[0].SK
    };

    try {
      await this.entity.delete(keys);
    } catch (ex) {
      throw new _error.default(ex.message || "Could not delete link user <-> tenant.", ex.code || "DELETE_LINK_USER_TENANT_ERROR", {
        keys,
        user
      });
    }
  }

  async createToken(params) {
    const {
      identity,
      token
    } = params;
    const keys = {
      PK: this.createPartitionKey(identity.id),
      SK: `PAT#${token.id}`,
      GSI1_PK: "PAT",
      GSI1_SK: token.token
    };

    try {
      await this.tokenEntity.put(_objectSpread(_objectSpread(_objectSpread({}, token), keys), {}, {
        TYPE: "security.pat"
      }));
      return token;
    } catch (ex) {
      throw new _error.default(ex.message || "Cannot create user access token.", ex.code || "CREATE_USER_ACCESS_TOKEN_ERROR", {
        keys,
        token
      });
    }
  }

  async updateToken(params) {
    const {
      original,
      token
    } = params;
    const keys = {
      PK: `U#${original.login}`,
      SK: `PAT#${original.id}`
    };

    try {
      await this.tokenEntity.put(_objectSpread(_objectSpread({}, token), keys));
      return token;
    } catch (ex) {
      throw new _error.default(ex.message || "Cannot update user access token.", ex.code || "UPDATE_USER_ACCESS_TOKEN_ERROR", {
        keys,
        token,
        original
      });
    }
  }

  async deleteToken(params) {
    const {
      identity,
      token
    } = params;
    const keys = {
      PK: this.createPartitionKey(identity.id),
      SK: `PAT#${token.id}`
    };

    try {
      await this.tokenEntity.delete(keys);
      return token;
    } catch (ex) {
      throw new _error.default(ex.message || "Cannot delete user access token.", ex.code || "DELETE_USER_ACCESS_TOKEN_ERROR", {
        keys,
        token
      });
    }
  }

  async getPersonalAccessToken(params) {
    const {
      login,
      tokenId
    } = params;
    const keys = {
      PK: `U#${login}`,
      SK: `PAT#${tokenId}`
    };

    try {
      const result = await this.tokenEntity.get(keys);

      if (!result || !result.Item) {
        return null;
      }

      return this.cleanupTokenItem(result.Item);
    } catch (ex) {
      throw new _error.default(ex.message || "Cannot get user access token.", ex.code || "GET_USER_ACCESS_TOKEN_ERROR", {
        login,
        tokenId
      });
    }
  }

  async listTokens(params) {
    const {
      login
    } = params;
    const queryParams = {
      entity: this.tokenEntity,
      partitionKey: `U#${login}`,
      options: {
        beginsWith: "PAT#"
      }
    };

    try {
      return await (0, _query.queryAll)(queryParams);
    } catch (ex) {
      throw new _error.default(ex.messsage || "Cannot list user tokens.", ex.code || "LIST_TOKENS_ERROR", {
        login
      });
    }
  }

  async listUsersLinks(params) {
    const ids = params.where.id_in;

    if (ids.length === 0) {
      return [];
    }

    const queries = ids.map(id => {
      return (0, _query.queryAll)({
        partitionKey: `U#${id}`,
        entity: this.linksEntity,
        options: {
          beginsWith: "LINK#"
        }
      });
    });

    try {
      const results = await Promise.all(queries);
      const items = [];

      for (const result of results) {
        items.push(...result);
      }

      return items.map(item => this.cleanupLinksItem(item));
    } catch (ex) {
      throw new _error.default(ex.messsage || "Cannot list user links.", ex.code || "LIST_USER_LINKS_ERROR", {
        ids
      });
    }
  }

  async listUsersByIds(ids) {
    const items = ids.map(id => {
      return this.entity.getBatch({
        PK: this.createPartitionKey(id),
        SK: this.createUserSortKey()
      });
    });

    try {
      const results = await (0, _batchRead.batchReadAll)({
        table: this.table,
        items
      });
      return results.map(item => this.cleanupItem(item));
    } catch (ex) {
      throw new _error.default(ex.messsage || "Cannot batch read users by ID.", ex.code || "BATCH_READ_BY_ID_ERROR", {
        ids
      });
    }
  }

  cleanupItem(item) {
    return (0, _cleanup.cleanupItem)(this.entity, item);
  }

  cleanupTokenItem(item) {
    return (0, _cleanup.cleanupItem)(this.tokenEntity, item);
  }

  cleanupLinksItem(item) {
    return (0, _cleanup.cleanupItem)(this.linksEntity, item);
  }
  /**
   * There is a need for this method because of the old way of saving the user data.
   */


  createUserPartitionKey(user) {
    return this.createPartitionKey(user.id || user.login);
  }

  createPartitionKey(id) {
    return `U#${id}`;
  }

  createUserSortKey() {
    return "A";
  }

  createLinkSortKey(tenant, group) {
    return `LINK#T#${tenant.id}#G#${group.slug}`;
  }

  createGsiPartitionKey(tenant) {
    return `T#${tenant.id}`;
  }

  createGsiSortKey(group, user) {
    return `G#${group.slug}#U#${user.id || user.login}`;
  }

}

exports.UserStorageOperationsDdb = UserStorageOperationsDdb;
//# sourceMappingURL=UserStorageOperations.js.map