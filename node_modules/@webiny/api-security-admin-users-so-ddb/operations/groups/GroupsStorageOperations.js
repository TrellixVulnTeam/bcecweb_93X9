"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.GroupsStorageOperationsDdb = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _table = require("../../definitions/table");

var _groupEntity = require("../../definitions/groupEntity");

var _linksEntity = require("../../definitions/linksEntity");

var _error = _interopRequireDefault(require("@webiny/error"));

var _cleanup = require("@webiny/db-dynamodb/utils/cleanup");

var _query = require("@webiny/db-dynamodb/utils/query");

var _sort = require("@webiny/db-dynamodb/utils/sort");

var _batchWrite = require("@webiny/db-dynamodb/utils/batchWrite");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

class GroupsStorageOperationsDdb {
  constructor({
    context
  }) {
    (0, _defineProperty2.default)(this, "context", void 0);
    (0, _defineProperty2.default)(this, "table", void 0);
    (0, _defineProperty2.default)(this, "entity", void 0);
    (0, _defineProperty2.default)(this, "linksEntity", void 0);
    this.context = context;
    this.table = (0, _table.createTable)({
      context: this.context
    });
    this.entity = (0, _groupEntity.createGroupEntity)({
      context,
      table: this.table
    });
    this.linksEntity = (0, _linksEntity.createLinksEntity)({
      context,
      table: this.table
    });
  }

  async get(tenant, {
    slug
  }) {
    const keys = {
      PK: this.createPartitionKey(tenant),
      SK: this.createSortKey(slug)
    };

    try {
      const result = await this.entity.get(keys);

      if (!result || !result.Item) {
        return null;
      }

      return this.cleanupItem(result.Item);
    } catch (ex) {
      throw new _error.default(ex.message || "Could not load group.", ex.code || "GET_GROUP_ERROR", {
        keys,
        slug
      });
    }
  }

  async list(tenant, {
    sort
  }) {
    let items = [];

    try {
      items = await (0, _query.queryAll)({
        entity: this.entity,
        partitionKey: this.createPartitionKey(tenant),
        options: {
          beginsWith: "G#"
        }
      });
    } catch (ex) {
      throw new _error.default(ex.message || "Could not list groups.", ex.code || "LIST_GROUP_ERROR");
    }

    const sortedItems = (0, _sort.sortItems)({
      items,
      sort,
      context: this.context,
      fields: ["createdOn"]
    });
    return sortedItems.map(item => this.cleanupItem(item));
  }

  async create(tenant, {
    group
  }) {
    const keys = {
      PK: this.createPartitionKey(tenant),
      SK: this.createSortKey(group.slug)
    };

    try {
      await this.entity.put(_objectSpread(_objectSpread({}, group), {}, {
        TYPE: "security.group"
      }, keys));
      return group;
    } catch (ex) {
      throw new _error.default(ex.message || "Could not create group.", ex.code || "CREATE_GROUP_ERROR", {
        keys
      });
    }
  }

  async update(tenant, {
    group
  }) {
    const keys = {
      PK: this.createPartitionKey(tenant),
      SK: this.createSortKey(group.slug)
    };

    try {
      await this.entity.put(_objectSpread(_objectSpread({}, group), keys));
      return group;
    } catch (ex) {
      throw new _error.default(ex.message || "Could not update group.", ex.code || "CREATE_UPDATE_ERROR", {
        keys,
        group
      });
    }
  }

  async delete(tenant, {
    group
  }) {
    const keys = {
      PK: this.createPartitionKey(tenant),
      SK: this.createSortKey(group.slug)
    };

    try {
      await this.entity.delete(_objectSpread({}, keys));
      return group;
    } catch (ex) {
      throw new _error.default(ex.message || "Could not delete group.", ex.code || "CREATE_DELETE_ERROR", {
        keys,
        group
      });
    }
  }

  async updateUserLinks(tenant, {
    group
  }) {
    let links = [];

    try {
      links = await (0, _query.queryAll)({
        entity: this.entity,
        partitionKey: this.createPartitionKey(tenant),
        options: {
          index: "GSI1",
          beginsWith: `${this.createSortKey(group.slug)}#`
        }
      });
    } catch (ex) {
      throw new _error.default(ex.message || "Could not get all the user <-> group links.", ex.code || "USER_GROUP_LINKS_LIST_ERROR");
    }

    const items = links.map(link => {
      return this.linksEntity.putBatch(_objectSpread(_objectSpread({}, link), {}, {
        group: {
          slug: group.slug,
          name: group.name,
          permissions: group.permissions
        }
      }));
    });

    try {
      await (0, _batchWrite.batchWriteAll)({
        table: this.table,
        items
      });
    } catch (ex) {
      throw new _error.default(ex.message || "Could not update user <-> group links.", ex.code || "UPDATE_USER_LINKS_ERROR", {
        group
      });
    }
  }

  cleanupItem(item) {
    return (0, _cleanup.cleanupItem)(this.entity, item, ["TYPE"]);
  }

  createPartitionKey(tenant) {
    return `T#${tenant.id}`;
  }

  createSortKey(slug) {
    return `G#${slug}`;
  }

}

exports.GroupsStorageOperationsDdb = GroupsStorageOperationsDdb;
//# sourceMappingURL=GroupsStorageOperations.js.map