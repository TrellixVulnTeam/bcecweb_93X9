import _classCallCheck from "@babel/runtime/helpers/classCallCheck";
import _createClass from "@babel/runtime/helpers/createClass";
import _defineProperty from "@babel/runtime/helpers/defineProperty";
var COLOR_TOOL_CLASS = "cdx-text-color";

var TextColorTool = /*#__PURE__*/function () {
  function TextColorTool(_ref) {
    var api = _ref.api,
        config = _ref.config;

    _classCallCheck(this, TextColorTool);

    _defineProperty(this, "_state", void 0);

    _defineProperty(this, "color", void 0);

    _defineProperty(this, "api", void 0);

    _defineProperty(this, "tag", void 0);

    _defineProperty(this, "class", void 0);

    _defineProperty(this, "colorPicker", void 0);

    _defineProperty(this, "button", void 0);

    _defineProperty(this, "config", void 0);

    _defineProperty(this, "_CSS", void 0);

    this.api = api;
    this.button = null;
    this._state = false;
    this.tag = "SPAN";
    this.color = "red";
    this.class = COLOR_TOOL_CLASS;
    this.config = config || {
      themeColors: ["#44bd32"]
    };
    this._CSS = {
      colorPicker: "ce-text-color-tool",
      colorBox: "ce-text-color-tool__color-box",
      colorBoxActive: "ce-text-color-tool__color-box--active"
    };
  }

  _createClass(TextColorTool, [{
    key: "state",
    get: function get() {
      return this._state;
    },
    set: function set(state) {
      this._state = state;
      this.button.classList.toggle(this.api.styles.inlineToolButtonActive, state);
    }
    /**
     * Render method must return HTML element of the button for Inline Toolbar.
     */

  }, {
    key: "render",
    value: function render() {
      this.button = document.createElement("button");
      this.button.type = "button";
      this.button.innerHTML = '<svg width="20" height="18"><path d="M10.458 12.04l2.919 1.686-.781 1.417-.984-.03-.974 1.687H8.674l1.49-2.583-.508-.775.802-1.401zm.546-.952l3.624-6.327a1.597 1.597 0 0 1 2.182-.59 1.632 1.632 0 0 1 .615 2.201l-3.519 6.391-2.902-1.675zm-7.73 3.467h3.465a1.123 1.123 0 1 1 0 2.247H3.273a1.123 1.123 0 1 1 0-2.247z"/></svg>';
      this.button.classList.add(this.api.styles.inlineToolButton);
      return this.button;
    }
    /**
     * Input for the link
     */

  }, {
    key: "renderActions",
    value: function renderActions() {
      var _this = this;

      // Create action element
      this.colorPicker = document.createElement("div"); // Add element properties

      this.colorPicker.classList.add(this._CSS.colorPicker);
      this.config.themeColors.forEach(function (color) {
        // create element
        var colorBox = document.createElement("button"); // add properties

        colorBox.style.backgroundColor = color;
        colorBox.classList.add(_this._CSS.colorBox);
        colorBox.addEventListener("click", function () {
          if (_this.color === color) {
            // reset the color
            _this.color = "unset";
          } else {
            // set color
            _this.color = color;
          }

          _this.colorPicker.childNodes.forEach(function (node) {
            if (node.classList.contains(_this._CSS.colorBoxActive)) {
              // remove active class
              node.classList.remove(_this._CSS.colorBoxActive);
            }
          }); // add active class


          colorBox.classList.add(_this._CSS.colorBoxActive);
        }); // save element

        _this.colorPicker.appendChild(colorBox);
      }); // Return element

      return this.colorPicker;
    }
    /**
     * Finally, when button is pressed Editor calls
     * surround method of the tool with Range object as an argument.
     * @param range
     */

  }, {
    key: "surround",
    value: function surround(range) {
      if (this.state) {
        this.unwrap(range);
        return;
      }

      this.wrap(range);
    }
  }, {
    key: "wrap",
    value: function wrap(range) {
      var selectedText = range.extractContents();
      var mark = document.createElement(this.tag);
      mark.classList.add(this.class);
      mark.appendChild(selectedText);
      range.insertNode(mark);
      this.api.selection.expandToTag(mark);
    }
  }, {
    key: "unwrap",
    value: function unwrap(range) {
      var mark = this.api.selection.findParentTag(this.tag, this.class);
      var text = range.extractContents();
      mark.remove();
      range.insertNode(text);
    }
  }, {
    key: "showActions",
    value: function showActions(mark) {
      var _this2 = this;

      this.colorPicker.onclick = function () {
        mark.style.color = _this2.color;
      };

      this.colorPicker.hidden = false;
    }
  }, {
    key: "hideActions",
    value: function hideActions() {
      this.colorPicker.onchange = null;
      this.colorPicker.hidden = true;
    }
    /**
     * CheckState method of each Inline Tool is called by Editor with current `Selection`
     * when user selects some text
     */

  }, {
    key: "checkState",
    value: function checkState() {
      var mark = this.api.selection.findParentTag(this.tag);
      this.state = !!mark;

      if (this.state) {
        this.showActions(mark);
      } else {
        this.hideActions();
      }
    }
  }, {
    key: "convertToHex",
    value: function convertToHex(color) {
      var rgb = color.match(/(\d+)/g);
      var hexR = parseInt(rgb[0]).toString(16);
      var hexG = parseInt(rgb[1]).toString(16);
      var hexB = parseInt(rgb[2]).toString(16);
      hexR = hexR.length === 1 ? "0" + hexR : hexR;
      hexG = hexG.length === 1 ? "0" + hexG : hexG;
      hexB = hexB.length === 1 ? "0" + hexB : hexB;
      return "#" + hexR + hexG + hexB;
    }
  }, {
    key: "clear",
    value: function clear() {
      this.hideActions();
    }
  }], [{
    key: "isInline",
    get: function get() {
      return true;
    }
    /**
     * Sanitize method returns rules to let Editor know which HTML tags it should respect.
     * @returns {object} sanitizer configuration.
     * https://editorjs.io/sanitizer
     */

  }, {
    key: "sanitize",
    get: function get() {
      // Block Tools are not connected with Inline ones,
      // so markup added by Inline Tool will be removed on pasting or on saving.
      // We need this config so that `class` & `style` attributes will remain intact for "span".
      return {
        span: function span(el) {
          // Respect `class` and `style` attributes if this condition is meet.
          if (el.classList.contains(COLOR_TOOL_CLASS)) {
            return {
              class: COLOR_TOOL_CLASS,
              style: el.style
            };
          }
        }
      };
    }
  }]);

  return TextColorTool;
}();

export default TextColorTool;
//# sourceMappingURL=index.js.map