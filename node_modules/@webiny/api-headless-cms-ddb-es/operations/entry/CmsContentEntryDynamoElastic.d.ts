import { CmsContentEntry, CmsContentEntryStorageOperations, CmsContentEntryStorageOperationsCreateArgs, CmsContentEntryStorageOperationsCreateRevisionFromArgs, CmsContentEntryStorageOperationsDeleteArgs, CmsContentEntryStorageOperationsDeleteRevisionArgs, CmsContentEntryStorageOperationsGetArgs, CmsContentEntryStorageOperationsListArgs, CmsContentEntryStorageOperationsListResponse, CmsContentEntryStorageOperationsPublishArgs, CmsContentEntryStorageOperationsRequestChangesArgs, CmsContentEntryStorageOperationsRequestReviewArgs, CmsContentEntryStorageOperationsUnpublishArgs, CmsContentEntryStorageOperationsUpdateArgs, CmsContentModel, CmsContext } from "@webiny/api-headless-cms/types";
export declare const TYPE_ENTRY = "cms.entry";
export declare const TYPE_ENTRY_LATEST: string;
export declare const TYPE_ENTRY_PUBLISHED: string;
interface ConstructorArgs {
    context: CmsContext;
}
/**
 * This implementation is not a general driver to fetch from DDB/Elastic.
 * Use some other implementation for general-use purpose.
 */
export default class CmsContentEntryDynamoElastic implements CmsContentEntryStorageOperations {
    private readonly context;
    private readonly _dataLoaders;
    private _esClient;
    private get esClient();
    private get partitionKey();
    constructor({ context }: ConstructorArgs);
    create(model: CmsContentModel, args: CmsContentEntryStorageOperationsCreateArgs): Promise<CmsContentEntry>;
    createRevisionFrom(model: CmsContentModel, args: CmsContentEntryStorageOperationsCreateRevisionFromArgs): Promise<import("@webiny/api-headless-cms/types").CmsStorageContentEntry>;
    delete(model: CmsContentModel, args: CmsContentEntryStorageOperationsDeleteArgs): Promise<void>;
    deleteRevision(model: CmsContentModel, args: CmsContentEntryStorageOperationsDeleteRevisionArgs): Promise<void>;
    get(model: CmsContentModel, args: CmsContentEntryStorageOperationsGetArgs): Promise<CmsContentEntry | null>;
    /**
     * Implemented search via the Elasticsearch.
     */
    list(model: CmsContentModel, args: CmsContentEntryStorageOperationsListArgs): Promise<CmsContentEntryStorageOperationsListResponse>;
    update(model: CmsContentModel, args: CmsContentEntryStorageOperationsUpdateArgs): Promise<CmsContentEntry>;
    publish(model: CmsContentModel, args: CmsContentEntryStorageOperationsPublishArgs): Promise<CmsContentEntry>;
    unpublish(model: CmsContentModel, args: CmsContentEntryStorageOperationsUnpublishArgs): Promise<CmsContentEntry>;
    requestChanges(model: CmsContentModel, args: CmsContentEntryStorageOperationsRequestChangesArgs): Promise<CmsContentEntry>;
    requestReview(model: CmsContentModel, args: CmsContentEntryStorageOperationsRequestReviewArgs): Promise<CmsContentEntry>;
    getAllRevisionsByIds(model: CmsContentModel, ids: readonly string[]): Promise<CmsContentEntry[]>;
    getByIds(model: CmsContentModel, ids: readonly string[]): Promise<CmsContentEntry[]>;
    getPublishedByIds(model: CmsContentModel, ids: readonly string[]): Promise<CmsContentEntry[]>;
    getLatestByIds(model: CmsContentModel, ids: readonly string[]): Promise<CmsContentEntry[]>;
    getRevisions(model: CmsContentModel, id: string): Promise<CmsContentEntry[]>;
    getRevisionById(model: CmsContentModel, id: string): Promise<CmsContentEntry | null>;
    getPublishedRevisionByEntryId(model: CmsContentModel, entryId: string): Promise<CmsContentEntry | null>;
    getLatestRevisionByEntryId(model: CmsContentModel, entryId: string): Promise<CmsContentEntry | null>;
    getPreviousRevision(model: CmsContentModel, entryId: string, version: number): Promise<CmsContentEntry | null>;
    private getSingleDynamoDbItem;
    getPartitionKey(id: string): string;
    /**
     * Gets a sort key in form of REV#version from:
     *   id#0003
     *   0003
     *   3
     */
    getSortKeyRevision(version: string | number): string;
    getSortKeyLatest(): string;
    getSortKeyPublished(): string;
}
export {};
