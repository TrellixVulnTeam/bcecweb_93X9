"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createElasticsearchFields = void 0;

var _ElasticsearchFieldPlugin = require("@webiny/api-elasticsearch/plugins/definition/ElasticsearchFieldPlugin");

const entity = "ContentElasticsearchEntry";
const fieldsWithKeywords = ["text", "long-text", "rich-text", "id", "ref"];

const hasKeyword = type => {
  return fieldsWithKeywords.includes(type);
};

const createElasticsearchFields = model => {
  /**
   * We need to map entry system fields that have different paths, no keyword or not sortable.
   */
  const systemFields = {
    createdBy: new _ElasticsearchFieldPlugin.ElasticsearchFieldPlugin({
      field: "createdBy",
      path: "createdBy.id",
      entity,
      searchable: true,
      keyword: true,
      sortable: false
    }),
    ownedBy: new _ElasticsearchFieldPlugin.ElasticsearchFieldPlugin({
      field: "ownedBy",
      path: "ownedBy.id",
      entity,
      searchable: true,
      keyword: true,
      sortable: false
    }),
    createdOn: new _ElasticsearchFieldPlugin.ElasticsearchFieldPlugin({
      field: "createdOn",
      path: "createdOn",
      entity,
      searchable: true,
      keyword: false,
      sortable: false,
      unmappedType: "date"
    }),
    savedOn: new _ElasticsearchFieldPlugin.ElasticsearchFieldPlugin({
      field: "savedOn",
      path: "savedOn",
      entity,
      searchable: true,
      keyword: false,
      sortable: false,
      unmappedType: "date"
    })
  };
  return model.fields.reduce((fields, field) => {
    fields[field.fieldId] = new _ElasticsearchFieldPlugin.ElasticsearchFieldPlugin({
      field: field.fieldId,
      path: `values.${field.fieldId}`,
      entity,
      searchable: true,
      keyword: hasKeyword(field.type)
    });
    return fields;
  }, systemFields);
};

exports.createElasticsearchFields = createElasticsearchFields;
//# sourceMappingURL=fields.js.map