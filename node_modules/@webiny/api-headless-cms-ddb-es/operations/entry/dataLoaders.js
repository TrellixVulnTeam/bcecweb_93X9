"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DataLoadersHandler = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _dataloader = _interopRequireDefault(require("dataloader"));

var _error = _interopRequireDefault(require("@webiny/error"));

var _lodash = _interopRequireDefault(require("lodash.chunk"));

var _configurations = _interopRequireDefault(require("../../configurations"));

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

// Used in functions below. Ensures we are batch getting 100 keys at most.
const batchLoadKeys = loadChunk => {
  return new _dataloader.default(async keys => {
    // DynamoDB allows getting a maximum of 100 items in a single database call.
    // So, we are creating chunks that consist of a maximum of 100 keys.
    const keysChunks = (0, _lodash.default)(keys, 100);
    const promises = [];
    keysChunks.forEach(chunk => {
      promises.push(new Promise(resolve => resolve(loadChunk(chunk))));
    });
    const entriesChunks = await Promise.all(promises);
    return entriesChunks.reduce((current, items) => current.concat(items), []);
  });
};

const flattenResults = results => {
  return results.reduce((collection, items) => {
    collection.push(...items);
    return collection;
  }, []);
};

const getAllEntryRevisions = (context, model, storageOperations) => {
  return new _dataloader.default(async ids => {
    const results = [];

    for (const id of ids) {
      const [entries] = await context.db.read(_objectSpread(_objectSpread({}, _configurations.default.db()), {}, {
        query: {
          PK: storageOperations.getPartitionKey(id),
          SK: {
            $beginsWith: "REV#"
          }
        }
      }));
      results.push(entries);
    }

    return results;
  });
};

const getRevisionById = (context, model, storageOperations) => {
  return batchLoadKeys(keys => {
    const queries = keys.reduce((collection, id) => {
      const partitionKey = storageOperations.getPartitionKey(id);
      const sortKey = storageOperations.getSortKeyRevision(id);
      const keys = `${partitionKey}__${sortKey}`;

      if (collection[keys]) {
        return collection;
      }

      collection[keys] = _objectSpread(_objectSpread({}, _configurations.default.db()), {}, {
        query: {
          PK: storageOperations.getPartitionKey(id),
          SK: storageOperations.getSortKeyRevision(id)
        }
      });
      return collection;
    }, {});
    return context.db.batch().read(...Object.values(queries)).execute().then(results => results.map(result => result[0])).then(results => {
      const items = flattenResults(results);
      return keys.map(id => {
        return items.filter(item => {
          const partitionKey = storageOperations.getPartitionKey(id);
          const sortKey = storageOperations.getSortKeyRevision(id);
          return item.PK === partitionKey && item.SK === sortKey;
        });
      });
    });
  });
};

const getPublishedRevisionByEntryId = (context, model, storageOperations) => {
  return batchLoadKeys(keys => {
    const sortKey = storageOperations.getSortKeyPublished();
    const queries = keys.reduce((collection, id) => {
      const partitionKey = storageOperations.getPartitionKey(id);

      if (collection[partitionKey]) {
        return collection;
      }

      collection[partitionKey] = _objectSpread(_objectSpread({}, _configurations.default.db()), {}, {
        query: {
          PK: partitionKey,
          SK: sortKey
        }
      });
      return collection;
    }, {});
    return context.db.batch().read(...Object.values(queries)).execute().then(results => results.map(result => result[0])).then(results => {
      const items = flattenResults(results);
      return keys.map(id => {
        return items.filter(item => {
          const partitionKey = storageOperations.getPartitionKey(id);
          return item.PK === partitionKey && item.SK === sortKey;
        });
      });
    });
  });
};

const getLatestRevisionByEntryId = (context, model, storageOperations) => {
  return batchLoadKeys(keys => {
    const sortKey = storageOperations.getSortKeyLatest();
    const queries = keys.reduce((collection, id) => {
      const partitionKey = storageOperations.getPartitionKey(id);

      if (collection[partitionKey]) {
        return collection;
      }

      collection[partitionKey] = _objectSpread(_objectSpread({}, _configurations.default.db()), {}, {
        query: {
          PK: storageOperations.getPartitionKey(id),
          SK: sortKey
        }
      });
      return collection;
    }, {});
    return context.db.batch().read(...Object.values(queries)).execute().then(results => results.map(result => result[0])).then(results => {
      const items = flattenResults(results);
      return keys.map(id => {
        return items.filter(item => {
          const partitionKey = storageOperations.getPartitionKey(id);
          return item.PK === partitionKey && item.SK === sortKey;
        });
      });
    });
  });
};

const dataLoaders = {
  getAllEntryRevisions,
  getRevisionById,
  getPublishedRevisionByEntryId,
  getLatestRevisionByEntryId
};

class DataLoadersHandler {
  constructor(context, storageOperations) {
    (0, _defineProperty2.default)(this, "_loaders", new Map());
    (0, _defineProperty2.default)(this, "_context", void 0);
    (0, _defineProperty2.default)(this, "_storageOperations", void 0);
    this._context = context;
    this._storageOperations = storageOperations;
  }

  async getAllEntryRevisions(model, ids) {
    return await this.loadMany("getAllEntryRevisions", model, ids);
  }

  clearAllEntryRevisions(model, entry) {
    this.clear("getAllEntryRevisions", model, entry);
  }

  async getRevisionById(model, ids) {
    return await this.loadMany("getRevisionById", model, ids);
  }

  clearRevisionById(model, entry) {
    this.clear("getRevisionById", model, entry);
  }

  async getPublishedRevisionByEntryId(model, ids) {
    return await this.loadMany("getPublishedRevisionByEntryId", model, ids);
  }

  clearPublishedRevisionByEntryId(model, entry) {
    this.clear("getPublishedRevisionByEntryId", model, entry);
  }

  async getLatestRevisionByEntryId(model, ids) {
    return await this.loadMany("getLatestRevisionByEntryId", model, ids);
  }

  clearLatestRevisionByEntryId(model, entry) {
    this.clear("getLatestRevisionByEntryId", model, entry);
  }

  getLoader(name, model) {
    if (!dataLoaders[name]) {
      throw new _error.default("Unknown data loader.", "UNKNOWN_DATA_LOADER", {
        name
      });
    }

    const loaderKey = `${name}-${model.modelId}`;

    if (!this._loaders.has(loaderKey)) {
      this._loaders.set(loaderKey, dataLoaders[name](this._context, model, this._storageOperations));
    }

    return this._loaders.get(loaderKey);
  }

  async loadMany(loader, model, ids) {
    let results;

    try {
      results = await this.getLoader(loader, model).loadMany(ids);

      if (Array.isArray(results) === true) {
        return results.reduce((acc, res) => {
          if (Array.isArray(res) === false) {
            if (res !== null && res !== void 0 && res.message) {
              throw new _error.default(res.message, res.code, _objectSpread(_objectSpread({}, res), {}, {
                data: JSON.stringify(res.data || {})
              }));
            }

            throw new _error.default("Result from the data loader must be an array of arrays which contain requested items.");
          }

          acc.push(...res);
          return acc;
        }, []);
      }
    } catch (ex) {
      throw new _error.default(ex.message || "Data loader error.", ex.code || "DATA_LOADER_ERROR", {
        loader,
        ids,
        model
      });
    }

    throw new _error.default(`Data loader did not return array of items or empty array.`, "INVALID_DATA_LOADER_RESULT", {
      loader,
      ids,
      results
    });
  }
  /**
   * Helper to clear the cache for certain data loader.
   * If entry is passed then clear target key only.
   */


  clear(name, model, entry) {
    const loader = this.getLoader(name, model);

    if (!entry) {
      loader.clearAll();
      return;
    }

    loader.clear(entry.id);
    loader.clear(this._storageOperations.getPartitionKey(entry.id));
  }

}

exports.DataLoadersHandler = DataLoadersHandler;
//# sourceMappingURL=dataLoaders.js.map