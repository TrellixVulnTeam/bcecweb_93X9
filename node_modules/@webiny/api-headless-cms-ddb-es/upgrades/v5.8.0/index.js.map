{"version":3,"sources":["../../../src/upgrades/v5.8.0/index.ts"],"names":["sleep","ms","Promise","resolve","setTimeout","extractEntryId","id","includes","WebinyError","entryId","split","shift","createPartitionKey","data","JSON","stringify","tenant","locale","executeQuery","query","items","previousResult","Array","isArray","Items","length","push","result","next","fetchEntries","args","records","entity","queries","Object","values","map","record","partitionKey","results","all","reduce","concat","ex","table","name","type","app","version","apply","context","i18n","elasticsearch","console","log","definitions","defineTable","elasticTable","defineElasticsearchTable","modelEntity","defineModel","entryEntity","defineEntry","entryElasticsearchEntity","defineElasticsearchEntry","entryRecords","esIndices","locales","getLocales","recordsInABatch","models","code","model","index","esIndex","configurations","es","cms","getLocale","localeCode","limit","esData","hasMoreItems","after","response","search","body","bool","must","term","__type","TYPE_ENTRY_LATEST","sort","createdOn","order","unmapped_type","size","hits","hit","source","_source","tenancy","getCurrentTenant","undefined","keys","regularEntries","updates","entry","putBatch","chunks","key","hasOwnProperty","chunk","batchWrite","elasticEntries","elasticUpdates","breakMs","elasticUpdatesChunks","elasticUpdateChunk","message"],"mappings":"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","sourcesContent":["import { UpgradePlugin } from \"@webiny/api-upgrade/types\";\nimport { CmsContentEntry, CmsContentModel, CmsContext } from \"@webiny/api-headless-cms/types\";\nimport configurations from \"../../configurations\";\nimport { TYPE_ENTRY_LATEST } from \"../../operations/entry/CmsContentEntryDynamoElastic\";\nimport WebinyError from \"@webiny/error\";\nimport lodashChunk from \"lodash.chunk\";\nimport definitions from \"../../definitions\";\nimport { Entity } from \"dynamodb-toolbox\";\nimport { Client } from \"@elastic/elasticsearch\";\n\ninterface EntryRecordData {\n    /**\n     * A generated mdbid with the version number.\n     */\n    id: string;\n    /**\n     * A generated mdbid without the version number.\n     */\n    entryId: string;\n    /**\n     * Tenant id.\n     */\n    tenant: string;\n    /**\n     * Locale code.\n     */\n    locale: string;\n}\n\ninterface ElasticCmsContentEntry {\n    index: string;\n    PK: string;\n    SK: string;\n    data: CmsContentEntry;\n}\n\nconst sleep = async (ms = 2000): Promise<void> => {\n    await new Promise(resolve => setTimeout(resolve, ms));\n};\n/**\n * Entry ID is the first part of the ID, before the #.\n */\nconst extractEntryId = (id: string): string => {\n    if (id.includes(\"#\") === false) {\n        throw new WebinyError(\n            \"Missing # in the given id value. Possibly not an ID.\",\n            \"MALFORMED_ID_ERROR\",\n            {\n                id\n            }\n        );\n    }\n    const entryId = id.split(\"#\").shift();\n    if (!entryId) {\n        throw new WebinyError(\"Malformed entry ID.\", \"MALFORMED_ID_ERROR\", {\n            id\n        });\n    }\n    return entryId;\n};\n\nconst createPartitionKey = (data: EntryRecordData) => {\n    if (!data.id) {\n        throw new WebinyError(\n            `Missing ID in the EntryRecordData: ${JSON.stringify(data)}`,\n            \"RECORD_DATA_ID_ERROR\",\n            {\n                data\n            }\n        );\n    }\n    const entryId = extractEntryId(data.id);\n    if (!data.tenant) {\n        throw new WebinyError(\"Missing tenant on entry record data.\", \"TENANT_ERROR\", {\n            data\n        });\n    } else if (!data.locale) {\n        throw new WebinyError(\"Missing locale on entry record data.\", \"LOCALE_ERROR\", {\n            data\n        });\n    }\n    return `T#${data.tenant}#L#${data.locale}#CMS#CME#${entryId}`;\n};\n/**\n * DynamoDB Toolbox Entity query executor.\n * This helps with paginating the result and loading all of the data that can be fetched by the query.\n */\nconst executeQuery = async <T>(query: Promise<any>): Promise<T[]> => {\n    const items: T[] = [];\n    /**\n     * First result is actually the real query result.\n     */\n    let previousResult = await query;\n    if (\n        !previousResult ||\n        Array.isArray(previousResult.Items) === false ||\n        previousResult.Items.length === 0\n    ) {\n        return items;\n    }\n    items.push(...previousResult.Items);\n    let result;\n    /**\n     * If previousResult.next method returns false it means there is nothing more to load.\n     * Otherwise a result object is returned and we loop it.\n     * This works only if autoParse is not false (it is true by default).\n     */\n    while (typeof previousResult.next === \"function\" && (result = previousResult.next())) {\n        if (!result || Array.isArray(result.Items) === false || result.Items.length === 0) {\n            return items;\n        }\n        items.push(...result.Items);\n        previousResult = result;\n    }\n    return items;\n};\n\ninterface FetchEntriesArgs {\n    records: Record<string, EntryRecordData>;\n    entity: Entity<any>;\n}\n\nconst fetchEntries = async <T>(args: FetchEntriesArgs): Promise<T[]> => {\n    const { records, entity } = args;\n    const queries = Object.values(records).map(record => {\n        const partitionKey = createPartitionKey(record);\n        return executeQuery<T>(entity.query(partitionKey));\n    });\n    try {\n        const results = await Promise.all(queries);\n\n        return results.reduce((items, result) => {\n            return items.concat(result);\n        }, []);\n    } catch (ex) {\n        throw new WebinyError(\n            `Fetching the entries from \"${entity.table.name}\" table the error.`,\n            \"FETCH_ENTRIES_ERROR\",\n            {\n                table: entity.table.name,\n                entity: entity.name\n            }\n        );\n    }\n};\n\nexport default (): UpgradePlugin<CmsContext> => ({\n    type: \"api-upgrade\",\n    name: \"api-upgrade-5.8.0\",\n    app: \"headless-cms\",\n    version: \"5.8.0\",\n    async apply(context: CmsContext): Promise<void> {\n        const { i18n } = context;\n        const elasticsearch: Client = (context as any).elasticsearch;\n        if (!elasticsearch) {\n            throw new WebinyError(\"Missing Elasticsearch client on the context.\");\n        }\n        console.log(\"Started with the update of CMS entries.\");\n\n        /**\n         * Define tables and entities via helper methods because tables and entities are created in multiple places in the code.\n         */\n        const table = definitions.defineTable(context);\n        const elasticTable = definitions.defineElasticsearchTable(context);\n        const modelEntity = definitions.defineModel({ context, table });\n        const entryEntity = definitions.defineEntry({ context, table });\n        const entryElasticsearchEntity = definitions.defineElasticsearchEntry({\n            context,\n            table: elasticTable\n        });\n\n        const entryRecords: Record<string, EntryRecordData> = {};\n        const esIndices: { esIndex: string; localeCode: string }[] = [];\n        const locales = i18n.getLocales();\n        /**\n         * max dynamodb limit\n         */\n        const recordsInABatch = 25;\n\n        /**\n         * We need to find all the entries in each of the possible elasticsearch indexes.\n         * For that we need a list of indexes + localeCode.\n         * To get the index name we need models from in each locale.\n         */\n        for (const locale of locales) {\n            /**\n             * Need all the models to build the elasticsearch indexes\n             */\n            const models = await executeQuery<CmsContentModel>(\n                // TODO determine if required to loop through the tenants\n                modelEntity.query(`T#root#L#${locale.code}#CMS#CM`)\n            );\n\n            for (const model of models) {\n                const { index: esIndex } = configurations.es(\n                    {\n                        ...context,\n                        cms: {\n                            ...context.cms,\n                            getLocale: () => {\n                                return locale;\n                            }\n                        }\n                    },\n                    model\n                );\n                esIndices.push({\n                    esIndex,\n                    localeCode: locale.code\n                });\n            }\n        }\n        const limit = 100;\n        /**\n         * Get all the latest entries from all the indexes, we only need the ID of the entry from the Elasticsearch.\n         * Other data we need is the tenant ID and locale code.\n         */\n        for (const esData of esIndices) {\n            const { esIndex, localeCode } = esData;\n            let hasMoreItems = true;\n            let after: string;\n            while (hasMoreItems) {\n                const response = await elasticsearch.search({\n                    index: esIndex,\n                    body: {\n                        query: {\n                            bool: {\n                                must: [\n                                    {\n                                        term: {\n                                            __type: TYPE_ENTRY_LATEST\n                                        }\n                                    }\n                                ]\n                            }\n                        },\n                        sort: {\n                            createdOn: {\n                                order: \"asc\",\n                                // eslint-disable-next-line\n                                unmapped_type: \"date\"\n                            }\n                        },\n                        size: limit + 1,\n                        after\n                    }\n                });\n\n                const { hits } = response.body.hits;\n\n                for (const hit of hits) {\n                    /**\n                     * _source should be an property on the hit, but we check it just in case something wrong happens.\n                     * There are no Elasticsearch typings for this.\n                     */\n                    const source = hit._source || {};\n                    if (!source.id) {\n                        throw new WebinyError(\n                            `Missing ID in source: ${JSON.stringify(source)}`,\n                            \"SOURCE_ID_ERROR\",\n                            {\n                                source\n                            }\n                        );\n                    }\n                    const entryId = extractEntryId(source.id);\n                    entryRecords[entryId] = {\n                        id: source.id,\n                        entryId,\n                        tenant: context.tenancy.getCurrentTenant().id,\n                        locale: localeCode\n                    };\n                }\n\n                hasMoreItems = hits.length > limit;\n                after = hasMoreItems ? hits[limit - 1].sort : undefined;\n            }\n        }\n        console.log(\n            `[ELASTICSEARCH] Retrieved ${\n                Object.keys(entryRecords).length\n            } entry IDs to query directly from the DynamoDB.`\n        );\n        /**\n         * Now we go into the DynamoDB regular table and find all the entries with the given IDs.\n         * This is done via the partition key as it is a combination of tenant, locale and generated entry id.\n         * We need to have a query for each of the entries because there are possible versions, published and latest records.\n         * We can use a scan but at that point all the records in the table would be read,\n         * which is possibly expensive if there are a lot of records from the other applications (file manager, form builder, ...)\n         */\n        const regularEntries = await fetchEntries<CmsContentEntry>({\n            records: entryRecords,\n            entity: entryEntity\n        });\n\n        /**\n         * Then we create updates to the regular DynamoDB records.\n         */\n        const updates = [];\n        for (const entry of regularEntries) {\n            if (!entry.id) {\n                throw new WebinyError(\n                    `Missing ID in regular entry: ${JSON.stringify(entry)}`,\n                    \"ENTRY_ID_ERROR\",\n                    {\n                        entry\n                    }\n                );\n            }\n            const entryId = extractEntryId(entry.id);\n            if (!entryRecords[entryId]) {\n                continue;\n            }\n            const { tenant } = entryRecords[entryId];\n            /**\n             * Remove the leftovers from the beta 5 to v5.0.0 upgrade\n             */\n            delete entry[\"ignore\"];\n            updates.push(\n                entryEntity.putBatch({\n                    ...entry,\n                    entryId,\n                    tenant\n                })\n            );\n        }\n        try {\n            const chunks = lodashChunk(updates, recordsInABatch);\n            for (const key in chunks) {\n                if (!chunks.hasOwnProperty(key)) {\n                    continue;\n                }\n                const chunk = chunks[key];\n                await table.batchWrite(chunk);\n            }\n        } catch (ex) {\n            throw new WebinyError(\n                \"Error while writing a batch of records to regular table.\",\n                \"REGULAR_TABLE_WRITE_ERROR\",\n                {\n                    length: updates.length,\n                    ex\n                }\n            );\n        }\n\n        console.log(`[DYNAMODB] Table updated records: ${updates.length}`);\n        /**\n         * Time to go for the Elasticsearch data.\n         */\n        const elasticEntries = await fetchEntries<ElasticCmsContentEntry>({\n            records: entryRecords,\n            entity: entryElasticsearchEntity\n        });\n        /**\n         * Then we create the updates to the Elasticsearch records.\n         */\n        const elasticUpdates = [];\n        for (const entry of elasticEntries) {\n            const data = entry.data;\n            if (!data) {\n                throw new WebinyError(\"Missing data in elastic entry.\", \"DATA_ERROR\", {\n                    entry\n                });\n            } else if (!data.id) {\n                throw new WebinyError(\n                    `Missing ID in elastic entry data: ${JSON.stringify(entry)}`,\n                    \"DATA_ID_ERROR\",\n                    {\n                        entry\n                    }\n                );\n            }\n            const entryId = extractEntryId(data.id);\n            if (!entryRecords[entryId]) {\n                continue;\n            }\n            const { tenant } = entryRecords[entryId];\n            /**\n             * Remove the leftovers from the beta 5 to v5.0.0 upgrade\n             */\n            delete entry[\"ignore\"];\n            delete entry[\"savedOn\"];\n            delete entry[\"version\"];\n            elasticUpdates.push(\n                entryElasticsearchEntity.putBatch({\n                    ...entry,\n                    data: {\n                        ...data,\n                        entryId,\n                        tenant\n                    }\n                })\n            );\n        }\n\n        const breakMs = 200;\n        /**\n         * Updating the Elasticsearch table is a bit tricky because it can break if overwhelmed.\n         * We will take breakMs ms break between each recordsInABatch records\n         */\n        const elasticUpdatesChunks = lodashChunk(elasticUpdates, recordsInABatch);\n        console.log(\n            `[ELASTICSEARCH] Total chunks to be written with ${recordsInABatch} records in a batch: ${elasticUpdatesChunks.length}`\n        );\n        for (const elasticUpdateChunk of elasticUpdatesChunks) {\n            try {\n                await elasticTable.batchWrite(elasticUpdateChunk);\n            } catch (ex) {\n                throw new WebinyError(\n                    \"Error writing to Elasticsearch stream table.\",\n                    \"STREAM_TABLE_WRITE_ERROR\",\n                    {\n                        ex,\n                        message: ex.message\n                    }\n                );\n            }\n            await sleep(breakMs);\n        }\n        console.log(`[ELASTICSEARCH] Streaming table updated records: ${elasticUpdates.length}`);\n    }\n});\n"],"file":"index.js"}