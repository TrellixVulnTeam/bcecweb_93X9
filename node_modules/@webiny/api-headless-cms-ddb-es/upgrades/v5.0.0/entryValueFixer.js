"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.entryValueFixer = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _cleanDatabaseRecord = require("./cleanDatabaseRecord");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

const convertTimeToNumber = time => {
  if (!time) {
    return null;
  }

  const [hours, minutes, seconds = 0] = time.split(":").map(Number);
  return hours * 60 * 60 + minutes * 60 + seconds;
};

const fixRawValues = (target, finder) => {
  const entry = _objectSpread({}, target);

  for (const fieldId in entry.rawValues) {
    // if field is ref field then continue, otherwise break
    const field = finder.findById(target.modelId, fieldId);

    if (field.type !== "ref") {
      continue;
    }

    const existingValue = entry.values[fieldId];
    const rawValue = entry.rawValues[fieldId]; // always remove from rawValue

    delete entry.rawValues[fieldId]; // if there is something in values - do not switch it

    if (typeof existingValue !== "undefined" || rawValue === undefined || rawValue === null) {
      continue;
    }

    entry.values[fieldId] = rawValue;
  }

  return entry;
};

const fixTime = (field, time) => {
  if (isNaN(time) === false) {
    return parseInt(time);
  } // lets not reinvent the wheel


  try {
    return convertTimeToNumber(time);
  } catch (err) {
    console.log(`fixTime on field "${field.fieldId}" failed`, err);
    return null;
  }
};

const fixDateTime = (field, dateTime) => {
  switch (field.settings.type) {
    case "time":
      return fixTime(field, dateTime);

    case "date":
      return new Date(dateTime).toISOString();

    case "dateTimeWithoutTimezone":
      return new Date(dateTime).toISOString();

    default:
      return dateTime;
  }
};

const fixNumber = (field, value) => {
  if (value === undefined || value === null) {
    return null;
  }

  return parseFloat(value);
};

const fieldFixMethods = {
  datetime: fixDateTime,
  number: fixNumber
};

const fixFieldValues = (target, finder) => {
  const entry = _objectSpread({}, target);

  for (const fieldId in target.values) {
    const field = finder.findById(target.modelId, fieldId);

    if (!field) {
      continue;
    }

    const fixMethod = fieldFixMethods[field.type];

    if (!fixMethod) {
      continue;
    } else if (target.values[fieldId] === null || target.values[fieldId] === undefined) {
      continue;
    }

    target.values[fieldId] = fixMethod(field, target.values[fieldId]);
  }

  return entry;
};

const entryValueFixer = (model, finder, target) => {
  return (0, _cleanDatabaseRecord.cleanDatabaseRecord)(fixFieldValues(fixRawValues(target, finder), finder));
};

exports.entryValueFixer = entryValueFixer;
//# sourceMappingURL=entryValueFixer.js.map