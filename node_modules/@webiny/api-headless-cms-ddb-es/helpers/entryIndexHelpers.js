"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.extractEntriesFromIndex = exports.prepareEntryToIndex = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _error = _interopRequireDefault(require("@webiny/error"));

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

const prepareEntryToIndex = args => {
  const {
    context,
    storageEntry,
    model
  } = args;
  const {
    fieldIndexPlugins,
    defaultIndexFieldPlugin,
    fieldTypePlugins
  } = setupEntriesIndexHelpers({
    context
  });

  function getFieldIndexPlugin(fieldType) {
    return fieldIndexPlugins[fieldType] || defaultIndexFieldPlugin;
  }

  function getFieldTypePlugin(fieldType) {
    return fieldTypePlugins[fieldType];
  } // These objects will contain values processed by field index plugins


  const values = {};
  const rawValues = {}; // We're only interested in current model fields.

  for (const field of model.fields) {
    if (storageEntry.values.hasOwnProperty(field.fieldId) === false) {
      continue;
    }

    const fieldTypePlugin = getFieldTypePlugin(field.type);

    if (!fieldTypePlugin) {
      throw new _error.default(`Missing field type plugin "${field.type}".`);
    }

    const targetFieldPlugin = getFieldIndexPlugin(field.type); // TODO: remove this `if` once we convert this plugin to proper plugin class

    if (targetFieldPlugin && targetFieldPlugin.toIndex) {
      const {
        value,
        rawValue
      } = targetFieldPlugin.toIndex({
        context,
        model,
        field,
        value: storageEntry.values[field.fieldId],
        getFieldIndexPlugin,
        getFieldTypePlugin
      });

      if (typeof value !== "undefined") {
        values[field.fieldId] = value;
      }

      if (typeof rawValue !== "undefined") {
        rawValues[field.fieldId] = rawValue;
      }
    }
  }

  return _objectSpread(_objectSpread({}, storageEntry), {}, {
    values,
    rawValues
  });
};

exports.prepareEntryToIndex = prepareEntryToIndex;

const setupEntriesIndexHelpers = ({
  context
}) => {
  const plugins = context.plugins.byType("cms-model-field-to-elastic-search");
  const fieldIndexPlugins = {};

  for (const plugin of plugins.reverse()) {
    if (fieldIndexPlugins[plugin.fieldType]) {
      continue;
    }

    fieldIndexPlugins[plugin.fieldType] = plugin;
  } // we will use this plugin if no targeted plugin found


  const defaultIndexFieldPlugin = plugins.find(plugin => plugin.fieldType === "*"); // CmsModelFieldToGraphQLPlugin plugins

  const fieldTypePlugins = context.plugins.byType("cms-model-field-to-graphql").reduce((plugins, plugin) => _objectSpread(_objectSpread({}, plugins), {}, {
    [plugin.fieldType]: plugin
  }), {});
  return {
    fieldIndexPlugins,
    defaultIndexFieldPlugin,
    fieldTypePlugins
  };
};

const extractEntriesFromIndex = ({
  context,
  entries,
  model
}) => {
  const {
    fieldIndexPlugins,
    defaultIndexFieldPlugin,
    fieldTypePlugins
  } = setupEntriesIndexHelpers({
    context
  });

  function getFieldIndexPlugin(fieldType) {
    return fieldIndexPlugins[fieldType] || defaultIndexFieldPlugin;
  }

  function getFieldTypePlugin(fieldType) {
    return fieldTypePlugins[fieldType];
  }

  const list = [];

  for (const entry of entries) {
    // This object will contain values processed by field index plugins
    const indexValues = {}; // We only consider fields that are present in the model

    for (const field of model.fields) {
      const fieldTypePlugin = fieldTypePlugins[field.type];

      if (!fieldTypePlugin) {
        throw new _error.default(`Missing field type plugin "${field.type}".`);
      }

      const targetFieldPlugin = getFieldIndexPlugin(field.type);

      if (targetFieldPlugin && targetFieldPlugin.fromIndex) {
        try {
          indexValues[field.fieldId] = targetFieldPlugin.fromIndex({
            context,
            model,
            field,
            getFieldIndexPlugin,
            getFieldTypePlugin,
            value: entry.values[field.fieldId],
            rawValue: entry.rawValues[field.fieldId]
          });
        } catch (ex) {
          throw new _error.default(ex.message || "Could not transform entry field from index.", ex.code || "FIELD_FROM_INDEX_ERROR", {
            field,
            entry
          });
        }
      }
    }

    list.push(_objectSpread(_objectSpread({}, entry), {}, {
      values: indexValues
    }));
  }

  return list;
};

exports.extractEntriesFromIndex = extractEntriesFromIndex;
//# sourceMappingURL=entryIndexHelpers.js.map