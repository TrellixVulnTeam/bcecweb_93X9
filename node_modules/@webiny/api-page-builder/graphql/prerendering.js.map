{"version":3,"sources":["../../src/graphql/prerendering.ts"],"names":["NOT_FOUND_FOLDER","PagePlugin","afterUnpublish","context","page","promises","push","pageBuilder","pages","prerendering","flush","paths","path","render","tags","tag","key","Promise","all","afterDelete","publishedPage","version","isPublished","id","afterPublish","settings","default","getCurrent","home","pid","notFound","configuration","meta","notFoundPage","storage","folder","SettingsPlugin","afterUpdate","nextSettings","i","diff","length","type","MenuPlugin","menu","value","slug"],"mappings":"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","sourcesContent":["import { PagePlugin } from \"~/plugins/PagePlugin\";\nimport { SettingsPlugin } from \"~/plugins/SettingsPlugin\";\nimport { MenuPlugin } from \"~/plugins/MenuPlugin\";\n\nconst NOT_FOUND_FOLDER = \"_NOT_FOUND_PAGE_\";\n\nexport default [\n    new PagePlugin({\n        // After a page was unpublished, we need to flush the page.\n        async afterUnpublish({ context, page }) {\n            const promises = [];\n            promises.push(\n                context.pageBuilder.pages.prerendering.flush({ paths: [{ path: page.path }] })\n            );\n\n            // After a page was unpublished, we need to rerender pages that contain pages list element.\n            promises.push(\n                context.pageBuilder.pages.prerendering.render({\n                    tags: [{ tag: { key: \"pb-pages-list\" } }]\n                })\n            );\n\n            // Note: special pages (404 / home) cannot be unpublished, that's why\n            // there is no special handling in regards to that here.\n            await Promise.all(promises);\n        },\n        // After we deleted a page, we need to clear prerender files / cache as well, if the page was published.\n        async afterDelete({ context, page, publishedPage }) {\n            // Published pages have this record.\n            if (!publishedPage) {\n                return;\n            }\n\n            if (page.version === 1) {\n                return context.pageBuilder.pages.prerendering.flush({\n                    paths: [{ path: publishedPage.path }]\n                });\n            }\n\n            // If the published version was deleted.\n            const isPublished = publishedPage.id === page.id;\n            if (isPublished) {\n                return context.pageBuilder.pages.prerendering.flush({\n                    paths: [{ path: publishedPage.path }]\n                });\n            }\n\n            // Note: special pages (404 / home) cannot be deleted, that's why\n            // there is no special handling in regards to that here.\n        },\n        // After a page was published, we need to render the page.\n        async afterPublish({ context, page, publishedPage }) {\n            const promises = [];\n            promises.push(\n                context.pageBuilder.pages.prerendering.render({ paths: [{ path: page.path }] })\n            );\n\n            const settings = await context.pageBuilder.settings.default.getCurrent();\n\n            // If we just published a page that is set as current homepage, let's rerender the \"/\" path as well.\n            if (settings?.pages?.home === page.pid) {\n                promises.push(\n                    context.pageBuilder.pages.prerendering.render({ paths: [{ path: \"/\" }] })\n                );\n            }\n\n            // Finally, if we just published a page that is set as current not-found page, let's do\n            // another rerender and save that into the NOT_FOUND_FOLDER.\n            if (settings?.pages?.notFound === page.pid) {\n                promises.push(\n                    context.pageBuilder.pages.prerendering.render({\n                        paths: [\n                            {\n                                path: page.path,\n                                configuration: {\n                                    meta: {\n                                        notFoundPage: true\n                                    },\n                                    storage: { folder: NOT_FOUND_FOLDER }\n                                }\n                            }\n                        ]\n                    })\n                );\n            }\n\n            // After a page was published, we need to rerender pages that contain pages list element.\n            promises.push(\n                context.pageBuilder.pages.prerendering.render({\n                    tags: [{ tag: { key: \"pb-pages-list\" } }]\n                })\n            );\n\n            // If we had a published page and the URL on which it was published is different than\n            // the URL of the just published page, then let's flush the page on old URL.\n            if (publishedPage && publishedPage.path !== page.path) {\n                promises.push(\n                    context.pageBuilder.pages.prerendering.flush({\n                        paths: [{ path: publishedPage.path }]\n                    })\n                );\n            }\n\n            await Promise.all(promises);\n        }\n    }),\n    new SettingsPlugin({\n        // After settings were changed, invalidate all pages that contain pb-page tag.\n        async afterUpdate({ context, nextSettings, meta }) {\n            if (!nextSettings) {\n                return;\n            }\n\n            // TODO: optimize this.\n            // TODO: right now, on each update of settings, we trigger a complete site rebuild.\n            await context.pageBuilder.pages.prerendering.render({\n                tags: [{ tag: { key: \"pb-page\" } }]\n            });\n\n            // If a change on pages settings (home, notFound) has been made, let's rerender accordingly.\n            for (let i = 0; i < meta.diff.pages.length; i++) {\n                const [type, , , page] = meta.diff.pages[i];\n                switch (type) {\n                    case \"home\":\n                        await context.pageBuilder.pages.prerendering.render({\n                            paths: [{ path: \"/\" }]\n                        });\n                        break;\n                    case \"notFound\":\n                        await context.pageBuilder.pages.prerendering.render({\n                            paths: [\n                                {\n                                    path: page.path,\n                                    configuration: {\n                                        storage: { folder: NOT_FOUND_FOLDER }\n                                    }\n                                }\n                            ]\n                        });\n                        break;\n                }\n            }\n        }\n    }),\n    new MenuPlugin({\n        // After a menu has changed, invalidate all pages that contain the updated menu.\n        async afterUpdate({ context, menu }) {\n            await context.pageBuilder.pages.prerendering.render({\n                tags: [{ tag: { key: \"pb-menu\", value: menu.slug } }]\n            });\n        }\n    })\n];\n"],"file":"prerendering.js"}