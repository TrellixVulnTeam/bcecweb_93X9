"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _mdbid = _interopRequireDefault(require("mdbid"));

var _uniqid = _interopRequireDefault(require("uniqid"));

var _trimStart = _interopRequireDefault(require("lodash/trimStart"));

var _omit = _interopRequireDefault(require("lodash/omit"));

var _get = _interopRequireDefault(require("lodash/get"));

var _merge = _interopRequireDefault(require("lodash/merge"));

var _dataloader = _interopRequireDefault(require("dataloader"));

var _apiSecurity = require("@webiny/api-security");

var _error = _interopRequireDefault(require("@webiny/error"));

var _handlerGraphql = require("@webiny/handler-graphql");

var _getPKPrefix = _interopRequireDefault(require("./utils/getPKPrefix"));

var _defaults = _interopRequireDefault(require("./utils/defaults"));

var _types = require("../../types");

var _SearchPublishedPagesPlugin = require("../../plugins/SearchPublishedPagesPlugin");

var _SearchLatestPagesPlugin = require("../../plugins/SearchLatestPagesPlugin");

var _createListMeta = _interopRequireDefault(require("./utils/createListMeta"));

var _checkBasePermissions = _interopRequireDefault(require("./utils/checkBasePermissions"));

var _checkOwnPermissions = _interopRequireDefault(require("./utils/checkOwnPermissions"));

var _getNormalizedListPagesArgs = _interopRequireDefault(require("./utils/getNormalizedListPagesArgs"));

var _executeCallbacks = _interopRequireDefault(require("./utils/executeCallbacks"));

var _normalizePath = _interopRequireDefault(require("./pages/normalizePath"));

var _contentCompression = require("./pages/contentCompression");

var _models = require("./pages/models");

var _esPageData = require("./pages/esPageData");

var _PagePlugin = require("../../plugins/PagePlugin");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

const STATUS_CHANGES_REQUESTED = "changesRequested";
const STATUS_REVIEW_REQUESTED = "reviewRequested";
const STATUS_DRAFT = "draft";
const STATUS_PUBLISHED = "published";
const STATUS_UNPUBLISHED = "unpublished";

const getZeroPaddedVersionNumber = number => String(number).padStart(4, "0");

const DEFAULT_EDITOR = "page-builder";
const PERMISSION_NAME = "pb.page";
const plugin = {
  type: "context",

  async apply(context) {
    const {
      db,
      i18nContent,
      elasticsearch
    } = context;

    const PK_PAGE = pid => `${(0, _getPKPrefix.default)(context)}P#${pid}`;

    const PK_PAGE_PUBLISHED_PATH = () => `${(0, _getPKPrefix.default)(context)}PATH`;

    const ES_DEFAULTS = () => _defaults.default.es(context); // Used in a couple of key events - (un)publishing and pages deletion.


    const pagePlugins = context.plugins.byType(_PagePlugin.PagePlugin.type);
    context.pageBuilder = _objectSpread(_objectSpread({}, context.pageBuilder), {}, {
      pages: {
        dataLoaders: {
          getPublishedById: new _dataloader.default(async argsArray => {
            const batch = db.batch();
            const notFoundError = new _handlerGraphql.NotFoundError("Page not found.");
            const idNotProvidedError = new _error.default('Cannot get published page - "id" not provided.');
            const errorsAndResults = [];
            let batchResultIndex = 0;

            for (let i = 0; i < argsArray.length; i++) {
              const args = argsArray[i];

              if (!args.id) {
                errorsAndResults.push(idNotProvidedError);
                continue;
              } // If we have a full ID, then try to load it directly.


              const [pid, version] = args.id.split("#");

              if (version) {
                errorsAndResults.push(batchResultIndex++);
                batch.read(_objectSpread(_objectSpread({}, _defaults.default.db), {}, {
                  query: {
                    PK: PK_PAGE(pid),
                    SK: `REV#${version}`
                  }
                }));
                continue;
              }

              errorsAndResults.push(batchResultIndex++);
              batch.read(_objectSpread(_objectSpread({}, _defaults.default.db), {}, {
                query: {
                  PK: PK_PAGE(pid),
                  SK: `P`
                }
              }));
            } // Replace batch result indexes with actual results.


            const batchResults = await batch.execute();

            for (let i = 0; i < errorsAndResults.length; i++) {
              const errorResult = errorsAndResults[i];

              if (typeof errorResult !== "number") {
                continue;
              }

              const [[page]] = batchResults[errorResult];

              if (!page) {
                errorsAndResults[i] = notFoundError;
                continue;
              } // If preview enabled, return the page, without checking if the page
              // is published. The preview flag is not utilized anywhere else.


              if (argsArray[i].preview || page.status === "published") {
                errorsAndResults[i] = page; // Extract compressed page content.

                errorsAndResults[i].content = await (0, _contentCompression.extractContent)(errorsAndResults[i].content);
                continue;
              }

              errorsAndResults[i] = notFoundError;
            }

            return errorsAndResults;
          }, {
            cacheKeyFn: key => key.id + key.preview
          })
        },

        async get(id) {
          const [pid, rev] = id.split("#");
          const permission = await (0, _checkBasePermissions.default)(context, PERMISSION_NAME, {
            rwd: "r"
          });
          let page;

          if (rev) {
            const [[exactRevision]] = await db.read(_objectSpread(_objectSpread({}, _defaults.default.db), {}, {
              query: {
                PK: PK_PAGE(pid),
                SK: `REV#${rev}`
              }
            }));
            page = exactRevision;
          } else {
            const [[latestRevision]] = await db.read(_objectSpread(_objectSpread({}, _defaults.default.db), {}, {
              query: {
                PK: PK_PAGE(pid),
                SK: `L`
              }
            }));
            page = latestRevision;
          }

          if (!page) {
            throw new _handlerGraphql.NotFoundError("Page not found.");
          }

          const identity = context.security.getIdentity();
          (0, _checkOwnPermissions.default)(identity, permission, page, "ownedBy"); // Extract compressed page content.

          page.content = await (0, _contentCompression.extractContent)(page.content);
          return page;
        },

        async getPublishedById(args) {
          return this.dataLoaders.getPublishedById.load(args);
        },

        async getPublishedByPath(args) {
          if (!args.path) {
            throw new _error.default('Cannot get published page - "path" not provided.');
          }

          const notFoundError = new _handlerGraphql.NotFoundError("Page not found.");
          const normalizedPath = (0, _normalizePath.default)(args.path);

          if (normalizedPath === "/") {
            var _settings$pages;

            const settings = await context.pageBuilder.settings.default.getCurrent();

            if (!(settings !== null && settings !== void 0 && (_settings$pages = settings.pages) !== null && _settings$pages !== void 0 && _settings$pages.home)) {
              throw notFoundError;
            }

            return context.pageBuilder.pages.getPublishedById({
              id: settings.pages.home
            });
          }

          let [[page]] = await db.read(_objectSpread(_objectSpread({}, _defaults.default.db), {}, {
            query: {
              PK: PK_PAGE_PUBLISHED_PATH(),
              SK: normalizedPath
            }
          }));

          if (!page) {
            // Try loading dynamic pages
            for (const plugin of pagePlugins) {
              if (typeof plugin.notFound === "function") {
                page = await plugin.notFound({
                  args,
                  context
                });

                if (page) {
                  break;
                }
              }
            }
          }

          if (page) {
            // Extract compressed page content.
            page.content = await (0, _contentCompression.extractContent)(page.content);
            return page;
          }

          throw notFoundError;
        },

        async listLatest(args) {
          const permission = await (0, _checkBasePermissions.default)(context, PERMISSION_NAME, {
            rwd: "r"
          });
          const {
            sort,
            from,
            size,
            query,
            page
          } = (0, _getNormalizedListPagesArgs.default)(args, context);
          query.filter.push({
            term: {
              "locale.keyword": i18nContent.getLocale().code
            }
          }, {
            term: {
              latest: true
            }
          }); // If users can only manage own records, let's add the special filter.

          if (permission.own === true) {
            const identity = context.security.getIdentity();
            query.filter.push({
              term: {
                "createdBy.id.keyword": identity.id
              }
            });
          }

          const listLatestPlugins = context.plugins.byType(_SearchLatestPagesPlugin.SearchLatestPagesPlugin.type);

          for (const plugin of listLatestPlugins) {
            // Apply query modifications
            plugin.modifyQuery({
              query,
              args,
              context
            }); // Apply sort modifications

            plugin.modifySort({
              sort,
              args,
              context
            });
          }

          const response = await elasticsearch.search(_objectSpread(_objectSpread({}, ES_DEFAULTS()), {}, {
            body: {
              query: {
                bool: {
                  must: query.must.length > 0 ? query.must : undefined,
                  must_not: query.must_not.length > 0 ? query.must_not : undefined,
                  filter: query.filter.length > 0 ? query.filter : undefined
                }
              },
              from,
              size,
              sort
            }
          }));
          const results = response.body.hits;
          const total = results.total.value;
          const data = total > 0 ? results.hits.map(item => item._source) : [];
          const meta = (0, _createListMeta.default)({
            page,
            limit: size,
            totalCount: total
          });
          return [data, meta];
        },

        async listPublished(args) {
          const {
            sort,
            from,
            size,
            query,
            page
          } = (0, _getNormalizedListPagesArgs.default)(args, context);
          query.filter.push({
            term: {
              "locale.keyword": i18nContent.getLocale().code
            }
          }, {
            term: {
              published: true
            }
          });
          const listPublishedPlugins = context.plugins.byType(_SearchPublishedPagesPlugin.SearchPublishedPagesPlugin.type);

          for (const plugin of listPublishedPlugins) {
            // Apply query modifications
            plugin.modifyQuery({
              query,
              args,
              context
            }); // Apply sort modifications

            plugin.modifySort({
              sort,
              args,
              context
            });
          }

          const response = await elasticsearch.search(_objectSpread(_objectSpread({}, ES_DEFAULTS()), {}, {
            body: {
              query: {
                bool: {
                  must: query.must.length > 0 ? query.must : undefined,
                  must_not: query.must_not.length > 0 ? query.must_not : undefined,
                  filter: query.filter.length > 0 ? query.filter : undefined
                }
              },
              from,
              size,
              sort
            }
          }));
          const results = response.body.hits;
          const total = results.total.value;
          const data = total > 0 ? results.hits.map(item => item._source) : [];
          const meta = (0, _createListMeta.default)({
            page,
            limit: size,
            totalCount: total
          });
          return [data, meta];
        },

        async listTags(args) {
          if (args.search.query.length < 2) {
            throw new _error.default("Please provide at least two characters.");
          }

          let query = undefined; // When ES index is shared between tenants, we need to filter records by tenant ID

          const sharedIndex = process.env.ELASTICSEARCH_SHARED_INDEXES === "true";

          if (sharedIndex) {
            const tenant = context.tenancy.getCurrentTenant();
            query = {
              bool: {
                filter: [{
                  term: {
                    "tenant.keyword": tenant.id
                  }
                }]
              }
            };
          }

          const response = await elasticsearch.search(_objectSpread(_objectSpread({}, ES_DEFAULTS()), {}, {
            body: {
              query,
              size: 0,
              aggs: {
                tags: {
                  terms: {
                    field: "tags.keyword",
                    include: `.*${args.search.query}.*`,
                    size: 10
                  }
                }
              }
            }
          }));

          try {
            return response.body.aggregations.tags.buckets.map(item => item.key);
          } catch {
            return [];
          }
        },

        async listPageRevisions(pageId) {
          const [pid] = pageId.split("#");
          const [pages] = await db.read(_objectSpread(_objectSpread({}, _defaults.default.db), {}, {
            query: {
              PK: PK_PAGE(pid),
              SK: {
                $beginsWith: "REV#"
              },
              sort: {
                SK: -1
              }
            }
          }));
          return pages.sort((a, b) => b.version - a.version);
        },

        async create(categorySlug) {
          await (0, _checkBasePermissions.default)(context, PERMISSION_NAME, {
            rwd: "w"
          });
          const category = await context.pageBuilder.categories.get(categorySlug);

          if (!category) {
            throw new _handlerGraphql.NotFoundError(`Category with slug "${categorySlug}" not found.`);
          }

          const title = "Untitled";
          let pagePath = "";

          if (category.slug === "static") {
            pagePath = (0, _normalizePath.default)("untitled-" + _uniqid.default.time());
          } else {
            pagePath = (0, _normalizePath.default)([category.url, "untitled-" + _uniqid.default.time()].join("/").replace(/\/\//g, "/"));
          }

          const identity = context.security.getIdentity();
          new _models.CreateDataModel().populate({
            category: category.slug
          }).validate();
          const [pid, version] = [(0, _mdbid.default)(), 1];
          const zeroPaddedVersion = getZeroPaddedVersionNumber(version);
          const id = `${pid}#${zeroPaddedVersion}`;
          const updateSettingsModel = new _models.UpdateSettingsModel().populate({
            general: {
              layout: category.layout
            }
          });
          const owner = {
            id: identity.id,
            displayName: identity.displayName,
            type: identity.type
          };
          const page = {
            id,
            pid,
            locale: context.i18nContent.getLocale().code,
            tenant: context.tenancy.getCurrentTenant().id,
            editor: DEFAULT_EDITOR,
            category: category.slug,
            title,
            path: pagePath,
            version: 1,
            status: STATUS_DRAFT,
            visibility: {
              list: {
                latest: true,
                published: true
              },
              get: {
                latest: true,
                published: true
              }
            },
            home: false,
            notFound: false,
            locked: false,
            publishedOn: null,
            createdFrom: null,
            settings: await updateSettingsModel.toJSON(),
            savedOn: new Date().toISOString(),
            createdOn: new Date().toISOString(),
            ownedBy: owner,
            createdBy: owner,
            content: (0, _contentCompression.compressContent)() // Just create the initial { compression, content } object.

          };
          await (0, _executeCallbacks.default)(pagePlugins, "beforeCreate", {
            context,
            page
          });

          const ddbData = _objectSpread({
            PK: PK_PAGE(pid),
            SK: `REV#${zeroPaddedVersion}`,
            TYPE: _types.TYPE.PAGE
          }, page);

          const latestPageKeys = {
            PK: PK_PAGE(pid),
            SK: "L"
          };
          await db.batch().create(_objectSpread(_objectSpread({}, _defaults.default.db), {}, {
            data: ddbData
          })).create(_objectSpread(_objectSpread({}, _defaults.default.db), {}, {
            data: _objectSpread(_objectSpread({}, ddbData), latestPageKeys)
          })).create(_objectSpread(_objectSpread({}, _defaults.default.esDb), {}, {
            data: _objectSpread(_objectSpread({}, latestPageKeys), {}, {
              index: ES_DEFAULTS().index,
              data: (0, _esPageData.getESLatestPageData)(context, _objectSpread(_objectSpread({}, ddbData), latestPageKeys))
            })
          })).execute();
          await (0, _executeCallbacks.default)(pagePlugins, "afterCreate", {
            context,
            page
          });
          return (0, _omit.default)(ddbData, ["PK", "SK", "content"]);
        },

        async createFrom(from) {
          const permission = await (0, _checkBasePermissions.default)(context, PERMISSION_NAME, {
            rwd: "w"
          });
          const [fromPid, fromVersion] = from.split("#");
          const [[[page]], [[latestPage]]] = await db.batch().read(_objectSpread(_objectSpread({}, _defaults.default.db), {}, {
            query: {
              PK: PK_PAGE(fromPid),
              SK: `REV#${fromVersion}`
            }
          })).read(_objectSpread(_objectSpread({}, _defaults.default.db), {}, {
            query: {
              PK: PK_PAGE(fromPid),
              SK: "L"
            }
          })).execute();

          if (!page) {
            throw new _handlerGraphql.NotFoundError(`Page "${from}" not found.`);
          } // Must not be able to create a new page (revision) from a page of another author.


          if ((permission === null || permission === void 0 ? void 0 : permission.own) === true) {
            const identity = context.security.getIdentity();

            if (page.ownedBy.id !== identity.id) {
              throw new _apiSecurity.NotAuthorizedError();
            }
          }

          const nextVersion = latestPage.version + 1;
          const zeroPaddedNextVersion = getZeroPaddedVersionNumber(nextVersion);
          const nextId = `${fromPid}#${zeroPaddedNextVersion}`;
          const identity = context.security.getIdentity();

          const data = _objectSpread(_objectSpread({}, page), {}, {
            SK: `REV#${zeroPaddedNextVersion}`,
            id: nextId,
            status: STATUS_DRAFT,
            locked: false,
            publishedOn: null,
            version: nextVersion,
            savedOn: new Date().toISOString(),
            createdFrom: from,
            createdOn: new Date().toISOString(),
            createdBy: {
              id: identity.id,
              displayName: identity.displayName,
              type: identity.type
            }
          });

          await (0, _executeCallbacks.default)(pagePlugins, "beforeCreate", {
            context,
            page: data
          });
          const latestPageKeys = {
            PK: PK_PAGE(fromPid),
            SK: "L"
          };
          const batch = db.batch().create(_objectSpread(_objectSpread({}, _defaults.default.db), {}, {
            data
          })).update(_objectSpread(_objectSpread({}, _defaults.default.db), {}, {
            query: latestPageKeys,
            data: _objectSpread(_objectSpread({}, data), latestPageKeys)
          })); // If the new revision is visible in "latest" page lists, then update the ES index.

          if ((0, _get.default)(data, "visibility.list.latest") !== false) {
            batch.update(_objectSpread(_objectSpread({}, _defaults.default.esDb), {}, {
              query: latestPageKeys,
              data: _objectSpread(_objectSpread({}, latestPageKeys), {}, {
                index: ES_DEFAULTS().index,
                data: (0, _esPageData.getESLatestPageData)(context, data)
              })
            }));
          }

          await batch.execute();
          await (0, _executeCallbacks.default)(pagePlugins, "afterCreate", {
            page: data,
            context
          }); // Extract compressed page content.

          data.content = await (0, _contentCompression.extractContent)(data.content);
          return data;
        },

        async update(id, data) {
          const permission = await (0, _checkBasePermissions.default)(context, PERMISSION_NAME, {
            rwd: "w"
          });
          const [pid, rev] = id.split("#");
          const [[[existingPage]], [[existingLatestPage]]] = await db.batch().read(_objectSpread(_objectSpread({}, _defaults.default.db), {}, {
            query: {
              PK: PK_PAGE(pid),
              SK: `REV#${rev}`
            },
            limit: 1
          })).read(_objectSpread(_objectSpread({}, _defaults.default.db), {}, {
            query: {
              PK: PK_PAGE(pid),
              SK: "L"
            },
            limit: 1
          })).execute();

          if (!existingPage) {
            throw new _handlerGraphql.NotFoundError(`Page "${id}" not found.`);
          }

          if (existingPage.locked) {
            throw new _error.default(`Cannot update page because it's locked.`);
          }

          const identity = context.security.getIdentity();
          (0, _checkOwnPermissions.default)(identity, permission, existingPage, "ownedBy");

          const updateData = _objectSpread(_objectSpread({}, data), {}, {
            savedOn: new Date().toISOString()
          });

          await (0, _executeCallbacks.default)(pagePlugins, "beforeUpdate", {
            context,
            existingPage,
            inputData: data,
            updateData
          });
          const newContent = updateData.content;

          if (newContent) {
            updateData.content = (0, _contentCompression.compressContent)(newContent);
          }

          const newPageData = _objectSpread(_objectSpread({}, existingPage), updateData);

          const newLatestPage = _objectSpread(_objectSpread({}, existingLatestPage), updateData);

          const batch = db.batch().update(_objectSpread(_objectSpread({}, _defaults.default.db), {}, {
            query: {
              PK: PK_PAGE(pid),
              SK: `REV#${rev}`
            },
            data: newPageData
          })); // If we updated the latest rev, make sure the changes are propagated to "L" record and ES.

          if (newLatestPage.id === id) {
            const latestPageKeys = {
              PK: PK_PAGE(pid),
              SK: "L"
            };
            batch.update(_objectSpread(_objectSpread({}, _defaults.default.db), {}, {
              query: latestPageKeys,
              data: newLatestPage
            })); // Update the ES index according to the value of the "latest pages lists" visibility setting.

            if ((0, _get.default)(newPageData, "visibility.list.latest") !== false) {
              batch.update(_objectSpread(_objectSpread({}, _defaults.default.esDb), {}, {
                query: latestPageKeys,
                data: _objectSpread(_objectSpread({}, latestPageKeys), {}, {
                  index: ES_DEFAULTS().index,
                  data: (0, _esPageData.getESLatestPageData)(context, newPageData)
                })
              }));
            } else {
              batch.delete(_objectSpread(_objectSpread({}, _defaults.default.esDb), {}, {
                query: latestPageKeys
              }));
            }
          }

          await batch.execute();
          await (0, _executeCallbacks.default)(pagePlugins, "afterUpdate", {
            context,
            page: newPageData,
            inputData: data
          });
          return _objectSpread(_objectSpread({}, newPageData), {}, {
            content: newContent || newPageData.content
          });
        },

        async delete(pageId) {
          const permission = await (0, _checkBasePermissions.default)(context, PERMISSION_NAME, {
            rwd: "d"
          });
          const [pid, rev] = pageId.split("#");
          const PAGE_PK = PK_PAGE(pid); // 1. Load the page and latest / published page (rev) data.

          const [[[page]], [[latestPage]], [[publishedPage]]] = await db.batch().read(_objectSpread(_objectSpread({}, _defaults.default.db), {}, {
            query: {
              PK: PAGE_PK,
              SK: `REV#${rev}`
            }
          })).read(_objectSpread(_objectSpread({}, _defaults.default.db), {}, {
            query: {
              PK: PAGE_PK,
              SK: "L"
            }
          })).read(_objectSpread(_objectSpread({}, _defaults.default.db), {}, {
            query: {
              PK: PAGE_PK,
              SK: "P"
            }
          })).execute(); // 2. Do a couple of checks.

          if (!page) {
            throw new _handlerGraphql.NotFoundError(`Page "${pageId}" not found.`);
          }

          const identity = context.security.getIdentity();
          (0, _checkOwnPermissions.default)(identity, permission, page, "ownedBy");
          const settings = await context.pageBuilder.settings.default.getCurrent();
          const pages = (settings === null || settings === void 0 ? void 0 : settings.pages) || {};

          for (const key in pages) {
            if (pages[key] === page.pid) {
              throw new _error.default(`Cannot delete page because it's set as ${key}.`);
            }
          } // 3. Let's start updating. But first, let's trigger before-delete hook callbacks.


          await (0, _executeCallbacks.default)(pagePlugins, "beforeDelete", {
            context,
            page,
            latestPage,
            publishedPage
          }); // Before we continue, note that if `publishedPageData` exists, then `publishedPagePathData`
          // also exists. And to delete it, we can read `publishedPageData.path` to get its SK.
          // There can't be a situation where just one record exists, there's always gonna be both.
          // If we are deleting the initial version, we need to remove all versions and all of the meta data.

          if (page.version === 1) {
            // 4.1. We delete pages in batches of 15.
            let publishedPathEntryDeleted = false;

            while (true) {
              const [pageItemCollection] = await db.read(_objectSpread(_objectSpread({}, _defaults.default.db), {}, {
                limit: 15,
                query: {
                  PK: PAGE_PK,
                  SK: {
                    $gte: " "
                  }
                }
              }));

              if (pageItemCollection.length === 0) {
                break;
              }

              const batch = db.batch();

              for (let i = 0; i < pageItemCollection.length; i++) {
                const item = pageItemCollection[i];

                if (item.status === "published" && !publishedPathEntryDeleted) {
                  publishedPathEntryDeleted = true;
                  batch.delete(_objectSpread(_objectSpread({}, _defaults.default.db), {}, {
                    query: {
                      PK: PK_PAGE_PUBLISHED_PATH(),
                      SK: item.path
                    }
                  }));
                }

                batch.delete(_objectSpread(_objectSpread({}, _defaults.default.db), {}, {
                  query: {
                    PK: item.PK,
                    SK: item.SK
                  }
                }));
              }

              await batch.execute();
            } // 4.2. Finally, delete data from ES.


            await db.batch().delete(_objectSpread(_objectSpread({}, _defaults.default.esDb), {}, {
              query: {
                PK: PAGE_PK,
                SK: "L"
              }
            })).delete(_objectSpread(_objectSpread({}, _defaults.default.esDb), {}, {
              query: {
                PK: PAGE_PK,
                SK: "P"
              }
            })).execute();
            await (0, _executeCallbacks.default)(pagePlugins, "afterDelete", {
              context,
              page,
              latestPage,
              publishedPage
            });
            return [page, null];
          } // 5. If we are deleting a specific version (version > 1)...
          // 6.1. Delete the actual page entry.


          const batch = db.batch().delete(_objectSpread(_objectSpread({}, _defaults.default.db), {}, {
            query: {
              PK: PAGE_PK,
              SK: `REV#${rev}`
            }
          })); // 6.2. If the page is published, remove published data, both from DB and ES.

          if (publishedPage && publishedPage.id === page.id) {
            batch.delete(_objectSpread(_objectSpread({}, _defaults.default.db), {}, {
              query: {
                PK: PAGE_PK,
                SK: "P"
              }
            })).delete(_objectSpread(_objectSpread({}, _defaults.default.db), {}, {
              query: {
                PK: PK_PAGE_PUBLISHED_PATH(),
                SK: publishedPage.path
              }
            })).delete(_objectSpread(_objectSpread({}, _defaults.default.esDb), {}, {
              query: {
                PK: PAGE_PK,
                SK: "P"
              }
            }));
          } // 6.3. If the page is latest, assign the previously latest page as the new latest.
          // Updates must be made again both on DB and ES side.


          let newLatestPage;

          if (latestPage.id === page.id) {
            [[newLatestPage]] = await db.read(_objectSpread(_objectSpread({}, _defaults.default.db), {}, {
              query: {
                PK: PAGE_PK,
                SK: {
                  $lt: `REV#${rev}`
                }
              },
              sort: {
                SK: -1
              },
              limit: 1
            })); // Update latest page data.

            batch.update(_objectSpread(_objectSpread({}, _defaults.default.db), {}, {
              query: {
                PK: PAGE_PK,
                SK: "L"
              },
              data: _objectSpread(_objectSpread({}, newLatestPage), {}, {
                PK: PAGE_PK,
                SK: "L"
              })
            })).update(_objectSpread(_objectSpread({}, _defaults.default.esDb), {}, {
              query: {
                PK: PAGE_PK,
                SK: "L"
              },
              data: {
                PK: PAGE_PK,
                SK: "L",
                index: ES_DEFAULTS().index,
                data: (0, _esPageData.getESLatestPageData)(context, newLatestPage)
              }
            }));
          }

          await batch.execute();
          await (0, _executeCallbacks.default)(pagePlugins, "afterDelete", {
            context,
            page,
            latestPage,
            publishedPage
          }); // 7. Done. We return both the deleted page, and the new latest one (if there is one).

          return [page, newLatestPage];
        },

        async publish(pageId) {
          const permission = await (0, _checkBasePermissions.default)(context, PERMISSION_NAME, {
            pw: "p"
          });
          const [pid, rev] = pageId.split("#");
          const PAGE_PK = PK_PAGE(pid); // `publishedPageData` will give us a record that contains `id` and `path, which tell us
          // the current revision and over which path it has been published, respectively.

          const [[[page]], [[publishedPage]], [[latestPage]]] = await db.batch().read(_objectSpread(_objectSpread({}, _defaults.default.db), {}, {
            query: {
              PK: PAGE_PK,
              SK: `REV#${rev}`
            }
          })).read(_objectSpread(_objectSpread({}, _defaults.default.db), {}, {
            query: {
              PK: PAGE_PK,
              SK: "P"
            }
          })).read(_objectSpread(_objectSpread({}, _defaults.default.db), {}, {
            query: {
              PK: PAGE_PK,
              SK: "L"
            }
          })).execute();

          if (!page) {
            throw new _handlerGraphql.NotFoundError(`Page "${pageId}" not found.`);
          }

          const identity = context.security.getIdentity();
          (0, _checkOwnPermissions.default)(identity, permission, page, "ownedBy");

          if (page.status === STATUS_PUBLISHED) {
            throw new _handlerGraphql.NotFoundError(`Page "${pageId}" is already published.`);
          }

          const [[publishedPageOnPath]] = await db.read(_objectSpread(_objectSpread({}, _defaults.default.db), {}, {
            query: {
              PK: PK_PAGE_PUBLISHED_PATH(),
              SK: page.path
            }
          }));
          await (0, _executeCallbacks.default)(pagePlugins, "beforePublish", {
            context,
            page,
            latestPage,
            publishedPage
          });
          const pathTakenByAnotherPage = publishedPageOnPath && publishedPageOnPath.pid !== page.pid; // If this is true, let's unpublish the page first. Note that we're not talking about this
          // same page, but a previous revision. We're talking about a completely different page
          // (with different PID). Remember that page ID equals `PID#version`.

          if (pathTakenByAnotherPage) {
            // Note two things here...
            // 1) It is possible that this call is about to try to unpublish a page that is set as
            // a special page (home / 404). In that case, this whole process will fail, and that
            // is to be expected. Maybe we could think of a better solution in the future, but for
            // now, it works like this. If there was only more ⏱.
            // 2) If a user doesn't have the unpublish permission, again, the whole action will fail.
            await this.unpublish(publishedPageOnPath.id);
          } // Now that the other page has been unpublished, we can continue with publish the current one.
          // Change loaded page's status to published.


          page.status = STATUS_PUBLISHED;
          page.locked = true;
          page.publishedOn = new Date().toISOString(); // We need to issue a couple of updates.

          const batch = db.batch(); // 1. Update the page in the database first.

          batch.update(_objectSpread(_objectSpread({}, _defaults.default.db), {}, {
            query: {
              PK: PAGE_PK,
              SK: `REV#${rev}`
            },
            data: page
          })); // If we just published the latest version, update the latest revision entry too.

          if (latestPage.id === pageId) {
            batch.update(_objectSpread(_objectSpread({}, _defaults.default.db), {}, {
              query: {
                PK: PAGE_PK,
                SK: "L"
              },
              data: _objectSpread(_objectSpread({}, page), {}, {
                PK: PAGE_PK,
                SK: "L"
              })
            }));
          }

          if (publishedPage) {
            const [, publishedRev] = publishedPage.id.split("#");
            batch.update(_objectSpread(_objectSpread({}, _defaults.default.db), {}, {
              query: {
                PK: PAGE_PK,
                SK: `REV#${publishedRev}`
              },
              data: _objectSpread(_objectSpread({}, publishedPage), {}, {
                status: STATUS_UNPUBLISHED,
                PK: PAGE_PK,
                SK: `REV#${publishedRev}`
              })
            })).update(_objectSpread(_objectSpread({}, _defaults.default.db), {}, {
              query: {
                PK: PAGE_PK,
                SK: "P"
              },
              data: _objectSpread(_objectSpread({}, page), {}, {
                PK: PAGE_PK,
                SK: "P"
              })
            })); // If the paths are different, delete previous published-page-on-path entry.

            if (publishedPage.path !== page.path) {
              batch.delete(_objectSpread(_objectSpread({}, _defaults.default.db), {}, {
                query: {
                  PK: PK_PAGE_PUBLISHED_PATH(),
                  SK: publishedPage.path
                }
              })).create(_objectSpread(_objectSpread({}, _defaults.default.db), {}, {
                data: _objectSpread(_objectSpread({}, page), {}, {
                  PK: PK_PAGE_PUBLISHED_PATH(),
                  SK: page.path
                })
              }));
            } else {
              batch.update(_objectSpread(_objectSpread({}, _defaults.default.db), {}, {
                query: {
                  PK: PK_PAGE_PUBLISHED_PATH(),
                  SK: page.path
                },
                data: _objectSpread(_objectSpread({}, page), {}, {
                  PK: PK_PAGE_PUBLISHED_PATH(),
                  SK: page.path
                })
              }));
            }
          } else {
            batch.create(_objectSpread(_objectSpread({}, _defaults.default.db), {}, {
              data: _objectSpread(_objectSpread({}, page), {}, {
                PK: PAGE_PK,
                SK: "P"
              })
            })).create(_objectSpread(_objectSpread({}, _defaults.default.db), {}, {
              data: _objectSpread(_objectSpread({}, page), {}, {
                PK: PK_PAGE_PUBLISHED_PATH(),
                SK: page.path
              })
            }));
          } // If we are publishing the latest revision, let's also update the latest revision entry's
          // status in ES. Also, if we are publishing the latest revision and the "LATEST page lists
          // visibility" is not false, then we need to update the latest page revision entry in ES.


          if ((latestPage === null || latestPage === void 0 ? void 0 : latestPage.id) === pageId && (0, _get.default)(page, "visibility.list.latest") !== false) {
            batch.update(_objectSpread(_objectSpread({}, _defaults.default.esDb), {}, {
              query: {
                PK: PAGE_PK,
                SK: "L"
              },
              data: {
                PK: PAGE_PK,
                SK: "L",
                index: ES_DEFAULTS().index,
                data: (0, _esPageData.getESLatestPageData)(context, page)
              }
            }));
          } // Update the published revision entry in ES,
          // if the "PUBLISHED page lists visibility" setting is not explicitly set to false.


          if ((0, _get.default)(page, "visibility.list.published") !== false) {
            batch.create(_objectSpread(_objectSpread({}, _defaults.default.esDb), {}, {
              data: {
                PK: PAGE_PK,
                SK: "P",
                index: ES_DEFAULTS().index,
                data: (0, _esPageData.getESPublishedPageData)(context, _objectSpread(_objectSpread({}, page), {}, {
                  id: pageId,
                  status: STATUS_PUBLISHED,
                  locked: true
                }))
              }
            }));
          } else {
            batch.delete(_objectSpread(_objectSpread({}, _defaults.default.esDb), {}, {
              query: {
                PK: PAGE_PK,
                SK: "P"
              }
            }));
          }

          await batch.execute();
          await (0, _executeCallbacks.default)(pagePlugins, "afterPublish", {
            context,
            page,
            latestPage,
            publishedPage
          });
          return page;
        },

        async unpublish(pageId) {
          const permission = await (0, _checkBasePermissions.default)(context, PERMISSION_NAME, {
            pw: "u"
          });
          const [pid, rev] = pageId.split("#");
          const PAGE_PK = PK_PAGE(pid);
          const [[[page]], [[publishedPage]], [[latestPage]]] = await db.batch().read(_objectSpread(_objectSpread({}, _defaults.default.db), {}, {
            query: {
              PK: PAGE_PK,
              SK: `REV#${rev}`
            },
            limit: 1
          })).read(_objectSpread(_objectSpread({}, _defaults.default.db), {}, {
            limit: 1,
            query: {
              PK: PAGE_PK,
              SK: "P"
            }
          })).read(_objectSpread(_objectSpread({}, _defaults.default.db), {}, {
            limit: 1,
            query: {
              PK: PAGE_PK,
              SK: "L"
            }
          })).execute();

          if (!page) {
            throw new _handlerGraphql.NotFoundError(`Page "${pageId}" not found.`);
          }

          const identity = context.security.getIdentity();
          (0, _checkOwnPermissions.default)(identity, permission, page, "ownedBy");

          if (!publishedPage || publishedPage.id !== pageId) {
            throw new _error.default(`Page "${pageId}" is not published.`);
          }

          const settings = await context.pageBuilder.settings.default.getCurrent();
          const pages = (settings === null || settings === void 0 ? void 0 : settings.pages) || {};

          for (const key in pages) {
            if (pages[key] === page.pid) {
              throw new _error.default(`Cannot unpublish page because it's set as ${key}.`);
            }
          }

          await (0, _executeCallbacks.default)(pagePlugins, "beforeUnpublish", {
            context,
            page
          });
          page.status = STATUS_UNPUBLISHED;
          const batch = db.batch().delete(_objectSpread(_objectSpread({}, _defaults.default.db), {}, {
            query: {
              PK: PAGE_PK,
              SK: "P"
            }
          })).delete(_objectSpread(_objectSpread({}, _defaults.default.db), {}, {
            query: {
              PK: PK_PAGE_PUBLISHED_PATH(),
              SK: publishedPage.path
            }
          })).update(_objectSpread(_objectSpread({}, _defaults.default.db), {}, {
            query: {
              PK: PAGE_PK,
              SK: `REV#${rev}`
            },
            data: page
          })); // If we are unpublishing the latest revision, let's also update the latest revision entry's
          // status in ES. We can only do that if the entry actually exists, or in other words, if the
          // published page's "LATEST pages lists visibility" setting is not set to false.

          if (latestPage.id === pageId && (0, _get.default)(page, "visibility.list.latest") !== false) {
            batch.update(_objectSpread(_objectSpread({}, _defaults.default.esDb), {}, {
              query: {
                PK: PAGE_PK,
                SK: "L"
              },
              data: {
                PK: PAGE_PK,
                SK: "L",
                index: ES_DEFAULTS().index,
                data: (0, _esPageData.getESLatestPageData)(context, page)
              }
            }));
          } // And of course, delete the published revision entry in ES.


          if ((0, _get.default)(page, "visibility.list.published") !== false) {
            batch.delete(_objectSpread(_objectSpread({}, _defaults.default.esDb), {}, {
              query: {
                PK: PAGE_PK,
                SK: "P"
              }
            }));
          }

          await batch.execute();
          await (0, _executeCallbacks.default)(pagePlugins, "afterUnpublish", {
            context,
            page
          });
          return page;
        },

        async requestReview(pageId) {
          const permission = await (0, _checkBasePermissions.default)(context, PERMISSION_NAME, {
            pw: "r"
          });
          const [pid, rev] = pageId.split("#");
          const PAGE_PK = PK_PAGE(pid);
          const [[[page]], [[latestPageData]]] = await db.batch().read(_objectSpread(_objectSpread({}, _defaults.default.db), {}, {
            query: {
              PK: PAGE_PK,
              SK: `REV#${rev}`
            }
          })).read(_objectSpread(_objectSpread({}, _defaults.default.db), {}, {
            query: {
              PK: PAGE_PK,
              SK: "L"
            }
          })).execute();

          if (!page) {
            throw new _handlerGraphql.NotFoundError(`Page "${pageId}" not found.`);
          }

          const allowedStatuses = [STATUS_DRAFT, STATUS_CHANGES_REQUESTED];

          if (!allowedStatuses.includes(page.status)) {
            throw new _error.default(`Cannot request review - page is not a draft nor a change request has been issued.`);
          }

          const identity = context.security.getIdentity();
          (0, _checkOwnPermissions.default)(identity, permission, page, "ownedBy"); // Change loaded page's status to `reviewRequested`.

          page.status = STATUS_REVIEW_REQUESTED;
          page.locked = true;
          const batch = db.batch().update(_objectSpread(_objectSpread({}, _defaults.default.db), {}, {
            query: {
              PK: PAGE_PK,
              SK: `REV#${rev}`
            },
            data: page
          })); // If we updated the latest version, then make sure the changes are propagated to ES too.

          if (latestPageData.id === pageId) {
            // 0nly update if the "LATEST pages lists visibility" is not set to false.
            if ((0, _get.default)(page, "visibility.list.latest") !== false) {
              batch.update(_objectSpread(_objectSpread({}, _defaults.default.esDb), {}, {
                query: {
                  PK: PAGE_PK,
                  SK: "L"
                },
                data: {
                  PK: PAGE_PK,
                  SK: "L",
                  index: ES_DEFAULTS().index,
                  data: (0, _esPageData.getESLatestPageData)(context, page)
                }
              }));
            }
          }

          await batch.execute();
          return page;
        },

        async requestChanges(pageId) {
          const permission = await (0, _checkBasePermissions.default)(context, PERMISSION_NAME, {
            pw: "c"
          });
          const [pid, rev] = pageId.split("#");
          const PAGE_PK = PK_PAGE(pid);
          const [[[page]], [[latestPageData]]] = await db.batch().read(_objectSpread(_objectSpread({}, _defaults.default.db), {}, {
            query: {
              PK: PAGE_PK,
              SK: `REV#${rev}`
            }
          })).read(_objectSpread(_objectSpread({}, _defaults.default.db), {}, {
            query: {
              PK: PAGE_PK,
              SK: "L"
            }
          })).execute();

          if (!page) {
            throw new _handlerGraphql.NotFoundError(`Page "${pageId}" not found.`);
          }

          if (page.status !== STATUS_REVIEW_REQUESTED) {
            throw new _error.default(`Cannot request changes on a page that's not under review.`, "REQUESTED_CHANGES_ON_PAGE_REVISION_NOT_UNDER_REVIEW");
          }

          const identity = context.security.getIdentity();

          if (page.createdBy.id === identity.id) {
            throw new _error.default("Cannot request changes on page revision you created.", "REQUESTED_CHANGES_ON_PAGE_REVISION_YOU_CREATED");
          }

          (0, _checkOwnPermissions.default)(identity, permission, page, "ownedBy"); // Change loaded page's status to published.

          page.status = STATUS_CHANGES_REQUESTED;
          page.locked = false;
          const batch = await db.batch().update(_objectSpread(_objectSpread({}, _defaults.default.db), {}, {
            query: {
              PK: PAGE_PK,
              SK: `REV#${rev}`
            },
            data: page
          })); // If we updated the latest version, then make sure the changes are propagated to ES too.

          if (latestPageData.id === pageId) {
            // Only update if the "LATEST pages lists visibility" is not set to false.
            if ((0, _get.default)(page, "visibility.list.latest") !== false) {
              batch.update(_objectSpread(_objectSpread({}, _defaults.default.esDb), {}, {
                query: {
                  PK: PAGE_PK,
                  SK: "L"
                },
                data: {
                  PK: PAGE_PK,
                  SK: "L",
                  index: ES_DEFAULTS().index,
                  data: (0, _esPageData.getESLatestPageData)(context, page)
                }
              }));
            }
          }

          await batch.execute();
          return page;
        },

        prerendering: {
          async render(args) {
            var _current$prerendering;

            const current = await context.pageBuilder.settings.default.getCurrent();
            const appUrl = (0, _get.default)(current, "prerendering.app.url");
            const storageName = (0, _get.default)(current, "prerendering.storage.name");

            if (!appUrl || !storageName) {
              return;
            }

            const meta = (0, _merge.default)(current === null || current === void 0 ? void 0 : (_current$prerendering = current.prerendering) === null || _current$prerendering === void 0 ? void 0 : _current$prerendering.meta, {
              tenant: context.tenancy.getCurrentTenant().id,
              locale: i18nContent.getLocale().code
            });
            const {
              paths,
              tags
            } = args;
            const dbNamespace = "T#" + context.tenancy.getCurrentTenant().id;

            if (Array.isArray(paths)) {
              await context.prerenderingServiceClient.render(paths.map(item => ({
                url: appUrl + item.path,
                configuration: (0, _merge.default)({
                  meta,
                  storage: {
                    folder: (0, _trimStart.default)(item.path, "/"),
                    name: storageName
                  },
                  db: {
                    namespace: dbNamespace
                  }
                }, item.configuration)
              })));
            }

            if (Array.isArray(tags)) {
              await context.prerenderingServiceClient.queue.add(tags.map(item => ({
                render: {
                  tag: item.tag,
                  configuration: (0, _merge.default)({
                    db: {
                      namespace: dbNamespace
                    }
                  }, item.configuration)
                }
              })));
            }
          },

          async flush(args) {
            const current = await context.pageBuilder.settings.default.getCurrent();
            const appUrl = (0, _get.default)(current, "prerendering.app.url");
            const storageName = (0, _get.default)(current, "prerendering.storage.name");

            if (!storageName) {
              return;
            }

            const {
              paths,
              tags
            } = args;
            const dbNamespace = "T#" + context.tenancy.getCurrentTenant().id;

            if (Array.isArray(paths)) {
              await context.prerenderingServiceClient.flush(paths.map(p => ({
                url: appUrl + p.path,
                // Configuration is mainly static (defined here), but some configuration
                // overrides can arrive via the call args, so let's do a merge here.
                configuration: (0, _merge.default)({
                  db: {
                    namespace: dbNamespace
                  }
                }, p.configuration)
              })));
            }

            if (Array.isArray(tags)) {
              await context.prerenderingServiceClient.queue.add(tags.map(item => ({
                flush: {
                  tag: item.tag,
                  configuration: (0, _merge.default)({
                    db: {
                      namespace: dbNamespace
                    }
                  }, item.configuration)
                }
              })));
            }
          }

        }
      }
    });
  }

};
var _default = plugin;
exports.default = _default;
//# sourceMappingURL=pages.crud.js.map