"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _error = _interopRequireDefault(require("@webiny/error"));

var _apiSecurity = require("@webiny/api-security");

var _apiUpgrade = require("@webiny/api-upgrade");

var _executeCallbacks = _interopRequireDefault(require("./utils/executeCallbacks"));

var _welcomeToWebinyPageData = require("./install/welcome-to-webiny-page-data");

var _notFoundPageData = require("./install/notFoundPageData");

var _savePageAssets = _interopRequireDefault(require("./install/utils/savePageAssets"));

var _defaults = _interopRequireDefault(require("./utils/defaults"));

var _InstallationPlugin = require("../../plugins/InstallationPlugin");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

var _default = {
  type: "context",

  apply(context) {
    const {
      tenancy,
      db
    } = context;

    const keys = () => ({
      PK: `T#${tenancy.getCurrentTenant().id}#SYSTEM`,
      SK: "PB"
    });

    context.pageBuilder = _objectSpread(_objectSpread({}, context.pageBuilder), {}, {
      system: {
        async getVersion() {
          const [[system]] = await db.read(_objectSpread(_objectSpread({}, _defaults.default.db), {}, {
            query: keys()
          }));
          return system ? system.version : null;
        },

        async setVersion(version) {
          const [[system]] = await db.read(_objectSpread(_objectSpread({}, _defaults.default.db), {}, {
            query: keys()
          }));

          if (system) {
            await db.update(_objectSpread(_objectSpread({}, _defaults.default.db), {}, {
              query: keys(),
              data: {
                version
              }
            }));
          } else {
            await db.create(_objectSpread(_objectSpread({}, _defaults.default.db), {}, {
              data: _objectSpread(_objectSpread({}, keys()), {}, {
                version
              })
            }));
          }
        },

        async install({
          name,
          insertDemoData
        }) {
          const {
            pageBuilder,
            fileManager,
            elasticsearch
          } = context;
          const hookPlugins = context.plugins.byType(_InstallationPlugin.InstallationPlugin.type);
          await (0, _executeCallbacks.default)(hookPlugins, "beforeInstall", {
            context
          }); // Check whether the PB app is already installed

          const version = await pageBuilder.system.getVersion();

          if (version) {
            throw new _error.default("Page builder is already installed.", "PB_INSTALL_ABORTED");
          } // 1. Create ES index if it doesn't already exist.


          const {
            index
          } = _defaults.default.es(context);

          const {
            body: exists
          } = await elasticsearch.indices.exists({
            index
          });

          if (!exists) {
            await elasticsearch.indices.create({
              index,
              body: {
                // need this part for sorting to work on text fields
                settings: {
                  analysis: {
                    analyzer: {
                      lowercase_analyzer: {
                        type: "custom",
                        filter: ["lowercase", "trim"],
                        tokenizer: "keyword"
                      }
                    }
                  }
                },
                mappings: {
                  properties: {
                    property: {
                      type: "text",
                      fields: {
                        keyword: {
                          type: "keyword",
                          ignore_above: 256
                        }
                      },
                      analyzer: "lowercase_analyzer"
                    }
                  }
                }
              }
            });
          }

          if (insertDemoData) {
            // 2. Create initial page category.
            let staticCategory = await pageBuilder.categories.get("static");

            if (!staticCategory) {
              staticCategory = await pageBuilder.categories.create({
                name: "Static",
                slug: "static",
                url: "/static/",
                layout: "static"
              });
              pageBuilder.categories.dataLoaders.get.clearAll();
            } // 3. Create page blocks.
            // Upload page data images


            const fileIdToKeyMap = await (0, _savePageAssets.default)({
              context
            }); // 4. Create initial menu.

            const mainMenu = await pageBuilder.menus.get("main-menu");

            if (!mainMenu) {
              await pageBuilder.menus.create({
                title: "Main Menu",
                slug: "main-menu",
                description: "The main menu of the website, containing links to most important pages."
              });
            } // 5. Create sample pages.


            const {
              pages
            } = pageBuilder;
            const fmSettings = await fileManager.settings.getSettings();
            const welcomeToWebinyPageContent = (0, _welcomeToWebinyPageData.preparePageData)({
              srcPrefix: fmSettings && fmSettings.srcPrefix,
              fileIdToKeyMap
            });
            const initialPages = [{
              title: "Welcome to Webiny",
              path: "/welcome-to-webiny",
              content: welcomeToWebinyPageContent,
              settings: {}
            }, {
              title: "Not Found",
              path: "/not-found",
              content: _notFoundPageData.notFoundPageData,
              settings: {},
              // Do not show the page in page lists, only direct get is possible.
              visibility: {
                get: {
                  latest: true,
                  published: true
                },
                list: {
                  latest: false,
                  published: false
                }
              }
            }];
            const [homePage, notFoundPage] = await Promise.all(initialPages.map(data => pages.create(staticCategory.slug).then(page => pages.update(page.id, data)).then(page => pages.publish(page.id))));
            await pageBuilder.settings.default.update({
              name: name,
              pages: {
                home: homePage.pid,
                notFound: notFoundPage.pid
              }
            });
          } // 6. Mark the Page Builder app as installed.


          await this.setVersion(context.WEBINY_VERSION);
          await (0, _executeCallbacks.default)(hookPlugins, "afterInstall", {
            context
          });
        },

        async upgrade(version) {
          const identity = context.security.getIdentity();

          if (!identity) {
            throw new _apiSecurity.NotAuthorizedError();
          }

          const upgradePlugins = context.plugins.byType("api-upgrade").filter(pl => pl.app === "page-builder");
          const plugin = (0, _apiUpgrade.getApplicablePlugin)({
            deployedVersion: context.WEBINY_VERSION,
            installedAppVersion: await this.getVersion(),
            upgradePlugins,
            upgradeToVersion: version
          });
          await plugin.apply(context); // Store new app version

          await this.setVersion(version);
          return true;
        }

      }
    });
  }

};
exports.default = _default;
//# sourceMappingURL=system.crud.js.map