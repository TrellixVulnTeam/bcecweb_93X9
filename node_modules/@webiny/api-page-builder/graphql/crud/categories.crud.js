"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _defaults = _interopRequireDefault(require("./utils/defaults"));

var _dataloader = _interopRequireDefault(require("dataloader"));

var _fields = require("@commodo/fields");

var _validation = require("@webiny/validation");

var _getPKPrefix = _interopRequireDefault(require("./utils/getPKPrefix"));

var _apiSecurity = require("@webiny/api-security");

var _hasRwd = _interopRequireDefault(require("./utils/hasRwd"));

var _handlerGraphql = require("@webiny/handler-graphql");

var _checkBasePermissions = _interopRequireDefault(require("./utils/checkBasePermissions"));

var _checkOwnPermissions = _interopRequireDefault(require("./utils/checkOwnPermissions"));

var _error = _interopRequireDefault(require("@webiny/error"));

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

const CreateDataModel = (0, _fields.withFields)({
  slug: (0, _fields.string)({
    validation: _validation.validation.create("required,minLength:1,maxLength:100")
  }),
  name: (0, _fields.string)({
    validation: _validation.validation.create("required,minLength:1,maxLength:100")
  }),
  url: (0, _fields.string)({
    validation: _validation.validation.create("required,minLength:1,maxLength:100")
  }),
  layout: (0, _fields.string)({
    validation: _validation.validation.create("required,minLength:1,maxLength:100")
  })
})();
const UpdateDataModel = (0, _fields.withFields)({
  name: (0, _fields.string)({
    validation: _validation.validation.create("minLength:1,maxLength:100")
  }),
  url: (0, _fields.string)({
    validation: _validation.validation.create("minLength:1,maxLength:100")
  }),
  layout: (0, _fields.string)({
    validation: _validation.validation.create("minLength:1,maxLength:100")
  })
})();
const TYPE = "pb.category";
const PERMISSION_NAME = TYPE;
const plugin = {
  type: "context",

  async apply(context) {
    const {
      db
    } = context;

    const PK = () => `${(0, _getPKPrefix.default)(context)}C`;

    const ES_DEFAULTS = () => _defaults.default.es(context);

    const {
      getPermission
    } = context.security;
    context.pageBuilder = _objectSpread(_objectSpread({}, context.pageBuilder), {}, {
      categories: {
        dataLoaders: {
          get: new _dataloader.default(async slugs => {
            const batch = db.batch();

            for (let i = 0; i < slugs.length; i++) {
              batch.read(_objectSpread(_objectSpread({}, _defaults.default.db), {}, {
                query: {
                  PK: PK(),
                  SK: slugs[i]
                }
              }));
            }

            const results = await batch.execute();
            return results.map(([response]) => {
              return response[0];
            });
          })
        },

        async get(slug, options = {
          auth: true
        }) {
          const {
            auth
          } = options;

          if (auth === false) {
            return await this.dataLoaders.get.load(slug);
          }

          await context.i18nContent.checkI18NContentPermission();
          let permission;
          const categoryPermission = await getPermission("pb.category");

          if (categoryPermission && (0, _hasRwd.default)(categoryPermission, "r")) {
            permission = categoryPermission;
          } else {
            // If we don't have the necessary `categoryPermission` permission, let's still check if the
            // user has the permission to write pages. If so, we still want to allow listing categories,
            // because this is needed in order to create a page.
            const pagePermission = await getPermission("pb.page");

            if (pagePermission && (0, _hasRwd.default)(pagePermission, "w")) {
              permission = pagePermission;
            }
          }

          if (!permission) {
            throw new _apiSecurity.NotAuthorizedError();
          }

          const category = await this.dataLoaders.get.load(slug);
          const identity = context.security.getIdentity();
          (0, _checkOwnPermissions.default)(identity, permission, category);
          return category;
        },

        async list() {
          await context.i18nContent.checkI18NContentPermission();
          let permission;
          const categoryPermission = await getPermission("pb.category");

          if (categoryPermission && (0, _hasRwd.default)(categoryPermission, "r")) {
            permission = categoryPermission;
          } else {
            // If we don't have the necessary `categoryPermission` permission, let's still check if the
            // user has the permission to write pages. If so, we still want to allow listing categories,
            // because this is needed in order to create a page.
            const pagePermission = await getPermission("pb.page");

            if (pagePermission && (0, _hasRwd.default)(pagePermission, "w")) {
              permission = pagePermission;
            }
          }

          if (!permission) {
            throw new _apiSecurity.NotAuthorizedError();
          }

          const [categories] = await db.read(_objectSpread(_objectSpread({}, _defaults.default.db), {}, {
            query: {
              PK: PK(),
              SK: {
                $gt: " "
              }
            }
          })); // If user can only manage own records, let's check if he owns the loaded one.

          if (permission.own) {
            const identity = context.security.getIdentity();
            return categories.filter(category => category.createdBy.id === identity.id);
          }

          return categories;
        },

        async create(data) {
          await (0, _checkBasePermissions.default)(context, PERMISSION_NAME, {
            rwd: "w"
          });
          const existingCategory = await this.dataLoaders.get.load(data.slug);

          if (existingCategory) {
            throw new _handlerGraphql.NotFoundError(`Category with slug "${data.slug}" already exists.`);
          }

          const createDataModel = new CreateDataModel().populate(data);
          await createDataModel.validate();
          const identity = context.security.getIdentity();
          const createData = Object.assign(await createDataModel.toJSON(), {
            createdOn: new Date().toISOString(),
            createdBy: {
              id: identity.id,
              type: identity.type,
              displayName: identity.displayName
            }
          });
          await db.create(_objectSpread(_objectSpread({}, _defaults.default.db), {}, {
            data: _objectSpread(_objectSpread({}, createData), {}, {
              PK: PK(),
              SK: createDataModel.slug,
              TYPE,
              tenant: context.tenancy.getCurrentTenant().id,
              locale: context.i18nContent.getLocale().code
            })
          }));
          return createData;
        },

        async update(slug, data) {
          const permission = await (0, _checkBasePermissions.default)(context, PERMISSION_NAME, {
            rwd: "w"
          });
          const category = await this.get(slug);

          if (!category) {
            throw new _handlerGraphql.NotFoundError(`Category "${slug}" not found.`);
          }

          const identity = context.security.getIdentity();
          (0, _checkOwnPermissions.default)(identity, permission, category);
          const updateDataModel = new UpdateDataModel().populate(data);
          await updateDataModel.validate();
          const updateData = await updateDataModel.toJSON({
            onlyDirty: true
          });
          await db.update(_objectSpread(_objectSpread({}, _defaults.default.db), {}, {
            query: {
              PK: PK(),
              SK: slug
            },
            data: updateData
          }));
          return _objectSpread(_objectSpread({}, category), updateData);
        },

        async delete(slug) {
          const permission = await (0, _checkBasePermissions.default)(context, PERMISSION_NAME, {
            rwd: "d"
          });
          const category = await this.get(slug);

          if (!category) {
            throw new _handlerGraphql.NotFoundError(`Category "${slug}" not found.`);
          }

          const identity = context.security.getIdentity();
          (0, _checkOwnPermissions.default)(identity, permission, category); // Before deleting, let's check if there is a page that's in this category.
          // If so, let's prevent this.
          // Note: this try-catch is here because in tests, we have a case where a page is not created yet.
          // In that case, this is searching over an index that doesn't exist, and throws an error.
          // So for that case, if the error is `index_not_found_exception`, then let's just ignore it.

          try {
            const filter = [{
              term: {
                "category.keyword": category.slug
              }
            }]; // When ES index is shared between tenants, we need to filter records by tenant ID

            const sharedIndex = process.env.ELASTICSEARCH_SHARED_INDEXES === "true";

            if (sharedIndex) {
              const tenant = context.tenancy.getCurrentTenant();
              filter.push({
                term: {
                  "tenant.keyword": tenant.id
                }
              });
            }

            const response = await context.elasticsearch.search(_objectSpread(_objectSpread({}, ES_DEFAULTS()), {}, {
              body: {
                size: 1,
                query: {
                  bool: {
                    filter
                  }
                }
              }
            }));
            const results = response.body.hits;
            const total = results.total.value;

            if (total) {
              throw new _error.default("Cannot delete category because some pages are linked to it.", "CANNOT_DELETE_CATEGORY_PAGE_EXISTING");
            }
          } catch (e) {
            if (process.env.NODE_ENV !== "test") {
              throw e;
            }

            if (e.message !== "index_not_found_exception") {
              throw e;
            }
          }

          await db.delete(_objectSpread(_objectSpread({}, _defaults.default.db), {}, {
            query: {
              PK: PK(),
              SK: slug
            }
          }));
          return category;
        }

      }
    });
  }

};
var _default = plugin;
exports.default = _default;
//# sourceMappingURL=categories.crud.js.map