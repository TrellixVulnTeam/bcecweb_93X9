{"version":3,"sources":["../../../src/graphql/crud/categories.crud.ts"],"names":["CreateDataModel","slug","validation","create","name","url","layout","UpdateDataModel","TYPE","PERMISSION_NAME","plugin","type","apply","context","db","PK","ES_DEFAULTS","defaults","es","getPermission","security","pageBuilder","categories","dataLoaders","get","DataLoader","slugs","batch","i","length","read","query","SK","results","execute","map","response","options","auth","load","i18nContent","checkI18NContentPermission","permission","categoryPermission","pagePermission","NotAuthorizedError","category","identity","getIdentity","list","$gt","own","filter","createdBy","id","data","rwd","existingCategory","NotFoundError","createDataModel","populate","validate","createData","Object","assign","toJSON","createdOn","Date","toISOString","displayName","tenant","tenancy","getCurrentTenant","locale","getLocale","code","update","updateDataModel","updateData","onlyDirty","delete","term","sharedIndex","process","env","ELASTICSEARCH_SHARED_INDEXES","push","elasticsearch","search","body","size","bool","hits","total","value","Error","e","NODE_ENV","message"],"mappings":"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","sourcesContent":["import defaults from \"./utils/defaults\";\nimport DataLoader from \"dataloader\";\nimport { withFields, string } from \"@commodo/fields\";\nimport { validation } from \"@webiny/validation\";\nimport getPKPrefix from \"./utils/getPKPrefix\";\nimport { Category, PbContext } from \"../../types\";\nimport { ContextPlugin } from \"@webiny/handler/types\";\nimport { NotAuthorizedError } from \"@webiny/api-security\";\nimport hasRwd from \"./utils/hasRwd\";\nimport { NotFoundError } from \"@webiny/handler-graphql\";\nimport checkBasePermissions from \"./utils/checkBasePermissions\";\nimport checkOwnPermissions from \"./utils/checkOwnPermissions\";\nimport Error from \"@webiny/error\";\n\nconst CreateDataModel = withFields({\n    slug: string({ validation: validation.create(\"required,minLength:1,maxLength:100\") }),\n    name: string({ validation: validation.create(\"required,minLength:1,maxLength:100\") }),\n    url: string({ validation: validation.create(\"required,minLength:1,maxLength:100\") }),\n    layout: string({ validation: validation.create(\"required,minLength:1,maxLength:100\") })\n})();\n\nconst UpdateDataModel = withFields({\n    name: string({ validation: validation.create(\"minLength:1,maxLength:100\") }),\n    url: string({ validation: validation.create(\"minLength:1,maxLength:100\") }),\n    layout: string({ validation: validation.create(\"minLength:1,maxLength:100\") })\n})();\n\nconst TYPE = \"pb.category\";\nconst PERMISSION_NAME = TYPE;\n\nconst plugin: ContextPlugin<PbContext> = {\n    type: \"context\",\n    async apply(context) {\n        const { db } = context;\n        const PK = () => `${getPKPrefix(context)}C`;\n        const ES_DEFAULTS = () => defaults.es(context);\n\n        const { getPermission } = context.security;\n\n        context.pageBuilder = {\n            ...context.pageBuilder,\n            categories: {\n                dataLoaders: {\n                    get: new DataLoader(async slugs => {\n                        const batch = db.batch();\n\n                        for (let i = 0; i < slugs.length; i++) {\n                            batch.read({\n                                ...defaults.db,\n                                query: { PK: PK(), SK: slugs[i] }\n                            });\n                        }\n\n                        const results = await batch.execute();\n                        return results.map(([response]) => {\n                            return response[0];\n                        });\n                    })\n                },\n                async get(slug, options = { auth: true }) {\n                    const { auth } = options;\n\n                    if (auth === false) {\n                        return await this.dataLoaders.get.load(slug);\n                    }\n\n                    await context.i18nContent.checkI18NContentPermission();\n\n                    let permission;\n                    const categoryPermission = await getPermission(\"pb.category\");\n                    if (categoryPermission && hasRwd(categoryPermission, \"r\")) {\n                        permission = categoryPermission;\n                    } else {\n                        // If we don't have the necessary `categoryPermission` permission, let's still check if the\n                        // user has the permission to write pages. If so, we still want to allow listing categories,\n                        // because this is needed in order to create a page.\n                        const pagePermission = await getPermission(\"pb.page\");\n                        if (pagePermission && hasRwd(pagePermission, \"w\")) {\n                            permission = pagePermission;\n                        }\n                    }\n\n                    if (!permission) {\n                        throw new NotAuthorizedError();\n                    }\n\n                    const category = await this.dataLoaders.get.load(slug);\n\n                    const identity = context.security.getIdentity();\n                    checkOwnPermissions(identity, permission, category);\n\n                    return category;\n                },\n\n                async list() {\n                    await context.i18nContent.checkI18NContentPermission();\n\n                    let permission;\n                    const categoryPermission = await getPermission(\"pb.category\");\n                    if (categoryPermission && hasRwd(categoryPermission, \"r\")) {\n                        permission = categoryPermission;\n                    } else {\n                        // If we don't have the necessary `categoryPermission` permission, let's still check if the\n                        // user has the permission to write pages. If so, we still want to allow listing categories,\n                        // because this is needed in order to create a page.\n                        const pagePermission = await getPermission(\"pb.page\");\n                        if (pagePermission && hasRwd(pagePermission, \"w\")) {\n                            permission = pagePermission;\n                        }\n                    }\n\n                    if (!permission) {\n                        throw new NotAuthorizedError();\n                    }\n\n                    const [categories] = await db.read<Category>({\n                        ...defaults.db,\n                        query: { PK: PK(), SK: { $gt: \" \" } }\n                    });\n\n                    // If user can only manage own records, let's check if he owns the loaded one.\n                    if (permission.own) {\n                        const identity = context.security.getIdentity();\n                        return categories.filter(category => category.createdBy.id === identity.id);\n                    }\n\n                    return categories;\n                },\n                async create(data) {\n                    await checkBasePermissions(context, PERMISSION_NAME, { rwd: \"w\" });\n\n                    const existingCategory = await this.dataLoaders.get.load(data.slug);\n                    if (existingCategory) {\n                        throw new NotFoundError(\n                            `Category with slug \"${data.slug}\" already exists.`\n                        );\n                    }\n\n                    const createDataModel = new CreateDataModel().populate(data);\n                    await createDataModel.validate();\n\n                    const identity = context.security.getIdentity();\n\n                    const createData = Object.assign(await createDataModel.toJSON(), {\n                        createdOn: new Date().toISOString(),\n                        createdBy: {\n                            id: identity.id,\n                            type: identity.type,\n                            displayName: identity.displayName\n                        }\n                    });\n\n                    await db.create({\n                        ...defaults.db,\n                        data: {\n                            ...createData,\n                            PK: PK(),\n                            SK: createDataModel.slug,\n                            TYPE,\n                            tenant: context.tenancy.getCurrentTenant().id,\n                            locale: context.i18nContent.getLocale().code\n                        }\n                    });\n\n                    return createData;\n                },\n                async update(slug, data) {\n                    const permission = await checkBasePermissions(context, PERMISSION_NAME, {\n                        rwd: \"w\"\n                    });\n\n                    const category = await this.get(slug);\n                    if (!category) {\n                        throw new NotFoundError(`Category \"${slug}\" not found.`);\n                    }\n\n                    const identity = context.security.getIdentity();\n                    checkOwnPermissions(identity, permission, category);\n\n                    const updateDataModel = new UpdateDataModel().populate(data);\n                    await updateDataModel.validate();\n\n                    const updateData = await updateDataModel.toJSON({ onlyDirty: true });\n\n                    await db.update({\n                        ...defaults.db,\n                        query: { PK: PK(), SK: slug },\n                        data: updateData\n                    });\n\n                    return { ...category, ...updateData };\n                },\n                async delete(slug) {\n                    const permission = await checkBasePermissions(context, PERMISSION_NAME, {\n                        rwd: \"d\"\n                    });\n\n                    const category = await this.get(slug);\n                    if (!category) {\n                        throw new NotFoundError(`Category \"${slug}\" not found.`);\n                    }\n\n                    const identity = context.security.getIdentity();\n                    checkOwnPermissions(identity, permission, category);\n\n                    // Before deleting, let's check if there is a page that's in this category.\n                    // If so, let's prevent this.\n\n                    // Note: this try-catch is here because in tests, we have a case where a page is not created yet.\n                    // In that case, this is searching over an index that doesn't exist, and throws an error.\n                    // So for that case, if the error is `index_not_found_exception`, then let's just ignore it.\n                    try {\n                        const filter: any = [{ term: { \"category.keyword\": category.slug } }];\n\n                        // When ES index is shared between tenants, we need to filter records by tenant ID\n                        const sharedIndex = process.env.ELASTICSEARCH_SHARED_INDEXES === \"true\";\n                        if (sharedIndex) {\n                            const tenant = context.tenancy.getCurrentTenant();\n                            filter.push({ term: { \"tenant.keyword\": tenant.id } });\n                        }\n\n                        const response = await context.elasticsearch.search({\n                            ...ES_DEFAULTS(),\n                            body: {\n                                size: 1,\n                                query: {\n                                    bool: {\n                                        filter\n                                    }\n                                }\n                            }\n                        });\n\n                        const results = response.body.hits;\n                        const total = results.total.value;\n\n                        if (total) {\n                            throw new Error(\n                                \"Cannot delete category because some pages are linked to it.\",\n                                \"CANNOT_DELETE_CATEGORY_PAGE_EXISTING\"\n                            );\n                        }\n                    } catch (e) {\n                        if (process.env.NODE_ENV !== \"test\") {\n                            throw e;\n                        }\n\n                        if (e.message !== \"index_not_found_exception\") {\n                            throw e;\n                        }\n                    }\n\n                    await db.delete({\n                        ...defaults.db,\n                        query: { PK: PK(), SK: slug }\n                    });\n\n                    return category;\n                }\n            }\n        };\n    }\n};\n\nexport default plugin;\n"],"file":"categories.crud.js"}