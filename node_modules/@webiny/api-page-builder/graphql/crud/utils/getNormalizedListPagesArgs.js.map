{"version":3,"sources":["../../../../src/graphql/crud/utils/getNormalizedListPagesArgs.ts"],"names":["args","context","normalized","query","getQuery","sort","getSort","size","limit","from","page","where","search","exclude","filter","must","must_not","should","sharedIndex","process","env","ELASTICSEARCH_SHARED_INDEXES","tenant","tenancy","getCurrentTenant","push","term","id","category","status","tags","Array","isArray","length","rule","terms","bool","map","tag","query_string","allow_leading_wildcard","fields","paths","pageIds","forEach","item","includes","pid","normalizedSort","createdOn","order","unmapped_type","publishedOn","title"],"mappings":"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","sourcesContent":["import { ListPagesParams, PbContext } from \"../../types\";\nimport { ElasticsearchBoolQueryConfig } from \"@webiny/api-elasticsearch/types\";\nimport trimEnd from \"lodash/trimEnd\";\n\n/**\n * Returns arguments suited to be sent to ElasticSearch's `search` method.\n */\nexport default (args: ListPagesParams, context: PbContext) => {\n    const normalized = {\n        query: getQuery(args, context),\n        sort: getSort(args.sort),\n        size: args.limit ?? 10,\n        from: 0,\n        page: args.page || 1\n    };\n\n    normalized.from = (normalized.page - 1) * normalized.size;\n    return normalized;\n};\n\nconst getQuery = (args: ListPagesParams, context: PbContext): ElasticsearchBoolQueryConfig => {\n    const { where, search, exclude } = args;\n    const query: ElasticsearchBoolQueryConfig = {\n        filter: [],\n        must: [],\n        must_not: [],\n        should: []\n    };\n\n    // When ES index is shared between tenants, we need to filter records by tenant ID\n    const sharedIndex = process.env.ELASTICSEARCH_SHARED_INDEXES === \"true\";\n    if (sharedIndex) {\n        const tenant = context.tenancy.getCurrentTenant();\n        query.filter.push({ term: { \"tenant.keyword\": tenant.id } });\n    }\n\n    if (where) {\n        if (where.category) {\n            query.filter.push({ term: { \"category.keyword\": where.category } });\n        }\n\n        if (where.status) {\n            query.filter.push({ term: { \"status.keyword\": where.status } });\n        }\n\n        const tags = where.tags;\n        if (tags && Array.isArray(tags.query) && tags.query.length > 0) {\n            if (tags.rule === \"any\") {\n                query.filter.push({\n                    terms: { \"tags.keyword\": tags.query }\n                });\n            } else {\n                query.filter.push({\n                    bool: {\n                        must: where.tags.query.map(tag => ({\n                            term: { \"tags.keyword\": tag }\n                        }))\n                    }\n                });\n            }\n        }\n    }\n\n    if (search && search.query) {\n        query.must.push({\n            query_string: {\n                query: `*${search.query}*`,\n                allow_leading_wildcard: true,\n                fields: [\"title\", \"snippet\"]\n            }\n        });\n    }\n    // Prepare query to exclude page which match provided id and/or path.\n    if (Array.isArray(exclude) && exclude.length !== 0) {\n        const paths = [];\n        const pageIds = [];\n\n        exclude.forEach(item => {\n            // Page \"path\" will always starts with a slash.\n            if (item.includes(\"/\")) {\n                // Let's also ensure the trailing slash is removed.\n                paths.push(trimEnd(item, \"/\"));\n            } else {\n                pageIds.push(item);\n            }\n        });\n\n        if (paths.length) {\n            query.must_not.push({\n                terms: {\n                    \"path.keyword\": paths\n                }\n            });\n        }\n\n        if (pageIds.length) {\n            query.must_not.push({\n                terms: {\n                    pid: pageIds\n                }\n            });\n        }\n    }\n\n    return query;\n};\n\nconst getSort = sort => {\n    if (!sort) {\n        return {};\n    }\n\n    const normalizedSort: Record<string, any> = {};\n    if (sort.createdOn) {\n        normalizedSort[\"createdOn\"] = {\n            order: sort.createdOn,\n\n            unmapped_type: \"date\"\n        };\n    }\n\n    if (sort.publishedOn) {\n        normalizedSort[\"publishedOn\"] = {\n            order: sort.publishedOn,\n\n            unmapped_type: \"date\"\n        };\n    }\n\n    if (sort.title) {\n        normalizedSort[\"titleLC.keyword\"] = {\n            order: sort.title,\n\n            unmapped_type: \"text\"\n        };\n    }\n\n    return normalizedSort;\n};\n"],"file":"getNormalizedListPagesArgs.js"}