"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _trimEnd = _interopRequireDefault(require("lodash/trimEnd"));

/**
 * Returns arguments suited to be sent to ElasticSearch's `search` method.
 */
var _default = (args, context) => {
  var _args$limit;

  const normalized = {
    query: getQuery(args, context),
    sort: getSort(args.sort),
    size: (_args$limit = args.limit) !== null && _args$limit !== void 0 ? _args$limit : 10,
    from: 0,
    page: args.page || 1
  };
  normalized.from = (normalized.page - 1) * normalized.size;
  return normalized;
};

exports.default = _default;

const getQuery = (args, context) => {
  const {
    where,
    search,
    exclude
  } = args;
  const query = {
    filter: [],
    must: [],
    must_not: [],
    should: []
  }; // When ES index is shared between tenants, we need to filter records by tenant ID

  const sharedIndex = process.env.ELASTICSEARCH_SHARED_INDEXES === "true";

  if (sharedIndex) {
    const tenant = context.tenancy.getCurrentTenant();
    query.filter.push({
      term: {
        "tenant.keyword": tenant.id
      }
    });
  }

  if (where) {
    if (where.category) {
      query.filter.push({
        term: {
          "category.keyword": where.category
        }
      });
    }

    if (where.status) {
      query.filter.push({
        term: {
          "status.keyword": where.status
        }
      });
    }

    const tags = where.tags;

    if (tags && Array.isArray(tags.query) && tags.query.length > 0) {
      if (tags.rule === "any") {
        query.filter.push({
          terms: {
            "tags.keyword": tags.query
          }
        });
      } else {
        query.filter.push({
          bool: {
            must: where.tags.query.map(tag => ({
              term: {
                "tags.keyword": tag
              }
            }))
          }
        });
      }
    }
  }

  if (search && search.query) {
    query.must.push({
      query_string: {
        query: `*${search.query}*`,
        allow_leading_wildcard: true,
        fields: ["title", "snippet"]
      }
    });
  } // Prepare query to exclude page which match provided id and/or path.


  if (Array.isArray(exclude) && exclude.length !== 0) {
    const paths = [];
    const pageIds = [];
    exclude.forEach(item => {
      // Page "path" will always starts with a slash.
      if (item.includes("/")) {
        // Let's also ensure the trailing slash is removed.
        paths.push((0, _trimEnd.default)(item, "/"));
      } else {
        pageIds.push(item);
      }
    });

    if (paths.length) {
      query.must_not.push({
        terms: {
          "path.keyword": paths
        }
      });
    }

    if (pageIds.length) {
      query.must_not.push({
        terms: {
          pid: pageIds
        }
      });
    }
  }

  return query;
};

const getSort = sort => {
  if (!sort) {
    return {};
  }

  const normalizedSort = {};

  if (sort.createdOn) {
    normalizedSort["createdOn"] = {
      order: sort.createdOn,
      unmapped_type: "date"
    };
  }

  if (sort.publishedOn) {
    normalizedSort["publishedOn"] = {
      order: sort.publishedOn,
      unmapped_type: "date"
    };
  }

  if (sort.title) {
    normalizedSort["titleLC.keyword"] = {
      order: sort.title,
      unmapped_type: "text"
    };
  }

  return normalizedSort;
};
//# sourceMappingURL=getNormalizedListPagesArgs.js.map