{"version":3,"sources":["../../../../../src/graphql/crud/install/utils/savePageAssets.ts"],"names":["FILES_COUNT_IN_EACH_BATCH","context","process","env","NODE_ENV","INSTALL_EXTRACT_DIR","pagesFilesData","path","join","fileIdToKeyMap","chunksProcesses","filesChunks","i","length","push","Promise","promise","reject","filesChunk","s3UploadProcess","j","currentFile","id","type","buffer","fs","readFileSync","__physicalFileName","fileManager","storage","upload","size","name","keyPrefix","hideInFileManager","Boolean","meta","private","e","console","log","key","fileUploadResults","all","forEach","item","index","stack"],"mappings":"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","sourcesContent":["import chunk from \"lodash/chunk\";\nimport loadJson from \"load-json-file\";\nimport fs from \"fs-extra\";\nimport path from \"path\";\nimport sleep from \"./sleep\";\nimport downloadInstallationFiles from \"./downloadInstallFiles\";\n\nconst FILES_COUNT_IN_EACH_BATCH = 15;\n\nexport default async ({ context }) => {\n    /**\n     * This function contains logic of file download from S3.\n     * Current we're not mocking zip file download from S3 in tests at the moment.\n     * So, we're manually mocking it in case of test just by returning an empty object.\n     */\n    if (process.env.NODE_ENV === \"test\") {\n        return {};\n    }\n\n    const INSTALL_EXTRACT_DIR = await downloadInstallationFiles();\n\n    const pagesFilesData = await loadJson<Record<string, any>[]>(\n        path.join(INSTALL_EXTRACT_DIR, \"data/pagesFilesData.json\")\n    );\n\n    try {\n        // Save uploaded file key against static id for later use.\n        const fileIdToKeyMap = {};\n        // Contains all parallel file saving chunks.\n        const chunksProcesses = [];\n\n        // Gives an array of chunks (each consists of FILES_COUNT_IN_EACH_BATCH items).\n        const filesChunks = chunk(pagesFilesData, FILES_COUNT_IN_EACH_BATCH);\n\n        for (let i = 0; i < filesChunks.length; i++) {\n            chunksProcesses.push(\n                // eslint-disable-next-line\n                new Promise(async (promise, reject) => {\n                    try {\n                        const filesChunk = filesChunks[i];\n\n                        // 2. Use received pre-signed POST payloads to upload files directly to S3.\n                        const s3UploadProcess = [];\n                        for (let j = 0; j < filesChunk.length; j++) {\n                            const currentFile = filesChunk[j];\n                            // Initialize the value\n                            fileIdToKeyMap[currentFile.id] = currentFile.type;\n                            try {\n                                const buffer = fs.readFileSync(\n                                    path.join(\n                                        INSTALL_EXTRACT_DIR,\n                                        \"images/\",\n                                        currentFile.__physicalFileName\n                                    )\n                                );\n\n                                s3UploadProcess.push(\n                                    // Upload file to file manager via S3\n                                    context.fileManager.storage.upload({\n                                        buffer,\n                                        size: buffer.length,\n                                        name: currentFile.name,\n                                        type: currentFile.type,\n                                        keyPrefix: \"welcome-to-webiny-page\",\n                                        hideInFileManager: Boolean(currentFile.meta.private)\n                                    })\n                                );\n                            } catch (e) {\n                                console.log(\"Error while uploading file: \", currentFile.name);\n                                console.log(e);\n                                /**\n                                 * In case of error he still had a fake key so that we get same number of results as files chunk.\n                                 */\n                                s3UploadProcess.push({ key: currentFile.key + \"/not-found\" });\n                            }\n                        }\n\n                        const fileUploadResults = await Promise.all(s3UploadProcess);\n                        // Save File key against static ID\n                        fileUploadResults.forEach((item, index) => {\n                            fileIdToKeyMap[filesChunk[index].id] = item.key;\n                        });\n\n                        // @ts-ignore\n                        promise(fileUploadResults);\n                    } catch (e) {\n                        reject(e);\n                    }\n                })\n            );\n\n            await sleep(750);\n        }\n\n        await Promise.all(chunksProcesses);\n        return fileIdToKeyMap;\n    } catch (e) {\n        return console.log(`[savePageAssets]: error occurred: ${e.stack}`);\n    }\n};\n"],"file":"savePageAssets.js"}