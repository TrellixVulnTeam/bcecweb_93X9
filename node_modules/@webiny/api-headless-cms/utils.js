"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.executeCallbacks = exports.filterAsync = exports.paginateBatch = exports.createCmsPK = exports.zeroPad = exports.toSlug = exports.validateGroupAccess = exports.validateModelAccess = exports.checkModelAccess = exports.validateOwnership = exports.checkOwnership = exports.checkPermissions = exports.hasPw = exports.hasRwd = void 0;

var _slugify = _interopRequireDefault(require("slugify"));

var _apiSecurity = require("@webiny/api-security");

const hasRwd = (permission, rwd) => {
  if (typeof permission.rwd !== "string") {
    return true;
  }

  return permission.rwd.includes(rwd);
};

exports.hasRwd = hasRwd;

const hasPw = (permission, pw) => {
  const isCustom = Object.keys(permission).length > 1; // "name" key is always present

  if (!isCustom) {
    // Means it's a "full-access" permission.
    return true;
  }

  if (typeof permission.pw !== "string") {
    return false;
  }

  return permission.pw.includes(pw);
};

exports.hasPw = hasPw;
const PW = {
  r: "request review",
  c: "request change",
  p: "publish",
  u: "unpublish"
};
const RWD = {
  r: "read",
  w: "write",
  d: "delete"
};

const checkPermissions = async (context, name, check) => {
  // Check if user is allowed to edit content in current language
  const contentPermission = await context.security.getPermission("content.i18n");

  if (!contentPermission) {
    throw new _apiSecurity.NotAuthorizedError({
      data: {
        reason: "Missing access to content in any locale."
      }
    });
  } // We need to check this manually as CMS locale comes from the URL and not the default i18n app.


  const code = context.cms.getLocale().code; // IMPORTANT: If we have a `contentPermission`, and `locales` key is NOT SET - it means the user has access to all locales.
  // However, if the the `locales` IS SET - check that it contains the required locale.

  if (Array.isArray(contentPermission.locales) && !contentPermission.locales.includes(code)) {
    throw new _apiSecurity.NotAuthorizedError({
      data: {
        reason: `Not allowed to access content in "${code}."`
      }
    });
  }

  const permission = await context.security.getPermission(name);

  if (!permission) {
    throw new _apiSecurity.NotAuthorizedError({
      data: {
        reason: `Missing permission "${name}".`
      }
    });
  }

  if (!check) {
    return permission;
  }

  if (check.rwd && !hasRwd(permission, check.rwd)) {
    throw new _apiSecurity.NotAuthorizedError({
      data: {
        reason: `Not allowed to perform "${RWD[check.rwd]}" on "${name}".`
      }
    });
  } // r = request review
  // c = request change
  // p = publish
  // u = unpublish


  if (check.pw && !hasPw(permission, check.pw)) {
    throw new _apiSecurity.NotAuthorizedError({
      data: {
        reason: `Not allowed to perform "${PW[check.pw]}" on "${name}".`
      }
    });
  }

  return permission;
};

exports.checkPermissions = checkPermissions;

const checkOwnership = (context, permission, record) => {
  if (!permission.own) {
    return;
  }

  const identity = context.security.getIdentity();
  const owner = identity && record["ownedBy"] && record["ownedBy"].id === identity.id;
  const creator = identity && record["createdBy"] && record["createdBy"].id === identity.id;

  if (!owner && !creator) {
    throw new _apiSecurity.NotAuthorizedError({
      data: {
        reason: `You are not the owner of the record.`
      }
    });
  }
};

exports.checkOwnership = checkOwnership;

const validateOwnership = (context, permission, record) => {
  try {
    checkOwnership(context, permission, record);
    return true;
  } catch {
    return false;
  }
};
/**
 * model access is checking for both specific model or group access
 * if permission has specific models set as access pattern then groups will not matter (although both can be set)
 */


exports.validateOwnership = validateOwnership;

const checkModelAccess = async (context, model) => {
  if (await validateModelAccess(context, model)) {
    return;
  }

  throw new _apiSecurity.NotAuthorizedError({
    data: {
      reason: `Not allowed to access model "${model.modelId}".`
    }
  });
};

exports.checkModelAccess = checkModelAccess;

const validateModelAccess = async (context, model) => {
  const modelGroupPermission = await checkPermissions(context, "cms.contentModelGroup", {
    rwd: "r"
  });
  const {
    groups
  } = modelGroupPermission;
  const modelPermission = await checkPermissions(context, "cms.contentModel", {
    rwd: "r"
  });
  const {
    models
  } = modelPermission; // when no models or groups defined on permission
  // it means user has access to everything

  if (!models && !groups) {
    return true;
  }

  const locale = context.cms.getLocale().code; // Check whether the model is question belongs to "content model groups" for which user has permission.

  if (groups) {
    if (Array.isArray(groups[locale]) === false || groups[locale].includes(model.group.id) === false) {
      return false;
    }
  } // Check whether the model is question belongs to "content models" for which user has permission.


  if (models) {
    if (Array.isArray(models[locale]) === false || models[locale].includes(model.modelId) === false) {
      return false;
    }
  }

  return true;
};

exports.validateModelAccess = validateModelAccess;

const validateGroupAccess = (context, permission, group) => {
  const {
    groups
  } = permission; // when no groups defined on permission
  // it means user has access to everything

  if (!groups) {
    return true;
  }

  const locale = context.cms.getLocale().code; // when there is no locale in groups, it means that no access was given
  // this happens when access control was set but no models or groups were added

  if (Array.isArray(groups[locale]) === false || groups[locale].includes(group.id) === false) {
    return false;
  }

  return true;
};

exports.validateGroupAccess = validateGroupAccess;

const toSlug = text => {
  return (0, _slugify.default)(text, {
    replacement: "-",
    lower: true,
    remove: /[*#\?<>_\{\}\[\]+~.()'"!:;@]/g
  });
};

exports.toSlug = toSlug;

const zeroPad = version => `${version}`.padStart(4, "0");

exports.zeroPad = zeroPad;

const createCmsPK = context => {
  const {
    tenancy,
    cms
  } = context;
  const tenant = tenancy.getCurrentTenant();

  if (!tenant) {
    throw new Error("Tenant missing.");
  }

  const locale = cms.getLocale();

  if (!locale) {
    throw new Error("Locale missing.");
  }

  return `T#${tenant.id}#L#${locale.code}#CMS`;
};

exports.createCmsPK = createCmsPK;

const paginateBatch = async (items, perPage, execute) => {
  const pages = Math.ceil(items.length / perPage);

  for (let i = 0; i < pages; i++) {
    await execute(items.slice(i * perPage, i * perPage + perPage));
  }
};

exports.paginateBatch = paginateBatch;

const filterAsync = async (items, predicate) => {
  const filteredItems = [];

  for (let i = 0; i < items.length; i++) {
    const item = items[i];
    const valid = await predicate(item);

    if (valid) {
      filteredItems.push(item);
    }
  }

  return filteredItems;
};

exports.filterAsync = filterAsync;

const executeCallbacks = async (plugins, hook, args) => {
  for (const plugin of plugins) {
    if (typeof plugin[hook] === "function") {
      await plugin[hook](args);
    }
  }
};

exports.executeCallbacks = executeCallbacks;
//# sourceMappingURL=utils.js.map