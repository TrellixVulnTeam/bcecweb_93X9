{"version":3,"sources":["../../../../src/content/plugins/schema/createFieldResolvers.ts"],"names":["createFieldResolversFactory","endpointType","models","model","fieldTypePlugins","createFieldResolvers","params","graphQLType","fields","isRoot","extraResolvers","fieldResolvers","typeResolvers","field","type","createResolver","resolver","fieldResolver","Object","assign","fieldId","parent","args","context","info","transformedValue","value","values","err","a"],"mappings":";;;;;;;;;;;AAAA;;AACA;;AAEA;;;;;;AAUA;AACA;AACA;AACA;AACO,SAASA,2BAAT,CAAqC;AAAEC,EAAAA,YAAF;AAAgBC,EAAAA,MAAhB;AAAwBC,EAAAA,KAAxB;AAA+BC,EAAAA;AAA/B,CAArC,EAAwF;AAC3F,SAAO,SAASC,oBAAT,CAA8BC,MAA9B,EAA4D;AAC/D,UAAM;AAAEC,MAAAA,WAAF;AAAeC,MAAAA,MAAf;AAAuBC,MAAAA,MAAM,GAAG,KAAhC;AAAuCC,MAAAA,cAAc,GAAG;AAAxD,QAA+DJ,MAArE;;AAEA,UAAMK,cAAc,qBAAQD,cAAR,CAApB;;AACA,UAAME,aAAa,GAAG,EAAtB;;AAEA,SAAK,MAAMC,KAAX,IAAoBL,MAApB,EAA4B;AACxB,UAAI,CAACJ,gBAAgB,CAACS,KAAK,CAACC,IAAP,CAArB,EAAmC;AAC/B;AACH;;AAED,YAAMC,cAAoD,GAAG,kBACzDX,gBADyD,EAExD,GAAES,KAAK,CAACC,IAAK,IAAGb,YAAa,iBAF2B,CAA7D;AAKA,UAAIe,QAAJ;AACA,YAAMC,aAAa,GAAGF,cAAc,GAC9BA,cAAc,CAAC;AAAER,QAAAA,WAAF;AAAeL,QAAAA,MAAf;AAAuBC,QAAAA,KAAvB;AAA8BU,QAAAA,KAA9B;AAAqCR,QAAAA;AAArC,OAAD,CADgB,GAE9B,IAFN;;AAIA,UAAI,OAAOY,aAAP,KAAyB,UAA7B,EAAyC;AACrCD,QAAAA,QAAQ,GAAGC,aAAX;AACH,OAFD,MAEO,IAAIA,aAAa,KAAK,IAAtB,EAA4B;AAC/BD,QAAAA,QAAQ,GAAGC,aAAa,CAACD,QAAzB;AACAE,QAAAA,MAAM,CAACC,MAAP,CAAcP,aAAd,EAA6BK,aAAa,CAACL,aAA3C;AACH;;AAED,YAAM;AAAEQ,QAAAA;AAAF,UAAcP,KAApB;;AAEAF,MAAAA,cAAc,CAACS,OAAD,CAAd,GAA0B,OAAOC,MAAP,EAAeC,IAAf,EAAqBC,OAArB,EAA0CC,IAA1C,KAAmD;AACzE,YAAI;AACA;AACA,gBAAMC,gBAAgB,GAAG,MAAM,kDAA+B;AAC1DF,YAAAA,OAD0D;AAE1DpB,YAAAA,KAF0D;AAG1DU,YAAAA,KAH0D;AAI1Da,YAAAA,KAAK,EAAEjB,MAAM,GAAGY,MAAM,CAACM,MAAP,CAAcP,OAAd,CAAH,GAA4BC,MAAM,CAACD,OAAD;AAJW,WAA/B,CAA/B;AAOA,4BAAIX,MAAM,GAAGY,MAAM,CAACM,MAAV,GAAmBN,MAA7B,EAAqCD,OAArC,EAA8CK,gBAA9C;;AAEA,cAAI,CAACT,QAAL,EAAe;AACX,mBAAOP,MAAM,GAAGY,MAAM,CAACM,MAAP,CAAcP,OAAd,CAAH,GAA4BC,MAAM,CAACD,OAAD,CAA/C;AACH;;AAED,iBAAO,MAAMJ,QAAQ,CAACP,MAAM,GAAGY,MAAM,CAACM,MAAV,GAAmBN,MAA1B,EAAkCC,IAAlC,EAAwCC,OAAxC,EAAiDC,IAAjD,CAArB;AACH,SAhBD,CAgBE,OAAOI,GAAP,EAAY;AACV;AACA,gBAAMC,CAAC,GAAGD,GAAV;AACH;AACJ,OArBD;AAsBH;;AAED;AAAS,OAACrB,WAAD,GAAeI;AAAxB,OAA2CC,aAA3C;AACH,GAvDD;AAwDH","sourcesContent":["import get from \"lodash/get\";\nimport set from \"lodash/set\";\nimport { CmsContentModelField, CmsContext, CmsModelFieldToGraphQLCreateResolver } from \"~/types\";\nimport { entryFieldFromStorageTransform } from \"~/content/plugins/utils/entryStorage\";\nimport { Resolvers } from \"@webiny/handler-graphql/types\";\n\ninterface CreateFieldResolvers {\n    graphQLType: string;\n    fields: CmsContentModelField[];\n    isRoot: boolean;\n    extraResolvers?: Resolvers<any>;\n}\n\n/**\n * We use a factory to avoid passing the parameters for recursive invocations.\n * This way they will always be in the function scope and we can only pass \"fields\".\n */\nexport function createFieldResolversFactory({ endpointType, models, model, fieldTypePlugins }) {\n    return function createFieldResolvers(params: CreateFieldResolvers) {\n        const { graphQLType, fields, isRoot = false, extraResolvers = {} } = params;\n\n        const fieldResolvers = { ...extraResolvers };\n        const typeResolvers = {};\n\n        for (const field of fields) {\n            if (!fieldTypePlugins[field.type]) {\n                continue;\n            }\n\n            const createResolver: CmsModelFieldToGraphQLCreateResolver = get(\n                fieldTypePlugins,\n                `${field.type}.${endpointType}.createResolver`\n            );\n\n            let resolver;\n            const fieldResolver = createResolver\n                ? createResolver({ graphQLType, models, model, field, createFieldResolvers })\n                : null;\n\n            if (typeof fieldResolver === \"function\") {\n                resolver = fieldResolver;\n            } else if (fieldResolver !== null) {\n                resolver = fieldResolver.resolver;\n                Object.assign(typeResolvers, fieldResolver.typeResolvers);\n            }\n\n            const { fieldId } = field;\n\n            fieldResolvers[fieldId] = async (parent, args, context: CmsContext, info) => {\n                try {\n                    // Get transformed value (eg. data decompression)\n                    const transformedValue = await entryFieldFromStorageTransform({\n                        context,\n                        model,\n                        field,\n                        value: isRoot ? parent.values[fieldId] : parent[fieldId]\n                    });\n\n                    set(isRoot ? parent.values : parent, fieldId, transformedValue);\n\n                    if (!resolver) {\n                        return isRoot ? parent.values[fieldId] : parent[fieldId];\n                    }\n\n                    return await resolver(isRoot ? parent.values : parent, args, context, info);\n                } catch (err) {\n                    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n                    const a = err;\n                }\n            };\n        }\n\n        return { [graphQLType]: fieldResolvers, ...typeResolvers };\n    };\n}\n"],"file":"createFieldResolvers.js"}