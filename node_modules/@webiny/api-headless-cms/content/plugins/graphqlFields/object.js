"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _upperFirst = _interopRequireDefault(require("lodash/upperFirst"));

var _renderFields = require("../utils/renderFields");

var _renderInputFields = require("../utils/renderInputFields");

var _createTypeName = require("../utils/createTypeName");

const typeFromField = ({
  typeOfType,
  model,
  type,
  field,
  fieldTypePlugins
}) => {
  const typeSuffix = typeOfType === "input" ? "Input" : "";
  const typeName = (0, _createTypeName.createTypeName)(model.modelId);
  const mTypeName = (0, _createTypeName.createManageTypeName)(typeName); // `field` is an "object" field

  const fields = field.settings.fields;
  const fieldTypeName = `${mTypeName}_${(0, _upperFirst.default)(field.fieldId)}`;
  const typeFields = [];
  const nestedTypes = []; // Once the loop below starts, we'll be executing a recursive "object" type generation.
  // The main trick here is that nested objects don't know who the parent is, and will generate
  // type names using the "model", as if they're at the top level:
  // Every time the types are returned, we need to replace the model name in the generated type name
  // with the actual prefix which includes parent field name type.

  const replace = new RegExp(`${mTypeName}_`, "g");

  for (const f of fields) {
    const {
      fields,
      typeDefs
    } = typeOfType === "type" ? (0, _renderFields.renderField)({
      field: f,
      type,
      model,
      fieldTypePlugins
    }) : (0, _renderInputFields.renderInputField)({
      field: f,
      model,
      fieldTypePlugins
    });
    typeFields.push(fields.replace(replace, `${fieldTypeName}_`));

    if (typeDefs) {
      nestedTypes.push(typeDefs.replace(replace, `${fieldTypeName}_`));
    }
  }

  return {
    fieldType: `${fieldTypeName}${typeSuffix}`,
    typeDefs:
    /* GraphQL */
    `
            ${nestedTypes.join("\n")}
                    
            ${typeOfType} ${fieldTypeName}${typeSuffix} {
                ${typeFields.join("\n")}
            }
        `
  };
};

const plugin = {
  name: "cms-model-field-to-graphql-object",
  type: "cms-model-field-to-graphql",
  fieldType: "object",
  isSortable: false,
  isSearchable: false,
  read: {
    createTypeField({
      field,
      model,
      fieldTypePlugins
    }) {
      const {
        fieldType,
        typeDefs
      } = typeFromField({
        typeOfType: "type",
        model,
        type: "read",
        field,
        fieldTypePlugins
      });
      return {
        fields: `${field.fieldId}: ${field.multipleValues ? `[${fieldType}!]` : fieldType}`,
        typeDefs
      };
    },

    createResolver({
      field,
      createFieldResolvers,
      graphQLType
    }) {
      const fieldType = `${graphQLType}_${(0, _upperFirst.default)(field.fieldId)}`;
      return {
        resolver: null,
        typeResolvers: createFieldResolvers({
          graphQLType: fieldType,
          fields: field.settings.fields
        })
      };
    }

  },
  manage: {
    createTypeField({
      model,
      field,
      fieldTypePlugins
    }) {
      const {
        fieldType,
        typeDefs
      } = typeFromField({
        typeOfType: "type",
        model,
        type: "manage",
        field,
        fieldTypePlugins
      });
      return {
        fields: `${field.fieldId}: ${field.multipleValues ? `[${fieldType}!]` : fieldType}`,
        typeDefs
      };
    },

    createInputField({
      model,
      field,
      fieldTypePlugins
    }) {
      const {
        fieldType,
        typeDefs
      } = typeFromField({
        typeOfType: "input",
        model,
        type: "manage",
        field,
        fieldTypePlugins
      });
      return {
        fields: `${field.fieldId}: ${field.multipleValues ? `[${fieldType}!]` : fieldType}`,
        typeDefs
      };
    },

    createResolver({
      graphQLType,
      field,
      createFieldResolvers
    }) {
      const fieldType = `${graphQLType}_${(0, _upperFirst.default)(field.fieldId)}`;
      return {
        resolver: null,
        typeResolvers: createFieldResolvers({
          graphQLType: fieldType,
          fields: field.settings.fields
        })
      };
    }

  }
};
var _default = plugin;
exports.default = _default;
//# sourceMappingURL=object.js.map