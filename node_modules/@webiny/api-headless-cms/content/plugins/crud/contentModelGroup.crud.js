"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _fields = require("@commodo/fields");

var _validation = require("@webiny/validation");

var _mdbid = _interopRequireDefault(require("mdbid"));

var utils = _interopRequireWildcard(require("../../../utils"));

var _beforeDelete = require("./contentModelGroup/beforeDelete.hook");

var _beforeCreate = require("./contentModelGroup/beforeCreate.hook");

var _afterDelete = require("./contentModelGroup/afterDelete.hook");

var _handlerGraphql = require("@webiny/handler-graphql");

var _error = _interopRequireDefault(require("@webiny/error"));

var _afterUpdate = require("./contentModelGroup/afterUpdate.hook");

var _beforeUpdate = require("./contentModelGroup/beforeUpdate.hook");

var _afterCreate = require("./contentModelGroup/afterCreate.hook");

var _ContentModelGroupPlugin = require("../ContentModelGroupPlugin");

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

const CreateContentModelGroupModel = (0, _fields.withFields)({
  name: (0, _fields.string)({
    validation: _validation.validation.create("required,maxLength:100")
  }),
  slug: (0, _fields.string)({
    validation: _validation.validation.create("maxLength:100")
  }),
  description: (0, _fields.string)({
    validation: _validation.validation.create("maxLength:255")
  }),
  icon: (0, _fields.string)({
    validation: _validation.validation.create("required,maxLength:255")
  })
})();
const UpdateContentModelGroupModel = (0, _fields.withFields)({
  name: (0, _fields.string)({
    validation: _validation.validation.create("maxLength:100")
  }),
  description: (0, _fields.string)({
    validation: _validation.validation.create("maxLength:255")
  }),
  icon: (0, _fields.string)({
    validation: _validation.validation.create("maxLength:255")
  })
})();

var _default = () => ({
  type: "context",

  async apply(context) {
    /**
     * If cms is not defined on the context, do not continue, but log it.
     */
    if (!context.cms) {
      return;
    }

    const pluginType = "cms-content-model-group-storage-operations-provider";
    const providerPlugins = context.plugins.byType(pluginType);
    /**
     * Storage operations operations for the content model group.
     * Contains logic to save the data into the specific storage.
     */

    const providerPlugin = providerPlugins[providerPlugins.length - 1];

    if (!providerPlugin) {
      throw new _error.default(`Missing "${pluginType}" plugin.`, "PLUGIN_NOT_FOUND", {
        type: pluginType
      });
    }

    const storageOperations = await providerPlugin.provide({
      context
    });

    const checkPermissions = check => {
      return utils.checkPermissions(context, "cms.contentModelGroup", {
        rwd: check
      });
    };

    const groupsGet = async id => {
      const groupPlugin = context.plugins.byType(_ContentModelGroupPlugin.ContentModelGroupPlugin.type).find(item => item.contentModelGroup.id === id);

      if (groupPlugin) {
        return groupPlugin.contentModelGroup;
      }

      let group = null;

      try {
        group = await storageOperations.get({
          id
        });
      } catch (ex) {
        throw new _error.default(ex.message, ex.code || "GET_ERROR", _objectSpread(_objectSpread({}, ex.data || {}), {}, {
          id
        }));
      }

      if (!group) {
        throw new _handlerGraphql.NotFoundError(`Content model group "${id}" was not found!`);
      }

      return group;
    };

    const groupsList = async args => {
      const {
        where,
        limit
      } = args || {};

      try {
        const pluginsGroups = context.plugins.byType(_ContentModelGroupPlugin.ContentModelGroupPlugin.type).map(plugin => plugin.contentModelGroup);
        const databaseGroups = await storageOperations.list({
          where,
          limit
        });
        return [...databaseGroups, ...pluginsGroups];
      } catch (ex) {
        throw new _error.default(ex.message, ex.code || "LIST_ERROR", _objectSpread(_objectSpread({}, ex.data || {}), {}, {
          where,
          limit
        }));
      }
    };

    const groups = {
      operations: storageOperations,
      noAuth: () => {
        return {
          get: groupsGet,
          list: groupsList
        };
      },
      get: async id => {
        const permission = await checkPermissions("r");
        const group = await groupsGet(id);
        utils.checkOwnership(context, permission, group);
        utils.validateGroupAccess(context, permission, group);
        return group;
      },
      list: async args => {
        const permission = await checkPermissions("r");
        const response = await groupsList(args);
        return response.filter(group => {
          if (!utils.validateOwnership(context, permission, group)) {
            return false;
          }

          return utils.validateGroupAccess(context, permission, group);
        });
      },
      create: async inputData => {
        await checkPermissions("w");
        const createdData = new CreateContentModelGroupModel().populate(_objectSpread(_objectSpread({}, inputData), {}, {
          slug: inputData.slug ? utils.toSlug(inputData.slug) : ""
        }));
        await createdData.validate();
        const input = await createdData.toJSON();
        const identity = context.security.getIdentity();
        const id = (0, _mdbid.default)();

        const data = _objectSpread(_objectSpread({}, input), {}, {
          id,
          locale: context.cms.getLocale().code,
          createdOn: new Date().toISOString(),
          savedOn: new Date().toISOString(),
          createdBy: {
            id: identity.id,
            displayName: identity.displayName,
            type: identity.type
          }
        });

        try {
          await (0, _beforeCreate.beforeCreateHook)({
            context,
            storageOperations,
            input,
            data
          });
          const group = await storageOperations.create({
            input,
            data
          });
          await (0, _afterCreate.afterCreateHook)({
            context,
            storageOperations,
            input,
            group
          });
          return group;
        } catch (ex) {
          throw new _error.default(ex.message || "Could not save data model group.", ex.code || "ERROR_ON_CREATE", _objectSpread(_objectSpread({}, ex.data || {}), {}, {
            data,
            input
          }));
        }
      },
      update: async (id, inputData) => {
        const permission = await checkPermissions("w");
        const group = await groupsGet(id);
        utils.checkOwnership(context, permission, group);
        const input = new UpdateContentModelGroupModel().populate(inputData);
        await input.validate();
        const updatedDataJson = await input.toJSON({
          onlyDirty: true
        }); // no need to continue if no values were changed

        if (Object.keys(updatedDataJson).length === 0) {
          return group;
        }

        const data = Object.assign(updatedDataJson, {
          savedOn: new Date().toISOString()
        });

        try {
          await (0, _beforeUpdate.beforeUpdateHook)({
            context,
            storageOperations,
            group,
            input,
            data
          });
          const updatedGroup = await storageOperations.update({
            group,
            data,
            input
          });
          await (0, _afterUpdate.afterUpdateHook)({
            context,
            storageOperations,
            group: updatedGroup,
            data,
            input
          });
          return updatedGroup;
        } catch (ex) {
          throw new _error.default(ex.message, ex.code || "UPDATE_ERROR", _objectSpread(_objectSpread({}, ex.data || {}), {}, {
            group,
            data,
            input
          }));
        }
      },
      delete: async id => {
        const permission = await checkPermissions("d");
        const group = await groupsGet(id);
        utils.checkOwnership(context, permission, group);

        try {
          await (0, _beforeDelete.beforeDeleteHook)({
            context,
            storageOperations,
            group
          });
          await storageOperations.delete({
            group
          });
          await (0, _afterDelete.afterDeleteHook)({
            context,
            storageOperations,
            group
          });
        } catch (ex) {
          throw new _error.default(ex.message, ex.code || "DELETE_ERROR", _objectSpread(_objectSpread({}, ex.data || {}), {}, {
            id
          }));
        }

        return true;
      }
    };
    context.cms = _objectSpread(_objectSpread({}, context.cms || {}), {}, {
      groups
    });
  }

});

exports.default = _default;
//# sourceMappingURL=contentModelGroup.crud.js.map