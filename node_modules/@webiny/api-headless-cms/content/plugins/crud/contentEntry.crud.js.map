{"version":3,"sources":["../../../../src/content/plugins/crud/contentEntry.crud.ts"],"names":["STATUS_DRAFT","STATUS_PUBLISHED","STATUS_UNPUBLISHED","STATUS_CHANGES_REQUESTED","STATUS_REVIEW_REQUESTED","cleanInputData","model","inputData","fields","reduce","acc","field","fieldId","cleanUpdatedInputData","input","undefined","createEntryId","version","entryId","id","utils","zeroPad","increaseEntryIdVersion","includes","WebinyError","split","ver","parseInt","type","name","apply","context","cms","pluginType","providerPlugins","plugins","byType","providerPlugin","length","storageOperations","provide","checkEntryPermissions","check","checkPermissions","deleteEntry","params","entry","storageEntry","delete","ex","message","code","getEntriesByIds","ids","permission","rwd","checkModelAccess","entries","getByIds","filter","validateOwnership","operations","getById","NotFoundError","getPublishedByIds","getLatestByIds","getEntryRevisions","getRevisions","get","args","items","list","limit","where","ownedBy","own","security","getIdentity","listWhere","hasMoreItems","totalCount","cursor","meta","listLatest","sort","latest","listPublished","published","create","identity","locale","getLocale","owner","displayName","webinyVersion","WEBINY_VERSION","tenant","tenancy","getCurrentTenant","modelId","createdOn","Date","toISOString","savedOn","createdBy","locked","status","values","result","data","error","createRevisionFrom","sourceId","uniqueId","originalStorageEntry","getRevisionById","latestStorageEntry","getLatestRevisionByEntryId","originalEntry","checkOwnership","latestEntry","latestId","nextVersion","publishedOn","update","deleteRevision","revisionId","storageEntryToDelete","previousStorageEntry","getPreviousRevision","latestEntryRevisionId","entryToDelete","entryToSetAsLatest","storageEntryToSetAsLatest","publish","pw","currentDate","requestChanges","requestReview","latestEntryRevision","allowedStatuses","unpublish","getPublishedRevisionByEntryId"],"mappings":"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","sourcesContent":["import mdbid from \"mdbid\";\nimport { ContextPlugin } from \"@webiny/handler/types\";\nimport { NotFoundError } from \"@webiny/handler-graphql\";\nimport {\n    CmsContentEntryContext,\n    CmsContentEntryPermission,\n    CmsContentEntry,\n    CmsContentModel,\n    CmsContext,\n    CmsContentEntryStorageOperationsProvider,\n    CmsStorageContentEntry\n} from \"~/types\";\nimport * as utils from \"~/utils\";\nimport { validateModelEntryData } from \"./contentEntry/entryDataValidation\";\nimport {\n    afterCreateHook,\n    afterDeleteHook,\n    afterDeleteRevisionHook,\n    afterPublishHook,\n    afterRequestChangesHook,\n    afterRequestReviewHook,\n    afterUpdateHook,\n    afterUnpublishHook,\n    beforeCreateHook,\n    beforeDeleteHook,\n    beforeDeleteRevisionHook,\n    beforePublishHook,\n    beforeRequestChangesHook,\n    beforeRequestReviewHook,\n    beforeUpdateHook,\n    beforeUnpublishHook,\n    beforeCreateRevisionFromHook,\n    afterCreateRevisionFromHook\n} from \"./contentEntry/hooks\";\nimport WebinyError from \"@webiny/error\";\nimport { entryFromStorageTransform, entryToStorageTransform } from \"../utils/entryStorage\";\n\nexport const STATUS_DRAFT = \"draft\";\nexport const STATUS_PUBLISHED = \"published\";\nexport const STATUS_UNPUBLISHED = \"unpublished\";\nexport const STATUS_CHANGES_REQUESTED = \"changesRequested\";\nexport const STATUS_REVIEW_REQUESTED = \"reviewRequested\";\n\nconst cleanInputData = (\n    model: CmsContentModel,\n    inputData: Record<string, any>\n): Record<string, any> => {\n    return model.fields.reduce((acc, field) => {\n        acc[field.fieldId] = inputData[field.fieldId];\n        return acc;\n    }, {});\n};\n\nconst cleanUpdatedInputData = (\n    model: CmsContentModel,\n    input: Record<string, any>\n): Record<string, any> => {\n    return model.fields.reduce((acc, field) => {\n        if (input[field.fieldId] === undefined) {\n            return acc;\n        }\n        acc[field.fieldId] = input[field.fieldId];\n        return acc;\n    }, {});\n};\n\ninterface DeleteEntryParams {\n    model: CmsContentModel;\n    entry: CmsContentEntry;\n    storageEntry: CmsStorageContentEntry;\n}\n\ninterface EntryIdResult {\n    /**\n     * A generated id that will connect all the entry records.\n     */\n    entryId: string;\n    /**\n     * Version of the entry.\n     */\n    version: number;\n    /**\n     * Combination of entryId and version.\n     */\n    id: string;\n}\n\nconst createEntryId = (version: number): EntryIdResult => {\n    const entryId = mdbid();\n    return {\n        entryId,\n        version,\n        id: `${entryId}#${utils.zeroPad(version)}`\n    };\n};\n\nconst increaseEntryIdVersion = (id: string): EntryIdResult => {\n    if (id.includes(\"#\") === false) {\n        throw new WebinyError(\n            \"Cannot increase version on the ID without the version part.\",\n            \"WRONG_ID\",\n            {\n                id\n            }\n        );\n    }\n    const [entryId, version] = id.split(\"#\");\n    const ver = parseInt(version) + 1;\n    return {\n        entryId,\n        version: ver,\n        id: `${entryId}#${utils.zeroPad(ver)}`\n    };\n};\n\nexport default (): ContextPlugin<CmsContext> => ({\n    type: \"context\",\n    name: \"context-content-model-entry\",\n    async apply(context) {\n        /**\n         * If cms is not defined on the context, do not continue, but log it.\n         */\n        if (!context.cms) {\n            return;\n        }\n\n        const pluginType = \"cms-content-entry-storage-operations-provider\";\n        const providerPlugins =\n            context.plugins.byType<CmsContentEntryStorageOperationsProvider>(pluginType);\n        /**\n         * Storage operations for the content entry.\n         * Contains logic to save the data into the specific storage.\n         */\n        const providerPlugin = providerPlugins[providerPlugins.length - 1];\n        if (!providerPlugin) {\n            throw new WebinyError(`Missing \"${pluginType}\" plugin.`, \"PLUGIN_NOT_FOUND\", {\n                type: pluginType\n            });\n        }\n\n        const storageOperations = await providerPlugin.provide({\n            context\n        });\n\n        const checkEntryPermissions = (check: {\n            rwd?: string;\n            pw?: string;\n        }): Promise<CmsContentEntryPermission> => {\n            return utils.checkPermissions(context, \"cms.contentEntry\", check);\n        };\n\n        /**\n         * A helper to delete the entire entry.\n         */\n        const deleteEntry = async (params: DeleteEntryParams): Promise<void> => {\n            const { model, entry, storageEntry } = params;\n            try {\n                await beforeDeleteHook({\n                    context,\n                    model,\n                    entry,\n                    storageEntry,\n                    storageOperations\n                });\n                await storageOperations.delete(model, {\n                    entry,\n                    storageEntry\n                });\n                await afterDeleteHook({\n                    context,\n                    model,\n                    entry,\n                    storageEntry,\n                    storageOperations\n                });\n            } catch (ex) {\n                throw new WebinyError(\n                    ex.message || \"Could not delete entry.\",\n                    ex.code || \"DELETE_ERROR\",\n                    {\n                        entry\n                    }\n                );\n            }\n        };\n        /**\n         * A helper to get entries by revision IDs\n         */\n        const getEntriesByIds = async (model: CmsContentModel, ids: string[]) => {\n            const permission = await checkEntryPermissions({ rwd: \"r\" });\n            await utils.checkModelAccess(context, model);\n\n            const entries = await storageOperations.getByIds(model, ids);\n\n            return entries.filter(entry => utils.validateOwnership(context, permission, entry));\n        };\n\n        const entries: CmsContentEntryContext = {\n            operations: storageOperations,\n            /**\n             * Get entries by exact revision IDs from the database.\n             */\n            getByIds: getEntriesByIds,\n            /**\n             * Get a single entry by revision ID from the database.\n             */\n            getById: async (model, id) => {\n                const [entry] = await getEntriesByIds(model, [id]);\n                if (!entry) {\n                    throw new NotFoundError(`Entry by ID \"${id}\" not found.`);\n                }\n                return entry;\n            },\n            /**\n             * Get latest published revisions by entry IDs.\n             */\n            getPublishedByIds: async (model: CmsContentModel, ids: string[]) => {\n                const permission = await checkEntryPermissions({ rwd: \"r\" });\n                await utils.checkModelAccess(context, model);\n\n                const entries = await storageOperations.getPublishedByIds(model, ids);\n\n                return entries.filter(entry => utils.validateOwnership(context, permission, entry));\n            },\n            /**\n             * Get latest revisions by entry IDs.\n             */\n            getLatestByIds: async (model: CmsContentModel, ids: string[]) => {\n                const permission = await checkEntryPermissions({ rwd: \"r\" });\n                await utils.checkModelAccess(context, model);\n\n                const entries = await storageOperations.getLatestByIds(model, ids);\n\n                return entries.filter(entry => utils.validateOwnership(context, permission, entry));\n            },\n\n            getEntryRevisions: async (model, entryId) => {\n                return storageOperations.getRevisions(model, entryId);\n            },\n            get: async (model, args) => {\n                await checkEntryPermissions({ rwd: \"r\" });\n\n                const [items] = await context.cms.entries.list(model, {\n                    ...args,\n                    limit: 1\n                });\n\n                if (items.length === 0) {\n                    throw new NotFoundError(`Entry not found!`);\n                }\n                return items[0];\n            },\n            list: async (model: CmsContentModel, args) => {\n                const permission = await checkEntryPermissions({ rwd: \"r\" });\n                await utils.checkModelAccess(context, model);\n\n                const { where = {} } = args || {};\n                /**\n                 * Possibly only get records which are owned by current user.\n                 * Or if searching for the owner set that value - in the case that user can see other entries than their own.\n                 */\n                const ownedBy = permission.own ? context.security.getIdentity().id : where.ownedBy;\n                const listWhere = {\n                    ...where\n                };\n                if (ownedBy !== undefined) {\n                    listWhere.ownedBy = ownedBy;\n                }\n\n                const { hasMoreItems, totalCount, cursor, items } = await storageOperations.list(\n                    model,\n                    {\n                        ...args,\n                        where: listWhere\n                    }\n                );\n\n                const meta = {\n                    hasMoreItems,\n                    totalCount,\n                    /**\n                     * Cursor should be null if there are no more items to load.\n                     * Just make sure of that, disregarding what is returned from the storageOperations.list method.\n                     */\n                    cursor: hasMoreItems ? cursor : null\n                };\n\n                return [items, meta];\n            },\n            listLatest: async function (model, args = {}) {\n                return context.cms.entries.list(model, {\n                    sort: [\"createdOn_DESC\"],\n                    ...args,\n                    where: {\n                        ...(args.where || {}),\n                        latest: true\n                    }\n                });\n            },\n            listPublished: async function (model, args = {}) {\n                return context.cms.entries.list(model, {\n                    sort: [\"createdOn_DESC\"],\n                    ...args,\n                    where: {\n                        ...(args.where || {}),\n                        published: true\n                    }\n                });\n            },\n            create: async (model, inputData) => {\n                await checkEntryPermissions({ rwd: \"w\" });\n                await utils.checkModelAccess(context, model);\n\n                /**\n                 * Make sure we only work with fields that are defined in the model.\n                 */\n                const input = cleanInputData(model, inputData);\n\n                await validateModelEntryData(context, model, input);\n\n                const identity = context.security.getIdentity();\n                const locale = context.cms.getLocale();\n\n                const owner = {\n                    id: identity.id,\n                    displayName: identity.displayName,\n                    type: identity.type\n                };\n\n                const { id, entryId, version } = createEntryId(1);\n\n                const entry: CmsContentEntry = {\n                    webinyVersion: context.WEBINY_VERSION,\n                    tenant: context.tenancy.getCurrentTenant().id,\n                    entryId,\n                    id,\n                    modelId: model.modelId,\n                    locale: locale.code,\n                    createdOn: new Date().toISOString(),\n                    savedOn: new Date().toISOString(),\n                    createdBy: owner,\n                    ownedBy: owner,\n                    version,\n                    locked: false,\n                    status: STATUS_DRAFT,\n                    values: input\n                };\n\n                let storageEntry: CmsStorageContentEntry = null;\n                try {\n                    await beforeCreateHook({ model, input, entry, context, storageOperations });\n                    storageEntry = await entryToStorageTransform(context, model, entry);\n                    const result = await storageOperations.create(model, {\n                        input,\n                        entry,\n                        storageEntry\n                    });\n                    await afterCreateHook({\n                        model,\n                        input,\n                        entry,\n                        /**\n                         * Pass the result because storage operations might have changed something (saved date, etc...)\n                         */\n                        storageEntry: result,\n                        context,\n                        storageOperations\n                    });\n                    return result;\n                } catch (ex) {\n                    throw new WebinyError(\n                        ex.message || \"Could not create content entry.\",\n                        ex.code || \"CREATE_ENTRY_ERROR\",\n                        ex.data || {\n                            error: ex,\n                            input,\n                            entry,\n                            storageEntry\n                        }\n                    );\n                }\n            },\n            createRevisionFrom: async (model, sourceId, inputData = {}) => {\n                const permission = await checkEntryPermissions({ rwd: \"w\" });\n                await utils.checkModelAccess(context, model);\n\n                /**\n                 * Make sure we only work with fields that are defined in the model.\n                 */\n                const input = cleanUpdatedInputData(model, inputData);\n\n                /**\n                 * Entries are identified by a common parent ID + Revision number.\n                 */\n                const [uniqueId] = sourceId.split(\"#\");\n\n                const originalStorageEntry = await storageOperations.getRevisionById(\n                    model,\n                    sourceId\n                );\n                const latestStorageEntry = await storageOperations.getLatestRevisionByEntryId(\n                    model,\n                    uniqueId\n                );\n\n                if (!originalStorageEntry) {\n                    throw new NotFoundError(\n                        `Entry \"${sourceId}\" of model \"${model.modelId}\" was not found.`\n                    );\n                }\n\n                /**\n                 * We need to convert data from DB to its original form before using it further.\n                 */\n                const originalEntry = await entryFromStorageTransform(\n                    context,\n                    model,\n                    originalStorageEntry\n                );\n\n                const values = {\n                    ...originalEntry.values,\n                    ...input\n                };\n\n                await validateModelEntryData(context, model, values);\n\n                utils.checkOwnership(context, permission, originalEntry);\n\n                const latestEntry = await entryFromStorageTransform(\n                    context,\n                    model,\n                    latestStorageEntry\n                );\n\n                const identity = context.security.getIdentity();\n\n                const latestId = latestStorageEntry ? latestStorageEntry.id : sourceId;\n                const { id, version: nextVersion } = increaseEntryIdVersion(latestId);\n\n                const entry: CmsContentEntry = {\n                    ...originalEntry,\n                    id,\n                    version: nextVersion,\n                    savedOn: new Date().toISOString(),\n                    createdOn: new Date().toISOString(),\n                    createdBy: {\n                        id: identity.id,\n                        displayName: identity.displayName,\n                        type: identity.type\n                    },\n                    locked: false,\n                    publishedOn: null,\n                    status: STATUS_DRAFT,\n                    values\n                };\n\n                let storageEntry: CmsStorageContentEntry = undefined;\n\n                try {\n                    await beforeCreateRevisionFromHook({\n                        context,\n                        model,\n                        entry,\n                        storageEntry,\n                        originalEntry,\n                        originalStorageEntry,\n                        latestEntry,\n                        latestStorageEntry,\n                        storageOperations\n                    });\n\n                    storageEntry = await entryToStorageTransform(context, model, entry);\n\n                    const result = await storageOperations.createRevisionFrom(model, {\n                        entry,\n                        storageEntry,\n                        originalEntry,\n                        originalStorageEntry,\n                        latestEntry,\n                        latestStorageEntry\n                    });\n                    await afterCreateRevisionFromHook({\n                        context,\n                        model,\n                        originalEntry,\n                        originalStorageEntry,\n                        latestEntry,\n                        latestStorageEntry,\n                        entry,\n                        /**\n                         * Passing result due to storage operations might have changed something on the entry.\n                         */\n                        storageEntry: result,\n                        storageOperations\n                    });\n                    return result;\n                } catch (ex) {\n                    throw new WebinyError(\n                        ex.message || \"Could not create entry from existing one.\",\n                        ex.code || \"CREATE_FROM_REVISION_ERROR\",\n                        {\n                            error: ex,\n                            entry,\n                            storageEntry,\n                            originalEntry,\n                            originalStorageEntry\n                        }\n                    );\n                }\n            },\n            update: async (model, id, inputData) => {\n                const permission = await checkEntryPermissions({ rwd: \"w\" });\n                await utils.checkModelAccess(context, model);\n\n                /**\n                 * Make sure we only work with fields that are defined in the model.\n                 */\n                const input = cleanInputData(model, inputData);\n\n                /**\n                 * Validate data early. We don't want to query DB if input data is invalid.\n                 */\n                await validateModelEntryData(context, model, input);\n                /**\n                 * The entry we are going to update.\n                 */\n                const originalStorageEntry = await storageOperations.getRevisionById(model, id);\n\n                if (!originalStorageEntry) {\n                    throw new NotFoundError(\n                        `Entry \"${id}\" of model \"${model.modelId}\" was not found.`\n                    );\n                }\n\n                if (originalStorageEntry.locked) {\n                    throw new WebinyError(\n                        `Cannot update entry because it's locked.`,\n                        \"CONTENT_ENTRY_UPDATE_ERROR\"\n                    );\n                }\n\n                const originalEntry = await entryFromStorageTransform(\n                    context,\n                    model,\n                    originalStorageEntry\n                );\n\n                utils.checkOwnership(context, permission, originalEntry);\n\n                /**\n                 * We always send the full entry to the hooks and storage operations update.\n                 */\n                const entry: CmsContentEntry = {\n                    ...originalEntry,\n                    savedOn: new Date().toISOString(),\n                    values: {\n                        /**\n                         * Existing values from the database, transformed back to original, of course.\n                         */\n                        ...originalEntry.values,\n                        /**\n                         * Add new values.\n                         */\n                        ...input\n                    }\n                };\n\n                let storageEntry: CmsStorageContentEntry = undefined;\n\n                try {\n                    await beforeUpdateHook({\n                        context,\n                        model,\n                        input,\n                        entry,\n                        originalEntry,\n                        originalStorageEntry,\n                        storageOperations\n                    });\n                    storageEntry = await entryToStorageTransform(context, model, entry);\n\n                    const result = await storageOperations.update(model, {\n                        originalEntry,\n                        originalStorageEntry,\n                        entry,\n                        storageEntry,\n                        input\n                    });\n                    await afterUpdateHook({\n                        context,\n                        model,\n                        input,\n                        entry,\n                        storageEntry: result,\n                        originalEntry,\n                        originalStorageEntry,\n                        storageOperations\n                    });\n                    return result;\n                } catch (ex) {\n                    throw new WebinyError(\n                        ex.message || \"Could not update existing entry.\",\n                        ex.code || \"UPDATE_ERROR\",\n                        {\n                            error: ex,\n                            entry,\n                            storageEntry,\n                            originalEntry,\n                            input\n                        }\n                    );\n                }\n            },\n            deleteRevision: async (model, revisionId) => {\n                const permission = await checkEntryPermissions({ rwd: \"d\" });\n                await utils.checkModelAccess(context, model);\n\n                const [entryId, version] = revisionId.split(\"#\");\n\n                const storageEntryToDelete = await storageOperations.getRevisionById(\n                    model,\n                    revisionId\n                );\n                const latestStorageEntry = await storageOperations.getLatestRevisionByEntryId(\n                    model,\n                    entryId\n                );\n                const previousStorageEntry = await storageOperations.getPreviousRevision(\n                    model,\n                    entryId,\n                    parseInt(version)\n                );\n\n                if (!storageEntryToDelete) {\n                    throw new NotFoundError(`Entry \"${revisionId}\" was not found!`);\n                }\n\n                utils.checkOwnership(context, permission, storageEntryToDelete);\n\n                const latestEntryRevisionId = latestStorageEntry ? latestStorageEntry.id : null;\n\n                const entryToDelete = await entryFromStorageTransform(\n                    context,\n                    model,\n                    storageEntryToDelete\n                );\n                /**\n                 * If targeted record is the latest entry record and there is no previous one, we need to run full delete with hooks.\n                 * At this point deleteEntry hooks are not fired.\n                 * TODO determine if not running the deleteRevision hooks is ok.\n                 */\n                if (entryToDelete.id === latestEntryRevisionId && !previousStorageEntry) {\n                    return await deleteEntry({\n                        model,\n                        entry: entryToDelete,\n                        storageEntry: storageEntryToDelete\n                    });\n                }\n                /**\n                 * If targeted record is latest entry revision, set the previous one as the new latest\n                 */\n                let entryToSetAsLatest: CmsContentEntry = null;\n                let storageEntryToSetAsLatest: CmsStorageContentEntry = null;\n                if (entryToDelete.id === latestEntryRevisionId) {\n                    entryToSetAsLatest = await entryFromStorageTransform(\n                        context,\n                        model,\n                        previousStorageEntry\n                    );\n                    storageEntryToSetAsLatest = previousStorageEntry;\n                }\n\n                try {\n                    await beforeDeleteRevisionHook({\n                        context,\n                        model,\n                        storageOperations,\n                        entryToDelete,\n                        storageEntryToDelete,\n                        entryToSetAsLatest,\n                        storageEntryToSetAsLatest\n                    });\n                    await storageOperations.deleteRevision(model, {\n                        entryToDelete,\n                        storageEntryToDelete,\n                        entryToSetAsLatest,\n                        storageEntryToSetAsLatest\n                    });\n\n                    await afterDeleteRevisionHook({\n                        context,\n                        model,\n                        storageOperations,\n                        entryToDelete,\n                        storageEntryToDelete,\n                        entryToSetAsLatest,\n                        storageEntryToSetAsLatest\n                    });\n                } catch (ex) {\n                    throw new WebinyError(ex.message, ex.code || \"DELETE_REVISION_ERROR\", {\n                        error: ex,\n                        entryToDelete,\n                        storageEntryToDelete,\n                        entryToSetAsLatest,\n                        storageEntryToSetAsLatest\n                    });\n                }\n            },\n            deleteEntry: async (model, entryId) => {\n                const permission = await checkEntryPermissions({ rwd: \"d\" });\n                await utils.checkModelAccess(context, model);\n\n                const storageEntry = await storageOperations.getLatestRevisionByEntryId(\n                    model,\n                    entryId\n                );\n\n                if (!storageEntry) {\n                    throw new NotFoundError(`Entry \"${entryId}\" was not found!`);\n                }\n\n                utils.checkOwnership(context, permission, storageEntry);\n\n                const entry = await entryFromStorageTransform(context, model, storageEntry);\n\n                return await deleteEntry({\n                    model,\n                    entry,\n                    storageEntry\n                });\n            },\n            publish: async (model, id) => {\n                const permission = await checkEntryPermissions({ pw: \"p\" });\n                await utils.checkModelAccess(context, model);\n\n                const originalStorageEntry = await storageOperations.getRevisionById(model, id);\n\n                if (!originalStorageEntry) {\n                    throw new NotFoundError(\n                        `Entry \"${id}\" in the model \"${model.modelId}\" was not found.`\n                    );\n                }\n\n                utils.checkOwnership(context, permission, originalStorageEntry);\n\n                const originalEntry = await entryFromStorageTransform(\n                    context,\n                    model,\n                    originalStorageEntry\n                );\n\n                const currentDate = new Date().toISOString();\n                const entry: CmsContentEntry = {\n                    ...originalEntry,\n                    status: STATUS_PUBLISHED,\n                    locked: true,\n                    savedOn: currentDate,\n                    publishedOn: currentDate\n                };\n\n                let storageEntry: CmsStorageContentEntry = undefined;\n\n                try {\n                    await beforePublishHook({\n                        context,\n                        storageOperations,\n                        model,\n                        entry,\n                        originalEntry,\n                        originalStorageEntry\n                    });\n                    storageEntry = await entryToStorageTransform(context, model, entry);\n                    const result = await storageOperations.publish(model, {\n                        entry,\n                        storageEntry,\n                        originalEntry,\n                        originalStorageEntry\n                    });\n                    await afterPublishHook({\n                        context,\n                        storageOperations,\n                        model,\n                        originalEntry,\n                        originalStorageEntry,\n                        entry,\n                        storageEntry: result\n                    });\n                    return result;\n                } catch (ex) {\n                    throw new WebinyError(\n                        ex.message || \"Could not publish entry.\",\n                        ex.code || \"PUBLISH_ERROR\",\n                        {\n                            entry,\n                            storageEntry,\n                            originalEntry,\n                            originalStorageEntry\n                        }\n                    );\n                }\n            },\n            requestChanges: async (model, id) => {\n                const permission = await checkEntryPermissions({ pw: \"c\" });\n\n                const originalStorageEntry = await storageOperations.getRevisionById(model, id);\n\n                if (!originalStorageEntry) {\n                    throw new NotFoundError(\n                        `Entry \"${id}\" of model \"${model.modelId}\" was not found.`\n                    );\n                }\n\n                const originalEntry = await entryFromStorageTransform(\n                    context,\n                    model,\n                    originalStorageEntry\n                );\n\n                if (originalEntry.status !== STATUS_REVIEW_REQUESTED) {\n                    throw new WebinyError(\n                        \"Cannot request changes on an entry that's not under review.\",\n                        \"ENTRY_NOT_UNDER_REVIEW\"\n                    );\n                }\n\n                const identity = context.security.getIdentity();\n                if (originalEntry.ownedBy.id === identity.id) {\n                    throw new WebinyError(\n                        \"You cannot request changes on your own entry.\",\n                        \"CANNOT_REQUEST_CHANGES_ON_OWN_ENTRY\"\n                    );\n                }\n\n                utils.checkOwnership(context, permission, originalEntry);\n\n                const entry: CmsContentEntry = {\n                    ...originalEntry,\n                    status: STATUS_CHANGES_REQUESTED\n                };\n\n                let storageEntry: CmsStorageContentEntry = undefined;\n\n                try {\n                    await beforeRequestChangesHook({\n                        context,\n                        model,\n                        originalEntry,\n                        originalStorageEntry,\n                        entry,\n                        storageOperations\n                    });\n\n                    storageEntry = await entryToStorageTransform(context, model, entry);\n\n                    const result = await storageOperations.requestChanges(model, {\n                        originalEntry,\n                        originalStorageEntry,\n                        entry,\n                        storageEntry\n                    });\n                    await afterRequestChangesHook({\n                        context,\n                        model,\n                        originalEntry,\n                        originalStorageEntry,\n                        entry,\n                        storageEntry: result,\n                        storageOperations\n                    });\n                    return result;\n                } catch (ex) {\n                    throw new WebinyError(\n                        ex.message || \"Could not request changes for the entry.\",\n                        ex.code || \"REQUEST_CHANGES_ERROR\",\n                        {\n                            entry,\n                            originalEntry\n                        }\n                    );\n                }\n            },\n            requestReview: async (model, id) => {\n                const permission = await checkEntryPermissions({ pw: \"r\" });\n                const [entryId] = id.split(\"#\");\n\n                const originalStorageEntry = await storageOperations.getRevisionById(model, id);\n                const latestEntryRevision = await storageOperations.getLatestRevisionByEntryId(\n                    model,\n                    entryId\n                );\n\n                if (!originalStorageEntry) {\n                    throw new NotFoundError(\n                        `Entry \"${id}\" of model \"${model.modelId}\" was not found.`\n                    );\n                } else if (!latestEntryRevision) {\n                    throw new NotFoundError(`Entry \"${id}\" does not have latest record`);\n                }\n\n                const originalEntry = await entryFromStorageTransform(\n                    context,\n                    model,\n                    originalStorageEntry\n                );\n\n                const allowedStatuses = [STATUS_DRAFT, STATUS_CHANGES_REQUESTED];\n                if (!allowedStatuses.includes(originalEntry.status)) {\n                    throw new WebinyError(\n                        \"Cannot request review - entry is not a draft nor was a change request issued.\",\n                        \"REQUEST_REVIEW_ERROR\",\n                        {\n                            entry: originalEntry\n                        }\n                    );\n                }\n\n                utils.checkOwnership(context, permission, originalEntry);\n\n                const entry: CmsContentEntry = {\n                    ...originalEntry,\n                    status: STATUS_REVIEW_REQUESTED\n                };\n\n                let storageEntry: CmsStorageContentEntry = undefined;\n\n                try {\n                    await beforeRequestReviewHook({\n                        context,\n                        model,\n                        originalEntry,\n                        originalStorageEntry,\n                        entry,\n                        storageOperations\n                    });\n\n                    storageEntry = await entryToStorageTransform(context, model, entry);\n\n                    const result = await storageOperations.requestReview(model, {\n                        originalEntry,\n                        originalStorageEntry,\n                        entry,\n                        storageEntry\n                    });\n                    await afterRequestReviewHook({\n                        context,\n                        model,\n                        originalEntry,\n                        originalStorageEntry,\n                        entry,\n                        storageEntry: result,\n                        storageOperations\n                    });\n                    return result;\n                } catch (ex) {\n                    throw new WebinyError(\n                        ex.message || \"Could not request review on the entry.\",\n                        ex.code || \"REQUEST_REVIEW_ERROR\",\n                        {\n                            originalEntry,\n                            entry\n                        }\n                    );\n                }\n            },\n            unpublish: async (model, id) => {\n                const permission = await checkEntryPermissions({ pw: \"u\" });\n\n                const [entryId] = id.split(\"#\");\n\n                const originalStorageEntry = await storageOperations.getPublishedRevisionByEntryId(\n                    model,\n                    entryId\n                );\n\n                if (!originalStorageEntry) {\n                    throw new NotFoundError(\n                        `Entry \"${id}\" of model \"${model.modelId}\" was not found.`\n                    );\n                }\n\n                if (originalStorageEntry.id !== id) {\n                    throw new WebinyError(`Entry is not published.`, \"UNPUBLISH_ERROR\", {\n                        entry: originalStorageEntry\n                    });\n                }\n\n                utils.checkOwnership(context, permission, originalStorageEntry);\n\n                const originalEntry = await entryFromStorageTransform(\n                    context,\n                    model,\n                    originalStorageEntry\n                );\n\n                const entry: CmsContentEntry = {\n                    ...originalEntry,\n                    status: STATUS_UNPUBLISHED\n                };\n\n                let storageEntry: CmsStorageContentEntry = undefined;\n\n                try {\n                    await beforeUnpublishHook({\n                        context,\n                        model,\n                        originalEntry,\n                        originalStorageEntry,\n                        entry,\n                        storageOperations\n                    });\n\n                    storageEntry = await entryToStorageTransform(context, model, entry);\n\n                    const result = await storageOperations.unpublish(model, {\n                        originalEntry,\n                        originalStorageEntry,\n                        entry,\n                        storageEntry\n                    });\n                    await afterUnpublishHook({\n                        context,\n                        model,\n                        originalEntry,\n                        originalStorageEntry,\n                        entry,\n                        storageEntry: result,\n                        storageOperations\n                    });\n                    return result;\n                } catch (ex) {\n                    throw new WebinyError(\n                        ex.message || \"Could not unpublish entry.\",\n                        ex.code || \"UNPUBLISH_ERROR\",\n                        {\n                            originalEntry,\n                            originalStorageEntry,\n                            entry,\n                            storageEntry\n                        }\n                    );\n                }\n            }\n        };\n\n        context.cms = {\n            ...(context.cms || ({} as any)),\n            entries\n        };\n    }\n});\n"],"file":"contentEntry.crud.js"}