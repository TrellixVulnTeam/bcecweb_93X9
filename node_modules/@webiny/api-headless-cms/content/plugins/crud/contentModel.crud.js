"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var utils = _interopRequireWildcard(require("../../../utils"));

var _dataloader = _interopRequireDefault(require("dataloader"));

var _handlerGraphql = require("@webiny/handler-graphql");

var _contentModelManagerFactory = require("./contentModel/contentModelManagerFactory");

var _models = require("./contentModel/models");

var _createFieldModels = require("./contentModel/createFieldModels");

var _validateLayout = require("./contentModel/validateLayout");

var _hooks = require("./contentModel/hooks");

var _apiSecurity = require("@webiny/api-security");

var _error = _interopRequireDefault(require("@webiny/error"));

var _ContentModelPlugin = require("@webiny/api-headless-cms/content/plugins/ContentModelPlugin");

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

var _default = () => ({
  type: "context",
  name: "context-content-model-storageOperations",

  async apply(context) {
    /**
     * If cms is not defined on the context, do not continue, but log it.
     */
    if (!context.cms) {
      return;
    }

    const pluginType = "cms-content-model-storage-operations-provider";
    const providerPlugins = context.plugins.byType(pluginType);
    /**
     * Storage operations for the content model.
     * Contains logic to save the data into the specific storage.
     */

    const providerPlugin = providerPlugins[providerPlugins.length - 1];

    if (!providerPlugin) {
      throw new _error.default(`Missing "${pluginType}" plugin.`, "PLUGIN_NOT_FOUND", {
        type: pluginType
      });
    }

    const storageOperations = await providerPlugin.provide({
      context
    });
    const loaders = {
      listModels: new _dataloader.default(async () => {
        const models = await storageOperations.list();
        return [models];
      })
    };
    const managers = new Map();

    const updateManager = async (context, model) => {
      const manager = await (0, _contentModelManagerFactory.contentModelManagerFactory)(context, model);
      managers.set(model.modelId, manager);
      return manager;
    };

    const checkModelPermissions = check => {
      return utils.checkPermissions(context, "cms.contentModel", {
        rwd: check
      });
    };

    const modelsGet = async modelId => {
      const pluginModel = context.plugins.byType(_ContentModelPlugin.ContentModelPlugin.type).find(plugin => plugin.contentModel.modelId === modelId);

      if (pluginModel) {
        return pluginModel.contentModel;
      }

      const databaseModel = await storageOperations.get({
        id: modelId
      });

      if (!databaseModel) {
        throw new _handlerGraphql.NotFoundError(`Content model "${modelId}" was not found!`);
      }

      return databaseModel;
    };

    const modelsList = async () => {
      const databaseModels = await loaders.listModels.load("listModels");
      const pluginsModels = context.plugins.byType(_ContentModelPlugin.ContentModelPlugin.type).map(plugin => plugin.contentModel);
      return [...databaseModels, ...pluginsModels];
    };

    const models = {
      operations: storageOperations,
      noAuth: () => {
        return {
          get: modelsGet,
          list: modelsList
        };
      },
      silentAuth: () => {
        return {
          list: async () => {
            try {
              return await models.list();
            } catch (ex) {
              if (ex instanceof _apiSecurity.NotAuthorizedError) {
                return [];
              }

              throw ex;
            }
          }
        };
      },

      async get(modelId) {
        const permission = await checkModelPermissions("r");
        const model = await modelsGet(modelId);
        utils.checkOwnership(context, permission, model);
        await utils.checkModelAccess(context, model);
        return model;
      },

      async list() {
        const permission = await checkModelPermissions("r");
        const models = await modelsList();
        return utils.filterAsync(models, async model => {
          if (!utils.validateOwnership(context, permission, model)) {
            return false;
          }

          return utils.validateModelAccess(context, model);
        });
      },

      async create(inputData) {
        await checkModelPermissions("w");
        const createdData = new _models.CreateContentModelModel().populate(inputData);
        await createdData.validate();
        const input = await createdData.toJSON();
        const group = await context.cms.groups.noAuth().get(input.group);

        if (!group) {
          throw new _handlerGraphql.NotFoundError(`There is no group "${input.group}".`);
        }

        const identity = context.security.getIdentity();

        const data = _objectSpread(_objectSpread({}, input), {}, {
          titleFieldId: "id",
          locale: context.cms.getLocale().code,
          group: {
            id: group.id,
            name: group.name
          },
          createdBy: {
            id: identity.id,
            displayName: identity.displayName,
            type: identity.type
          },
          createdOn: new Date().toISOString(),
          savedOn: new Date().toISOString(),
          fields: [],
          lockedFields: [],
          layout: []
        });

        await (0, _hooks.beforeCreateHook)({
          context,
          storageOperations,
          input,
          data
        });
        const model = await storageOperations.create({
          input,
          data
        });
        await updateManager(context, model);
        await (0, _hooks.afterCreateHook)({
          context,
          storageOperations,
          input,
          model
        });
        return model;
      },

      /**
       * Method does not check for permissions or ownership.
       * @internal
       */
      async updateModel(model, data) {
        const input = data;
        await (0, _hooks.beforeUpdateHook)({
          context,
          storageOperations,
          model,
          data,
          input
        });
        const resultModel = await storageOperations.update({
          data,
          model,
          input
        });
        await updateManager(context, resultModel);
        await (0, _hooks.afterUpdateHook)({
          context,
          storageOperations,
          model: resultModel,
          data,
          input
        });
        return resultModel;
      },

      async update(modelId, inputData) {
        await checkModelPermissions("w"); // Get a model record; this will also perform ownership validation.

        const model = await context.cms.models.get(modelId);
        const updatedData = new _models.UpdateContentModelModel().populate(inputData);
        await updatedData.validate();
        const input = await updatedData.toJSON({
          onlyDirty: true
        });

        if (Object.keys(input).length === 0) {
          return {};
        }

        if (input.group) {
          const group = await context.cms.groups.noAuth().get(input.group);

          if (!group) {
            throw new _handlerGraphql.NotFoundError(`There is no group "${input.group}".`);
          }

          input.group = {
            id: group.id,
            name: group.name
          };
        }

        const modelFields = await (0, _createFieldModels.createFieldModels)(model, inputData);
        (0, _validateLayout.validateLayout)(input, modelFields);

        const data = _objectSpread(_objectSpread({}, input), {}, {
          fields: modelFields,
          savedOn: new Date().toISOString()
        });

        await (0, _hooks.beforeUpdateHook)({
          context,
          storageOperations,
          model,
          data,
          input
        });
        const resultModel = await storageOperations.update({
          data,
          model,
          input
        });
        await updateManager(context, resultModel);
        await (0, _hooks.afterUpdateHook)({
          context,
          storageOperations,
          model: resultModel,
          data,
          input
        });
        return resultModel;
      },

      async delete(modelId) {
        await checkModelPermissions("d");
        const model = await context.cms.models.get(modelId);
        await (0, _hooks.beforeDeleteHook)({
          context,
          storageOperations,
          model
        });
        const result = await storageOperations.delete({
          model
        });

        if (!result) {
          throw new _error.default("Could not delete the content model", "CONTENT_MODEL_DELETE_ERROR", {
            modelId: model.modelId
          });
        }

        await (0, _hooks.afterDeleteHook)({
          context,
          storageOperations,
          model
        });
        managers.delete(model.modelId);
      },

      async getManager(modelId) {
        if (managers.has(modelId)) {
          return managers.get(modelId);
        }

        const models = await modelsList();
        const model = models.find(m => m.modelId === modelId);

        if (!model) {
          throw new _handlerGraphql.NotFoundError(`There is no content model "${modelId}".`);
        }

        return await updateManager(context, model);
      },

      getManagers: () => managers
    };
    context.cms = _objectSpread(_objectSpread({}, context.cms || {}), {}, {
      models,
      getModel: modelId => {
        return models.getManager(modelId);
      }
    });
  }

});

exports.default = _default;
//# sourceMappingURL=contentModel.crud.js.map