"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.beforeUpdateHook = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _error = _interopRequireDefault(require("@webiny/error"));

var _runContentModelLifecycleHooks = require("./runContentModelLifecycleHooks");

var _ContentModelPlugin = require("../../ContentModelPlugin");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

const defaultTitleFieldId = "id";
const allowedTitleFieldTypes = ["text", "number"];

const getContentModelTitleFieldId = (fields, titleFieldId) => {
  // if there is no title field defined either in input data or existing content model data
  // we will take first text field that has no multiple values enabled
  // or if initial titleFieldId is the default one also try to find first available text field
  if (!titleFieldId || titleFieldId === defaultTitleFieldId) {
    const titleField = fields.find(field => {
      return field.type === "text" && !field.multipleValues;
    });
    return titleField ? titleField.fieldId : defaultTitleFieldId;
  } // check existing titleFieldId for existence in the model
  // for correct type
  // and that it is not multiple values field


  const target = fields.find(f => f.fieldId === titleFieldId);

  if (!target) {
    throw new _error.default(`Field does not exist in the model.`, "VALIDATION_ERROR", {
      fieldId: titleFieldId
    });
  }

  if (allowedTitleFieldTypes.includes(target.type) === false) {
    throw new _error.default(`Only ${allowedTitleFieldTypes.join(", ")} and id fields can be used as an entry title.`, "ENTRY_TITLE_FIELD_TYPE", {
      fieldId: target.fieldId,
      type: target.type
    });
  }

  if (target.multipleValues) {
    throw new _error.default(`Fields that accept multiple values cannot be used as the entry title.`, "ENTRY_TITLE_FIELD_TYPE", {
      fieldId: target.fieldId,
      type: target.type
    });
  }

  return target.fieldId;
};

const beforeUpdateHook = async args => {
  const {
    context,
    model,
    data
  } = args;
  const modelPlugin = context.plugins.byType(_ContentModelPlugin.ContentModelPlugin.type).find(item => item.contentModel.modelId === model.modelId);

  if (modelPlugin) {
    throw new _error.default("Content models defined via plugins cannot be updated.", "CONTENT_MODEL_UPDATE_ERROR", {
      modelId: model.modelId
    });
  }

  const combinedModel = _objectSpread(_objectSpread({}, model), data);

  const {
    titleFieldId
  } = combinedModel; // There should be fields/locked fields in either model or data to be updated.

  const {
    fields = [],
    lockedFields = []
  } = combinedModel; // Let's inspect the fields of the received content model. We prevent saving of a content model if it
  // contains a field for which a "cms-model-field-to-graphql" plugin does not exist on the backend.

  const fieldTypePlugins = context.plugins.byType("cms-model-field-to-graphql");

  for (let i = 0; i < fields.length; i++) {
    const field = fields[i];

    if (!fieldTypePlugins.find(item => item.fieldType === field.type)) {
      throw new Error(`Cannot update content model because of the unknown "${field.type}" field.`);
    }
  }

  data.titleFieldId = getContentModelTitleFieldId(fields, titleFieldId);
  const cmsLockedFieldPlugins = context.plugins.byType("cms-model-locked-field"); // We must not allow removal or changes in fields that are already in use in content entries.

  for (const lockedField of lockedFields) {
    const existingField = fields.find(item => item.fieldId === lockedField.fieldId);

    if (!existingField) {
      throw new _error.default(`Cannot remove the field "${lockedField.fieldId}" because it's already in use in created content.`, "ENTRY_FIELD_USED");
    }

    if (lockedField.multipleValues !== existingField.multipleValues) {
      throw new _error.default(`Cannot change "multipleValues" for the "${lockedField.fieldId}" field because it's already in use in created content.`, "ENTRY_FIELD_USED");
    }

    if (lockedField.type !== existingField.type) {
      throw new _error.default(`Cannot change field type for the "${lockedField.fieldId}" field because it's already in use in created content.`, "ENTRY_FIELD_USED");
    } // Check `lockedField` invariant for specific field


    const lockedFieldsByType = cmsLockedFieldPlugins.filter(pl => pl.fieldType === lockedField.type);

    for (const plugin of lockedFieldsByType) {
      if (typeof plugin.checkLockedField !== "function") {
        continue;
      }

      plugin.checkLockedField({
        lockedField,
        field: existingField
      });
    }
  }

  if (args.storageOperations.beforeUpdate) {
    await args.storageOperations.beforeUpdate(args);
  }

  await (0, _runContentModelLifecycleHooks.runContentModelLifecycleHooks)("beforeUpdate", args);
};

exports.beforeUpdateHook = beforeUpdateHook;
//# sourceMappingURL=beforeUpdate.hook.js.map