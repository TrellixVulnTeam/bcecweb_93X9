"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.graphQLHandlerFactory = void 0;

var _boolean = require("boolean");

var _schema = require("@graphql-tools/schema");

var _apiSecurity = require("@webiny/api-security");

var _debugPlugins = _interopRequireDefault(require("@webiny/handler-graphql/debugPlugins"));

var _processRequestBody = _interopRequireDefault(require("@webiny/handler-graphql/processRequestBody"));

var _buildSchemaPlugins = _interopRequireDefault(require("./plugins/buildSchemaPlugins"));

var _plugins = require("@webiny/handler-graphql/plugins");

const DEFAULT_HEADERS = {
  "Access-Control-Allow-Origin": "*",
  "Access-Control-Allow-Headers": "*",
  "Access-Control-Allow-Methods": "OPTIONS,POST",
  "Content-Type": "application/json"
};

const respond = (http, result) => {
  return http.response({
    body: JSON.stringify(result),
    statusCode: 200,
    headers: DEFAULT_HEADERS
  });
};

const schemaList = new Map();

const generateCacheKey = async args => {
  const {
    context,
    locale,
    type
  } = args;
  const lastModelChange = await context.cms.settings.getContentModelLastChange();
  return [locale.code, type, lastModelChange.toISOString()].join("#");
};

const generateSchema = async args => {
  const {
    context
  } = args;
  context.plugins.register(await (0, _buildSchemaPlugins.default)(context));
  const typeDefs = [];
  const resolvers = []; // Get schema definitions from plugins

  const schemaPlugins = context.plugins.byType(_plugins.GraphQLSchemaPlugin.type);

  for (const pl of schemaPlugins) {
    typeDefs.push(pl.schema.typeDefs);
    resolvers.push(pl.schema.resolvers);
  }

  return (0, _schema.makeExecutableSchema)({
    typeDefs,
    resolvers
  });
}; // gets an existing schema or rewrites existing one or creates a completely new one
// depending on the schemaId created from type and locale parameters


const getSchema = async args => {
  const {
    context,
    type,
    locale
  } = args;
  const tenantId = context.tenancy.getCurrentTenant().id;
  const id = `${tenantId}#${type}#${locale.code}`;
  const cacheKey = await generateCacheKey(args);

  if (!schemaList.has(id)) {
    const schema = await generateSchema(args);
    schemaList.set(id, {
      key: cacheKey,
      schema
    });
    return schema;
  }

  const cache = schemaList.get(id);

  if (cache.key === cacheKey) {
    return cache.schema;
  }

  const schema = await generateSchema(args);
  schemaList.set(id, {
    key: cacheKey,
    schema
  });
  return schema;
};

const checkEndpointAccess = async context => {
  const permission = await context.security.getPermission(`cms.endpoint.${context.cms.type}`);

  if (!permission) {
    throw new _apiSecurity.NotAuthorizedError({
      data: {
        reason: `Not allowed to access "${context.cms.type}" endpoint.`
      }
    });
  }
};

const graphQLHandlerFactory = (options = {}) => {
  const debug = (0, _boolean.boolean)(options.debug);
  return [...(debug ? (0, _debugPlugins.default)() : []), {
    type: "handler",
    name: "handler-graphql-content-model",

    async handle(context, next) {
      const {
        http
      } = context;

      if (!http || !http.request || !http.request.path || !http.request.path.parameters) {
        return next();
      }

      if (http.request.method === "OPTIONS") {
        return http.response({
          statusCode: 204,
          headers: DEFAULT_HEADERS
        });
      }

      if (http.request.method !== "POST") {
        return next();
      }

      try {
        await checkEndpointAccess(context);
      } catch (ex) {
        return respond(http, new _apiSecurity.NotAuthorizedResponse(ex));
      }

      const schema = await getSchema({
        context,
        locale: context.cms.getLocale(),
        type: context.cms.type
      });
      const body = JSON.parse(http.request.body);
      const result = await (0, _processRequestBody.default)(body, schema, context);
      return respond(http, result);
    }

  }];
};

exports.graphQLHandlerFactory = graphQLHandlerFactory;
//# sourceMappingURL=graphQLHandlerFactory.js.map