{"version":3,"sources":["../../src/handler/index.ts"],"names":["Operations","getError","item","index","error","reason","match","checkErrors","result","body","items","err","process","env","DEBUG","console","log","JSON","stringify","WebinyError","type","handle","context","event","args","operations","record","Records","newImage","Converter","unmarshall","dynamodb","NewImage","ignore","oldImage","OldImage","keys","Keys","_id","PK","SK","operation","eventName","data","undefined","REMOVE","INSERT","MODIFY","push","_index","delete","length","res","elasticsearch","bulk"],"mappings":";;;;;;;;;AAAA;;AAGA;;AACA;;IAEKA,U;;WAAAA,U;AAAAA,EAAAA,U;AAAAA,EAAAA,U;AAAAA,EAAAA,U;GAAAA,U,KAAAA,U;;AAML,MAAMC,QAAQ,GAAIC,IAAD,IAA8B;AAC3C,MAAI,CAACA,IAAI,CAACC,KAAN,IAAe,CAACD,IAAI,CAACC,KAAL,CAAWC,KAA3B,IAAoC,CAACF,IAAI,CAACC,KAAL,CAAWC,KAAX,CAAiBC,MAA1D,EAAkE;AAC9D,WAAO,IAAP;AACH;;AACD,QAAMA,MAAM,GAAGH,IAAI,CAACC,KAAL,CAAWC,KAAX,CAAiBC,MAAhC;;AACA,MAAIA,MAAM,CAACC,KAAP,CAAa,oCAAb,MAAuD,IAA3D,EAAiE;AAC7D,WAAO,OAAP;AACH;;AACD,SAAOD,MAAP;AACH,CATD;;AAUA,MAAME,WAAW,GAAIC,MAAD,IAAiB;AACjC,MAAI,CAACA,MAAD,IAAW,CAACA,MAAM,CAACC,IAAnB,IAA2B,CAACD,MAAM,CAACC,IAAP,CAAYC,KAA5C,EAAmD;AAC/C;AACH;;AACD,OAAK,MAAMR,IAAX,IAAmBM,MAAM,CAACC,IAAP,CAAYC,KAA/B,EAAsC;AAClC,UAAMC,GAAG,GAAGV,QAAQ,CAACC,IAAD,CAApB;;AACA,QAAI,CAACS,GAAL,EAAU;AACN;AACH,KAFD,MAEO,IAAIA,GAAG,KAAK,OAAZ,EAAqB;AACxB,UAAIC,OAAO,CAACC,GAAR,CAAYC,KAAZ,KAAsB,MAA1B,EAAkC;AAC9BC,QAAAA,OAAO,CAACC,GAAR,CAAY,eAAZ,EAA6BC,IAAI,CAACC,SAAL,CAAeV,MAAf,EAAuB,IAAvB,EAA6B,CAA7B,CAA7B;AACH;;AACD;AACH;;AACD,UAAM,IAAIW,cAAJ,CAAgBR,GAAhB,EAAqB,iCAArB,EAAwDT,IAAxD,CAAN;AACH;AACJ,CAhBD;;eAkBe,OAA4C;AACvDkB,EAAAA,IAAI,EAAE,SADiD;;AAEvD,QAAMC,MAAN,CAAaC,OAAb,EAAsB;AAClB,UAAM,CAACC,KAAD,IAAUD,OAAO,CAACE,IAAxB;AACA,UAAMC,UAAU,GAAG,EAAnB;;AAEA,SAAK,MAAMC,MAAX,IAAqBH,KAAK,CAACI,OAA3B,EAAoC;AAChC,YAAMC,QAAQ,GAAGC,oBAAUC,UAAV,CAAqBJ,MAAM,CAACK,QAAP,CAAgBC,QAArC,CAAjB;;AAEA,UAAIJ,QAAQ,CAACK,MAAT,KAAoB,IAAxB,EAA8B;AAC1B;AACH;;AAED,YAAMC,QAAQ,GAAGL,oBAAUC,UAAV,CAAqBJ,MAAM,CAACK,QAAP,CAAgBI,QAArC,CAAjB;;AACA,YAAMC,IAAI,GAAGP,oBAAUC,UAAV,CAAqBJ,MAAM,CAACK,QAAP,CAAgBM,IAArC,CAAb;;AACA,YAAMC,GAAG,GAAI,GAAEF,IAAI,CAACG,EAAG,IAAGH,IAAI,CAACI,EAAG,EAAlC;AACA,YAAMC,SAAS,GAAGf,MAAM,CAACgB,SAAzB;AAEA;AACZ;AACA;AACA;;AACY,UAAIC,IAAS,GAAGC,SAAhB;;AACA,UAAIH,SAAS,KAAKzC,UAAU,CAAC6C,MAA7B,EAAqC;AACjC;AAChB;AACA;AACgBF,QAAAA,IAAI,GAAG,MAAM,6BAAWrB,OAAX,EAAoBM,QAAQ,CAACe,IAA7B,CAAb;AACA;AAChB;AACA;AACA;AACA;AACA;AACA;;AACgB,YAAIA,IAAI,KAAKC,SAAT,IAAsBD,IAAI,KAAK,IAAnC,EAAyC;AACrC5B,UAAAA,OAAO,CAACC,GAAR,CACK,2DAA0DyB,SAAU,SAAQH,GAAI,EADrF;AAGA;AACH;AACJ;;AAED,cAAQZ,MAAM,CAACgB,SAAf;AACI,aAAK1C,UAAU,CAAC8C,MAAhB;AACA,aAAK9C,UAAU,CAAC+C,MAAhB;AACItB,UAAAA,UAAU,CAACuB,IAAX,CAAgB;AAAE7C,YAAAA,KAAK,EAAE;AAAEmC,cAAAA,GAAF;AAAOW,cAAAA,MAAM,EAAErB,QAAQ,CAACzB;AAAxB;AAAT,WAAhB,EAA4DwC,IAA5D;AACA;;AACJ,aAAK3C,UAAU,CAAC6C,MAAhB;AACIpB,UAAAA,UAAU,CAACuB,IAAX,CAAgB;AAAEE,YAAAA,MAAM,EAAE;AAAEZ,cAAAA,GAAF;AAAOW,cAAAA,MAAM,EAAEf,QAAQ,CAAC/B;AAAxB;AAAV,WAAhB;AACA;;AACJ;AACI;AATR;AAWH;;AAED,QAAI,CAACsB,UAAU,CAAC0B,MAAhB,EAAwB;AACpB;AACH;;AAED,QAAI;AACA,YAAMC,GAAG,GAAG,MAAM9B,OAAO,CAAC+B,aAAR,CAAsBC,IAAtB,CAA2B;AAAE7C,QAAAA,IAAI,EAAEgB;AAAR,OAA3B,CAAlB;AACAlB,MAAAA,WAAW,CAAC6C,GAAD,CAAX;;AACA,UAAIxC,OAAO,CAACC,GAAR,CAAYC,KAAZ,KAAsB,MAA1B,EAAkC;AAC9BC,QAAAA,OAAO,CAACC,GAAR,CAAY,eAAZ,EAA6BC,IAAI,CAACC,SAAL,CAAekC,GAAf,EAAoB,IAApB,EAA0B,CAA1B,CAA7B;AACH;AACJ,KAND,CAME,OAAOhD,KAAP,EAAc;AACZ,UAAIQ,OAAO,CAACC,GAAR,CAAYC,KAAZ,KAAsB,MAA1B,EAAkC;AAC9BC,QAAAA,OAAO,CAACC,GAAR,CAAY,YAAZ,EAA0BC,IAAI,CAACC,SAAL,CAAed,KAAf,EAAsB,IAAtB,EAA4B,CAA5B,CAA1B;AACH;;AACD,YAAMA,KAAN;AACH;;AAED,WAAO,IAAP;AACH;;AA1EsD,CAA5C,C","sourcesContent":["import { Converter } from \"aws-sdk/clients/dynamodb\";\nimport { HandlerPlugin } from \"@webiny/handler/types\";\nimport { ElasticsearchContext } from \"@webiny/api-elasticsearch/types\";\nimport WebinyError from \"@webiny/error\";\nimport { decompress } from \"@webiny/api-elasticsearch/compression\";\n\nenum Operations {\n    INSERT = \"INSERT\",\n    MODIFY = \"MODIFY\",\n    REMOVE = \"REMOVE\"\n}\n\nconst getError = (item: any): string | null => {\n    if (!item.index || !item.index.error || !item.index.error.reason) {\n        return null;\n    }\n    const reason = item.index.error.reason;\n    if (reason.match(/no such index \\[([a-zA-Z0-9_-]+)\\]/) !== null) {\n        return \"index\";\n    }\n    return reason;\n};\nconst checkErrors = (result: any) => {\n    if (!result || !result.body || !result.body.items) {\n        return;\n    }\n    for (const item of result.body.items) {\n        const err = getError(item);\n        if (!err) {\n            continue;\n        } else if (err === \"index\") {\n            if (process.env.DEBUG === \"true\") {\n                console.log(\"Bulk response\", JSON.stringify(result, null, 2));\n            }\n            continue;\n        }\n        throw new WebinyError(err, \"DYNAMODB_TO_ELASTICSEARCH_ERROR\", item);\n    }\n};\n\nexport default (): HandlerPlugin<ElasticsearchContext> => ({\n    type: \"handler\",\n    async handle(context) {\n        const [event] = context.args;\n        const operations = [];\n\n        for (const record of event.Records) {\n            const newImage = Converter.unmarshall(record.dynamodb.NewImage);\n\n            if (newImage.ignore === true) {\n                continue;\n            }\n\n            const oldImage = Converter.unmarshall(record.dynamodb.OldImage);\n            const keys = Converter.unmarshall(record.dynamodb.Keys);\n            const _id = `${keys.PK}:${keys.SK}`;\n            const operation = record.eventName;\n\n            /**\n             * On operations other than REMOVE we decompress the data and store it into the Elasticsearch.\n             * No need to try to decompress if operation is REMOVE since there is no data sent into that operation.\n             */\n            let data: any = undefined;\n            if (operation !== Operations.REMOVE) {\n                /**\n                 * We must decompress the data that is going into the Elasticsearch.\n                 */\n                data = await decompress(context, newImage.data);\n                /**\n                 * No point in writing null or undefined data into the Elasticsearch.\n                 * This might happen on some error while decompressing. We will log it.\n                 *\n                 * Data should NEVER be null or undefined in the Elasticsearch DynamoDB table, unless it is a delete operations.\n                 * If it is - it is a bug.\n                 */\n                if (data === undefined || data === null) {\n                    console.log(\n                        `Could not get decompressed data, skipping ES operation \"${operation}\", ID ${_id}`\n                    );\n                    continue;\n                }\n            }\n\n            switch (record.eventName) {\n                case Operations.INSERT:\n                case Operations.MODIFY:\n                    operations.push({ index: { _id, _index: newImage.index } }, data);\n                    break;\n                case Operations.REMOVE:\n                    operations.push({ delete: { _id, _index: oldImage.index } });\n                    break;\n                default:\n                    break;\n            }\n        }\n\n        if (!operations.length) {\n            return;\n        }\n\n        try {\n            const res = await context.elasticsearch.bulk({ body: operations });\n            checkErrors(res);\n            if (process.env.DEBUG === \"true\") {\n                console.log(\"Bulk response\", JSON.stringify(res, null, 2));\n            }\n        } catch (error) {\n            if (process.env.DEBUG === \"true\") {\n                console.log(\"Bulk error\", JSON.stringify(error, null, 2));\n            }\n            throw error;\n        }\n\n        return true;\n    }\n});\n"],"file":"index.js"}