"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _fs = _interopRequireDefault(require("fs"));

var _path = _interopRequireDefault(require("path"));

var _util = _interopRequireDefault(require("util"));

var _ncp = _interopRequireDefault(require("ncp"));

var _loadJsonFile = _interopRequireDefault(require("load-json-file"));

var _writeJsonFile = _interopRequireDefault(require("write-json-file"));

var _pluralize = _interopRequireDefault(require("pluralize"));

var _case = _interopRequireDefault(require("case"));

var _replaceInPath = require("replace-in-path");

var _chalk = _interopRequireDefault(require("chalk"));

var _indentString = _interopRequireDefault(require("indent-string"));

var _error = _interopRequireDefault(require("@webiny/error"));

var _execa = _interopRequireDefault(require("execa"));

var _validateNpmPackageName = _interopRequireDefault(require("validate-npm-package-name"));

var _utils = require("@webiny/cli/utils");

const ncp = _util.default.promisify(_ncp.default.ncp);

const createPackageName = ({
  initial,
  location
}) => {
  if (initial) {
    return initial;
  }

  return _case.default.kebab(location);
};

var _default = () => ({
  name: "cli-plugin-scaffold-template-react-component",
  type: "cli-plugin-scaffold-template",
  scaffold: {
    name: "React Component Package",
    description: "Creates a new package that exports a simple React component.",
    questions: () => {
      return [{
        name: "componentName",
        message: "Enter the name of the component (in pascal-case)",
        default: "DisplayComponent",
        validate: name => {
          if (!name.match(/^([a-zA-Z]+)$/)) {
            return "A valid component name must consist of letters only.";
          } else if (!name.match(/^[A-Z]/)) {
            return "A valid component name must start with uppercase letter.";
          }

          return true;
        }
      }, {
        name: "location",
        message: `Enter the package location`,
        default: answers => {
          return `packages/${_case.default.kebab(answers.componentName)}`;
        },
        validate: location => {
          if (!location) {
            return "Please enter the package location.";
          }

          const locationPath = _path.default.resolve(location);

          if (_fs.default.existsSync(locationPath)) {
            return `The target location already exists "${location}".`;
          }

          return true;
        }
      }, {
        name: "packageName",
        message: "Enter the package name",
        default: answers => {
          return `@custom-components/${_case.default.kebab(answers.componentName)}`;
        },
        validate: packageName => {
          if (!packageName) {
            return true;
          } else if ((0, _validateNpmPackageName.default)(packageName)) {
            return true;
          }

          return `Package name must look something like "@custom-components/display".`;
        }
      }];
    },
    generate: async ({
      input,
      ora
    }) => {
      const {
        componentName,
        location,
        packageName: initialPackageName
      } = input;

      const fullLocation = _path.default.resolve(location);

      const packageName = createPackageName({
        initial: initialPackageName,
        location
      }); // Then we also copy the template folder

      const sourcePath = _path.default.join(__dirname, "template");

      if (_fs.default.existsSync(fullLocation)) {
        throw new _error.default(`Destination folder ${fullLocation} already exists.`);
      }

      const project = (0, _utils.getProject)({
        cwd: fullLocation
      });

      const locationRelative = _path.default.relative(project.root, fullLocation);

      const relativeRootPath = _path.default.relative(fullLocation, project.root);

      const baseTsConfigFullPath = _path.default.resolve(project.root, "tsconfig.json");

      const baseTsConfigRelativePath = _path.default.relative(fullLocation, baseTsConfigFullPath);

      const baseTsConfigBuildJsonPath = baseTsConfigFullPath.replace("tsconfig.json", "tsconfig.build.json");

      const baseTsConfigBuildRelativePath = _path.default.relative(fullLocation, baseTsConfigBuildJsonPath);

      const baseTsConfigBuildJson = await (0, _loadJsonFile.default)(baseTsConfigBuildJsonPath);
      ora.start(`Creating new Admin app module files in ${_chalk.default.green(fullLocation)}...`);
      await _fs.default.mkdirSync(fullLocation, {
        recursive: true
      }); // Copy template files

      await ncp(sourcePath, fullLocation); // Replace generic "Target" with received "input.componentName"

      const name = {
        plural: (0, _pluralize.default)(_case.default.camel(componentName)),
        singular: _pluralize.default.singular(_case.default.camel(componentName))
      };
      const codeReplacements = [{
        find: "targets",
        replaceWith: _case.default.camel(name.plural)
      }, {
        find: "Targets",
        replaceWith: _case.default.pascal(name.plural)
      }, {
        find: "TARGETS",
        replaceWith: _case.default.constant(name.plural)
      }, {
        find: "target",
        replaceWith: _case.default.camel(name.singular)
      }, {
        find: "Target",
        replaceWith: _case.default.pascal(name.singular)
      }, {
        find: "TARGET",
        replaceWith: _case.default.constant(name.singular)
      }, {
        find: "PACKAGE_NAME",
        replaceWith: packageName
      }, {
        find: "RELATIVE_ROOT_PATH",
        replaceWith: relativeRootPath.replace(/\\/g, "/")
      }];
      (0, _replaceInPath.replaceInPath)(_path.default.join(fullLocation, ".babelrc.js"), codeReplacements);
      (0, _replaceInPath.replaceInPath)(_path.default.join(fullLocation, "**/*.ts"), codeReplacements);
      (0, _replaceInPath.replaceInPath)(_path.default.join(fullLocation, "**/*.tsx"), codeReplacements); // Make sure to also rename base file names.

      const fileNameReplacements = [{
        find: "src/Target.tsx",
        replaceWith: `src/${_case.default.pascal(name.singular)}.tsx`
      }];

      for (const key in fileNameReplacements) {
        if (!fileNameReplacements.hasOwnProperty(key)) {
          continue;
        }

        const fileNameReplacement = fileNameReplacements[key];

        _fs.default.renameSync(_path.default.join(fullLocation, fileNameReplacement.find), _path.default.join(fullLocation, fileNameReplacement.replaceWith));
      } // Generated package file changes


      ora.start(`Setting package name...`);

      const packageJsonFile = _path.default.resolve(fullLocation, "package.json");

      const packageJson = _loadJsonFile.default.sync(packageJsonFile);

      packageJson.name = packageName;

      const {
        version
      } = require("@webiny/cli-plugin-scaffold/package.json"); // Inject Webiny packages version


      Object.keys(packageJson.dependencies).forEach(name => {
        if (name.startsWith("@webiny")) {
          packageJson.dependencies[name] = version;
        }
      });
      Object.keys(packageJson.devDependencies).forEach(name => {
        if (name.startsWith("@webiny")) {
          packageJson.devDependencies[name] = version;
        }
      });
      await (0, _writeJsonFile.default)(packageJsonFile, packageJson);
      ora.stopAndPersist({
        symbol: _chalk.default.green("✔"),
        text: "Package name set."
      });
      ora.start(`Setting tsconfig.json extends path...`);

      const packageTsConfigFilePath = _path.default.resolve(fullLocation, "tsconfig.json");

      const packageTsConfig = _loadJsonFile.default.sync(packageTsConfigFilePath);

      packageTsConfig.extends = baseTsConfigRelativePath;
      await (0, _writeJsonFile.default)(packageTsConfigFilePath, packageTsConfig);
      ora.stopAndPersist({
        symbol: _chalk.default.green("✔"),
        text: "tsconfig.json extends set."
      });
      ora.start(`Setting tsconfig.build.json extends path...`);

      const packageTsConfigBuildFilePath = _path.default.resolve(fullLocation, "tsconfig.build.json");

      const packageTsConfigBuild = _loadJsonFile.default.sync(packageTsConfigBuildFilePath);

      packageTsConfigBuild.extends = baseTsConfigBuildRelativePath;
      await (0, _writeJsonFile.default)(packageTsConfigBuildFilePath, packageTsConfigBuild);
      ora.stopAndPersist({
        symbol: _chalk.default.green("✔"),
        text: "tsconfig.build.json extends set."
      }); // Add package to workspaces

      const rootPackageJsonPath = _path.default.join(project.root, "package.json");

      const rootPackageJson = await (0, _loadJsonFile.default)(rootPackageJsonPath);

      if (!rootPackageJson.workspaces.packages.includes(location)) {
        rootPackageJson.workspaces.packages.push(location);
        await (0, _writeJsonFile.default)(rootPackageJsonPath, rootPackageJson);
      } // Update root tsconfig.build.json file paths


      ora.start(`Updating base tsconfig compilerOptions.paths to contain the package...`);

      if (!baseTsConfigBuildJson.compilerOptions) {
        baseTsConfigBuildJson.compilerOptions = {};
      }

      baseTsConfigBuildJson.compilerOptions.paths[`${packageName}`] = [`./${locationRelative}/src`];
      baseTsConfigBuildJson.compilerOptions.paths[`${packageName}/*`] = [`./${locationRelative}/src/*`];
      await (0, _writeJsonFile.default)(baseTsConfigBuildJsonPath, baseTsConfigBuildJson);
      ora.stopAndPersist({
        symbol: _chalk.default.green("✔"),
        text: `Updated base tsconfig compilerOptions.paths.`
      }); // Once everything is done, run `yarn` so the new packages are automatically installed.

      try {
        ora.start(`Installing dependencies...`);
        await (0, _execa.default)("yarn");
        ora.stopAndPersist({
          symbol: _chalk.default.green("✔"),
          text: "Dependencies installed."
        });
        ora.start(`Building generated package...`);
        const cwd = process.cwd();
        process.chdir(fullLocation);
        await (0, _execa.default)("yarn", ["build"]);
        process.chdir(cwd);
        ora.stopAndPersist({
          symbol: _chalk.default.green("✔"),
          text: "Package built."
        });
        ora.start(`Linking package...`);
        await (0, _execa.default)("yarn", ["postinstall"]);
        ora.stopAndPersist({
          symbol: _chalk.default.green("✔"),
          text: "Package linked."
        });
      } catch (err) {
        throw new _error.default(`Unable to install dependencies. Try running "yarn" in project root manually.`, err.message);
      }
    },
    onSuccess: async ({
      input
    }) => {
      const {
        componentName,
        location,
        packageName: initialPackageName
      } = input;

      const name = _case.default.pascal(componentName);

      const packageName = createPackageName({
        initial: initialPackageName,
        location
      });
      console.log("1. Include the package in your applications package.json file:");
      console.log((0, _indentString.default)(_chalk.default.green(`
// somewhere in your dependencies
"${packageName}": "^1.0.0"
`), 2));
      console.log("2. Import your component:");
      console.log((0, _indentString.default)(_chalk.default.green(`
// at the top of the file
import { ${name} } from "${packageName}";

// use in the code
<${name} />
`), 2));
      console.log("Learn more about app development at https://www.webiny.com/docs/tutorials/create-an-application/introduction.");
    }
  }
});

exports.default = _default;
//# sourceMappingURL=index.js.map