import _createForOfIteratorHelper from "@babel/runtime/helpers/createForOfIteratorHelper";
import _asyncToGenerator from "@babel/runtime/helpers/asyncToGenerator";
import _slicedToArray from "@babel/runtime/helpers/slicedToArray";
import _regeneratorRuntime from "@babel/runtime/regenerator";
import React, { useState, useMemo, useCallback, Fragment, useRef } from "react";
import { plugins } from "@webiny/plugins";
import { useSecurity } from "@webiny/app-security";
import { TenantHeaderLinkPlugin } from "@webiny/app/plugins/TenantHeaderLinkPlugin";
import { TenantPlugin } from "../plugins/TenantPlugin";
export var TenancyContext = /*#__PURE__*/React.createContext(null);
export var TenancyProvider = function TenancyProvider(props) {
  var _useState = useState(null),
      _useState2 = _slicedToArray(_useState, 2),
      currentTenant = _useState2[0],
      setCurrentTenant = _useState2[1];

  var _useSecurity = useSecurity(),
      identity = _useSecurity.identity;

  var onChangeCallbacks = useRef(new Set());
  var tenantPlugins = plugins.byType(TenantPlugin.type);
  /**
   * Create plugin elements. Once mounted, they will attach to Tenancy using `useTenancy()` hook.
   * Why mounting an element? Because that will allow the plugin authors to access any available context
   * using hooks and we won't need to think about all the possible dependencies we need to provide to the plugin.
   */

  var pluginElements = useMemo(function () {
    return tenantPlugins.map(function (plugin) {
      return plugin.render();
    });
  }, [tenantPlugins]);
  var changeTenant = useCallback( /*#__PURE__*/function () {
    var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(tenant) {
      var callbacks, _iterator, _step, callback;

      return _regeneratorRuntime.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              callbacks = onChangeCallbacks.current.values();
              _iterator = _createForOfIteratorHelper(callbacks);

              try {
                for (_iterator.s(); !(_step = _iterator.n()).done;) {
                  callback = _step.value;
                  callback(tenant);
                }
              } catch (err) {
                _iterator.e(err);
              } finally {
                _iterator.f();
              }

              setCurrentTenant(tenant);
              plugins.register(new TenantHeaderLinkPlugin(tenant.id));

            case 5:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));

    return function (_x) {
      return _ref.apply(this, arguments);
    };
  }(), []);
  var value = useMemo(function () {
    return {
      tenant: currentTenant,
      tenants: identity.access,
      setTenant: changeTenant,
      onChange: function onChange(cb) {
        onChangeCallbacks.current.add(cb);
        return function () {
          return onChangeCallbacks.current.delete(cb);
        };
      }
    };
  }, [identity, currentTenant]);
  return /*#__PURE__*/React.createElement(TenancyContext.Provider, {
    value: value
  }, /*#__PURE__*/React.createElement(Fragment, null, pluginElements, currentTenant ? props.children : null));
};
//# sourceMappingURL=Tenancy.js.map