import _taggedTemplateLiteral from "@babel/runtime/helpers/taggedTemplateLiteral";

var _templateObject;

import React, { Fragment } from "react";
import get from "lodash/get";
import { Icon } from "@webiny/ui/Icon";
import { i18n } from "@webiny/app/i18n";
import { ReactComponent as HandleIcon } from "@svgr/webpack!../../icons/round-drag_indicator-24px.svg";
import { Center, Vertical, Horizontal } from "../DropZone";
import Draggable from "../Draggable";
import EditFieldDialog from "./EditFieldDialog";
import Field from "./Field";
import { rowHandle, fieldHandle, fieldContainer, Row, RowContainer } from "./Styled";
import { useFieldEditor } from "./useFieldEditor";
import { FieldEditorProvider } from "./FieldEditorContext";
var t = i18n.namespace("app-headless-cms/admin/components/editor");
var fieldTypes = ["field", "newField"];

var Editor = function Editor() {
  var _useFieldEditor = useFieldEditor(),
      parent = _useFieldEditor.parent,
      depth = _useFieldEditor.depth,
      insertField = _useFieldEditor.insertField,
      updateField = _useFieldEditor.updateField,
      deleteField = _useFieldEditor.deleteField,
      fields = _useFieldEditor.fields,
      noConflict = _useFieldEditor.noConflict,
      editField = _useFieldEditor.editField,
      onFieldDrop = _useFieldEditor.onFieldDrop,
      onEndDrag = _useFieldEditor.onEndDrag,
      field = _useFieldEditor.field,
      dropTarget = _useFieldEditor.dropTarget;

  return /*#__PURE__*/React.createElement(Fragment, null, fields.length === 0 && /*#__PURE__*/React.createElement(Center, {
    onDrop: function onDrop(item) {
      return onFieldDrop(item, {
        row: 0,
        index: 0
      });
    },
    style: {
      padding: "5px 0 15px 0"
    }
  }, t(_templateObject || (_templateObject = _taggedTemplateLiteral(["Drop your first field here"])))), fields.map(function (row, index) {
    return /*#__PURE__*/React.createElement(Draggable, {
      beginDrag: {
        parent: parent ? parent.fieldId : null,
        type: "row",
        fields: row,
        pos: {
          row: index
        }
      },
      endDrag: onEndDrag,
      key: row.map(function (f) {
        return f.fieldId;
      }).join(".")
    }, function (_ref
    /* RowContainer start - includes drag handle, drop zones and the Row itself. */
    ) {
      var drag = _ref.drag,
          isDragging = _ref.isDragging;
      return /*#__PURE__*/React.createElement(RowContainer, {
        style: {
          opacity: isDragging ? 0.3 : 1
        }
      }, /*#__PURE__*/React.createElement("div", {
        className: rowHandle,
        ref: drag
      }, /*#__PURE__*/React.createElement(Icon, {
        icon: /*#__PURE__*/React.createElement(HandleIcon, null)
      })), /*#__PURE__*/React.createElement(Horizontal, {
        "data-testid": "cms-editor-row-droppable-top-".concat(index),
        isVisible: noConflict(),
        onDrop: function onDrop(item) {
          return onFieldDrop(item, {
            row: index,
            index: null
          });
        }
      }), /*#__PURE__*/React.createElement(Row, {
        "data-testid": "cms.editor.field-row"
      }, row.map(function (field, fieldIndex) {
        return /*#__PURE__*/React.createElement(Draggable, {
          key: field.fieldId,
          beginDrag: {
            parent: parent ? parent.fieldId : null,
            type: "field",
            field: field,
            pos: {
              row: index,
              index: fieldIndex
            }
          },
          endDrag: onEndDrag
        }, function (_ref2) {
          var drag = _ref2.drag;
          return /*#__PURE__*/React.createElement("div", {
            className: fieldContainer,
            ref: drag
          }, /*#__PURE__*/React.createElement(Vertical, {
            depth: depth,
            onDrop: function onDrop(item) {
              return onFieldDrop(item, {
                row: index,
                index: fieldIndex
              });
            },
            isVisible: noConflict(function (item) {
              return fieldTypes.includes(item.type) && (row.length < 4 || get(item, "pos.row") === index);
            })
          }), /*#__PURE__*/React.createElement("div", {
            className: fieldHandle
          }, /*#__PURE__*/React.createElement(Field, {
            parent: parent,
            field: field,
            onEdit: editField,
            onDelete: deleteField
          })), fieldIndex === row.length - 1 && /*#__PURE__*/React.createElement(Vertical, {
            last: true,
            depth: depth,
            isVisible: noConflict(function (item) {
              return fieldTypes.includes(item.type) && (row.length < 4 || get(item, "pos.row") === index);
            }),
            onDrop: function onDrop(item) {
              return onFieldDrop(item, {
                row: index,
                index: fieldIndex + 1
              });
            }
          }));
        });
      })), index === fields.length - 1 && /*#__PURE__*/React.createElement(Horizontal, {
        "data-testid": "cms-editor-row-droppable-bottom-".concat(index),
        last: true,
        isVisible: noConflict(),
        onDrop: function onDrop(item) {
          return onFieldDrop(item, {
            row: index + 1,
            index: null
          });
        }
      }));
    });
  }), /*#__PURE__*/React.createElement(EditFieldDialog, {
    field: field,
    onClose: editField,
    onSubmit: function onSubmit(field) {
      if (field.id) {
        updateField(field);
      } else {
        insertField({
          field: field,
          position: dropTarget
        });
      }

      editField(null);
    }
  }));
};

export var FieldEditor = function FieldEditor(props) {
  return /*#__PURE__*/React.createElement(FieldEditorProvider, props, /*#__PURE__*/React.createElement(Editor, null));
};
//# sourceMappingURL=FieldEditor.js.map