import _objectSpread from "@babel/runtime/helpers/objectSpread2";
import _slicedToArray from "@babel/runtime/helpers/slicedToArray";
import React, { useCallback, useState } from "react";
import dot from "dot-prop-immutable";
import shortid from "shortid";
import cloneDeep from "lodash/cloneDeep";
import useDeepCompareEffect from "use-deep-compare-effect";
import { plugins } from "@webiny/plugins";
import * as utils from "./utils";
import { useFieldEditor } from "./useFieldEditor";
export var FieldEditorContext = /*#__PURE__*/React.createContext(null);
export var FieldEditorProvider = function FieldEditorProvider(_ref) {
  var parent = _ref.parent,
      fields = _ref.fields,
      layout = _ref.layout,
      onChange = _ref.onChange,
      children = _ref.children;
  // We need to determine depth of this provider so we can render drop zones with correct z-indexes.
  var depth = 0;

  try {
    var editor = useFieldEditor();
    depth = editor.depth + 1;
  } catch (_unused) {// There's no parent provider, so this is the top-level one.
  }

  var _useState = useState({
    layout: layout,
    fields: fields,
    field: null,
    dropTarget: null
  }),
      _useState2 = _slicedToArray(_useState, 2),
      state = _useState2[0],
      setState = _useState2[1];

  useDeepCompareEffect(function () {
    onChange({
      fields: state.fields,
      layout: state.layout
    });
  }, [state.fields, state.layout]);
  var editField = useCallback(function (field) {
    setState(function (state) {
      return _objectSpread(_objectSpread({}, state), {}, {
        field: field
      });
    });
  }, []);
  var onDropTarget = {
    dropTarget: parent ? parent.fieldId : null
  };
  var onFieldDrop = useCallback(function (source, dropTarget) {
    var pos = source.pos,
        type = source.type,
        fieldType = source.fieldType,
        field = source.field,
        fields = source.fields;
    var parentId = parent ? parent.fieldId : null;

    if (type === "row") {
      if (parentId !== source.parent) {
        // We're dragging an existing row from another fieldset
        fields.forEach(function (field, index) {
          insertField({
            field: field,
            position: {
              row: dropTarget.row,
              index: index === 0 ? null : index
            }
          });
        });
      } else {
        // We're dragging a row within the same fieldset
        moveRow(pos.row, dropTarget.row);
      }

      return onDropTarget;
    } // If source pos is set, we are moving an existing field.


    if (pos) {
      if (parentId !== source.parent) {
        // We're dragging an existing field from another fieldset
        insertField({
          field: field,
          position: dropTarget
        });
      } else {
        // We're dragging a field within the same fieldset
        moveField({
          field: field,
          position: dropTarget
        });
      }

      return onDropTarget;
    }

    var plugin = getFieldPlugin(fieldType);
    editField(plugin.field.createField());
    setState(function (state) {
      return _objectSpread(_objectSpread({}, state), {}, {
        dropTarget: dropTarget
      });
    });
  }, []);

  var onEndDrag = function onEndDrag(_ref2, monitor) {
    var type = _ref2.type,
        field = _ref2.field,
        fields = _ref2.fields;

    if (!monitor.didDrop()) {
      return;
    } // Check if we dropped outside of the source fieldset, and if yes, remove the field from the original parent.


    var _monitor$getDropResul = monitor.getDropResult(),
        dropTarget = _monitor$getDropResul.dropTarget;

    var parentId = parent ? parent.fieldId : null;

    if (dropTarget === parentId) {
      return;
    }

    var removeFields = type === "row" ? fields : [field];
    removeFields.forEach(function (field) {
      return deleteField(field);
    });
  };

  var getFieldsInLayout = function getFieldsInLayout() {
    // Replace every field ID with actual field object.
    var fields = cloneDeep(state.layout.filter(function (arr) {
      return arr.length;
    }));
    fields.forEach(function (row, rowIndex) {
      row.forEach(function (fieldId, fieldIndex) {
        fields[rowIndex][fieldIndex] = getField({
          id: fieldId
        });
      });
    });
    return fields;
  };
  /**
   * Return field plugin.
   */


  var getFieldPlugin = function getFieldPlugin(type) {
    return plugins.byType("cms-editor-field-type").find(function (_ref3) {
      var field = _ref3.field;
      return field.type === type;
    });
  };
  /**
   * Checks if field of given type already exists in the list of fields.
   */


  var getField = function getField(query) {
    return state.fields.find(function (field) {
      for (var key in query) {
        if (!(key in field)) {
          return null;
        }

        if (field[key] !== query[key]) {
          return null;
        }
      }

      return true;
    });
  };
  /**
   * Inserts a new field into the target position.
   */


  var insertField = function insertField(_ref4) {
    var field = _ref4.field,
        position = _ref4.position;

    if (!field.id) {
      field.id = shortid.generate();
    }

    if (!field.type) {
      throw new Error("Field \"type\" missing.");
    }

    var fieldPlugin = getFieldPlugin(field.type);

    if (!fieldPlugin) {
      throw new Error("Invalid field \"type\".");
    }

    setState(function (data) {
      data = dot.set(data, "fields", function (fields) {
        if (Array.isArray(fields)) {
          return fields.concat(field);
        }

        return [field];
      }); // Move field to position where it was dropped.

      return utils.moveField({
        field: field,
        position: position,
        data: data
      });
    });
  };
  /**
   * Moves field to the given target position.
   */


  var moveField = function moveField(_ref5) {
    var field = _ref5.field,
        position = _ref5.position;
    setState(function (data) {
      return utils.moveField({
        field: field,
        position: position,
        data: data
      });
    });
  };
  /**
   * Moves row to a destination row.
   */


  var moveRow = function moveRow(source, destination) {
    setState(function (data) {
      return utils.moveRow({
        data: data,
        source: source,
        destination: destination
      });
    });
  };
  /**
   * Updates field.
   */


  var updateField = function updateField(field) {
    setState(function (data) {
      for (var i = 0; i < data.fields.length; i++) {
        if (data.fields[i].id === field.id) {
          return dot.set(data, "fields.".concat(i), field);
        }
      }
    });
  };
  /**
   * Deletes a field (both from the list of field and the layout).
   */


  var deleteField = function deleteField(field) {
    setState(function (data) {
      return utils.deleteField({
        field: field,
        data: data
      });
    });
  };

  var noConflict = useCallback(function (isVisible) {
    return function (item) {
      var sameParent = item.parent === onDropTarget.dropTarget;
      var draggedFields = [];

      switch (item.type) {
        case "row":
          item.fields.forEach(function (field) {
            return draggedFields.push(field.fieldId);
          });
          break;

        case "field":
          draggedFields.push(item.field.fieldId);
          break;

        default:
          break;
      }

      if (draggedFields.length && !sameParent && fields.some(function (field) {
        return draggedFields.includes(field.fieldId);
      })) {
        return false;
      }

      return typeof isVisible === "function" ? isVisible(item) : true;
    };
  }, [fields.map(function (f) {
    return f.fieldId;
  }).join(".")]);
  var value = {
    parent: parent,
    depth: depth,
    getFieldsInLayout: getFieldsInLayout,
    getFieldPlugin: getFieldPlugin,
    getField: getField,
    editField: editField,
    field: state.field,
    dropTarget: state.dropTarget,
    onFieldDrop: onFieldDrop,
    onEndDrag: onEndDrag,
    insertField: insertField,
    moveField: moveField,
    moveRow: moveRow,
    updateField: updateField,
    deleteField: deleteField,
    fields: getFieldsInLayout(),
    noConflict: noConflict,
    layout: state.layout
  };
  return /*#__PURE__*/React.createElement(FieldEditorContext.Provider, {
    value: value
  }, children);
};
//# sourceMappingURL=FieldEditorContext.js.map