import _toConsumableArray from "@babel/runtime/helpers/toConsumableArray";
import _objectSpread from "@babel/runtime/helpers/objectSpread2";
import React, { useRef, useCallback, cloneElement } from "react";
import { createValidators } from "./functions/createValidators";
export function useBind(_ref) {
  var ParentBind = _ref.Bind,
      field = _ref.field;
  var memoizedBindComponents = useRef({});
  return useCallback(function () {
    var index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : -1;
    var parentName = ParentBind.parentName; // If there's a parent name assigned to the given Bind component, we need to include it in the new field "name".
    // This allows us to have nested fields (like "object" field with nested properties)

    var name = [parentName, field.fieldId, index >= 0 ? index : undefined].filter(function (v) {
      return v !== undefined;
    }).join(".");

    if (memoizedBindComponents.current[name]) {
      return memoizedBindComponents.current[name];
    }

    var validators = createValidators(field.validation || []);
    var listValidators = createValidators(field.listValidation || []);
    var defaultValue = field.multipleValues ? [] : undefined;
    var isMultipleValues = index === -1 && field.multipleValues;
    var inputValidators = isMultipleValues ? listValidators : validators;

    memoizedBindComponents.current[name] = function UseBind(_ref2) {
      var childName = _ref2.name,
          childValidators = _ref2.validators,
          children = _ref2.children;
      return /*#__PURE__*/React.createElement(ParentBind, {
        name: childName || name,
        validators: childValidators || inputValidators,
        defaultValue: index === -1 ? defaultValue : null
      }, function (bind) {
        // Multiple-values functions below.
        var props = _objectSpread({}, bind);

        if (field.multipleValues && index === -1) {
          props.appendValue = function (newValue) {
            bind.onChange([].concat(_toConsumableArray(bind.value), [newValue]));
          };

          props.prependValue = function (newValue) {
            bind.onChange([newValue].concat(_toConsumableArray(bind.value)));
          };

          props.appendValues = function (newValues) {
            bind.onChange([].concat(_toConsumableArray(bind.value), _toConsumableArray(newValues)));
          };

          props.removeValue = function (index) {
            if (index >= 0) {
              var _value = bind.value;
              _value = [].concat(_toConsumableArray(_value.slice(0, index)), _toConsumableArray(_value.slice(index + 1)));
              bind.onChange(_value); // To make sure the field is still valid, we must trigger validation.

              bind.form.validateInput(field.fieldId);
            }
          };
        }

        if (typeof children === "function") {
          return children(props);
        }

        return /*#__PURE__*/cloneElement(children, props);
      });
    }; // We need to keep track of current field name, to support nested fields.


    memoizedBindComponents.current[name].parentName = name;
    return memoizedBindComponents.current[name];
  }, [field.fieldId]);
}
//# sourceMappingURL=useBind.js.map