import _toConsumableArray from "@babel/runtime/helpers/toConsumableArray";
import _objectSpread from "@babel/runtime/helpers/objectSpread2";
import _slicedToArray from "@babel/runtime/helpers/slicedToArray";
import dotProp from "dot-prop-immutable";
import orderBy from "lodash/orderBy";
import * as GQL from "../../../graphql/contentEntries";
/*
 * We need to preserve the order of entries with new entry addition
 * because we're not re-fetching the list but updating it directly inside cache.
 * */

var sortEntries = function sortEntries(list, sort) {
  if (!sort || typeof sort !== "string") {
    return list;
  }

  var _sort$split = sort.split("_"),
      _sort$split2 = _slicedToArray(_sort$split, 2),
      key = _sort$split2[0],
      value = _sort$split2[1];

  var order = value.toLowerCase();
  return orderBy(list, [key], [order]);
};

export var addEntryToListCache = function addEntryToListCache(model, cache, entry, variables) {
  var gqlParams = {
    query: GQL.createListQuery(model),
    variables: variables
  };

  var _cache$readQuery = cache.readQuery(gqlParams),
      content = _cache$readQuery.content;

  if (!content || !content.data) {
    return;
  }

  cache.writeQuery(_objectSpread(_objectSpread({}, gqlParams), {}, {
    data: {
      content: _objectSpread(_objectSpread({}, content), {}, {
        data: sortEntries([entry].concat(_toConsumableArray(content.data)), variables.sort)
      })
    }
  }));
};
export var updateLatestRevisionInListCache = function updateLatestRevisionInListCache(model, cache, revision, variables) {
  var gqlParams = {
    query: GQL.createListQuery(model),
    variables: variables
  };

  var _revision$id$split = revision.id.split("#"),
      _revision$id$split2 = _slicedToArray(_revision$id$split, 1),
      uniqueId = _revision$id$split2[0];

  var _cache$readQuery2 = cache.readQuery(gqlParams),
      content = _cache$readQuery2.content;

  if (!content || !content.data) {
    return;
  }

  var index = content.data.findIndex(function (item) {
    return item.id.startsWith(uniqueId);
  });

  if (index === -1) {
    return;
  }

  cache.writeQuery(_objectSpread(_objectSpread({}, gqlParams), {}, {
    data: {
      content: dotProp.set(content, "data.".concat(index), revision)
    }
  }));
};
export var removeEntryFromListCache = function removeEntryFromListCache(model, cache, revision, variables) {
  // Delete the item from list cache
  var gqlParams = {
    query: GQL.createListQuery(model),
    variables: variables
  };

  var _cache$readQuery3 = cache.readQuery(gqlParams),
      content = _cache$readQuery3.content;

  if (!content || !content.data) {
    return;
  }

  var entryId = revision.id.split("#")[0];
  var index = content.data.findIndex(function (item) {
    return item.id.startsWith(entryId);
  });

  if (index === -1) {
    return;
  }

  cache.writeQuery(_objectSpread(_objectSpread({}, gqlParams), {}, {
    data: {
      content: dotProp.delete(content, "data.".concat(index))
    }
  }));
};
export var removeRevisionFromEntryCache = function removeRevisionFromEntryCache(model, cache, revision) {
  var gqlParams = {
    query: GQL.createRevisionsQuery(model),
    variables: {
      id: revision.id.split("#")[0]
    }
  };

  var _cache$readQuery4 = cache.readQuery(gqlParams),
      revisions = _cache$readQuery4.revisions;

  if (!revisions || !revisions.data) {
    return;
  }

  var index = revisions.data.findIndex(function (item) {
    return item.id === revision.id;
  });
  var newRevisions = dotProp.delete(revisions, "data.".concat(index));
  cache.writeQuery(_objectSpread(_objectSpread({}, gqlParams), {}, {
    data: {
      revisions: newRevisions
    }
  })); // Return new revisions

  return newRevisions.data;
};
export var addRevisionToRevisionsCache = function addRevisionToRevisionsCache(model, cache, revision) {
  var gqlParams = {
    query: GQL.createRevisionsQuery(model),
    variables: {
      id: revision.id.split("#")[0]
    }
  };

  var _cache$readQuery5 = cache.readQuery(gqlParams),
      revisions = _cache$readQuery5.revisions;

  if (!revisions || !revisions.data) {
    return;
  }

  cache.writeQuery(_objectSpread(_objectSpread({}, gqlParams), {}, {
    data: {
      revisions: dotProp.set(revisions, "data", [revision].concat(_toConsumableArray(revisions.data)))
    }
  }));
};
export var unpublishPreviouslyPublishedRevision = function unpublishPreviouslyPublishedRevision(model, cache, publishedId) {
  var gqlParams = {
    query: GQL.createRevisionsQuery(model),
    variables: {
      id: publishedId.split("#")[0]
    }
  };

  var _cache$readQuery6 = cache.readQuery(gqlParams),
      revisions = _cache$readQuery6.revisions;

  if (!revisions || !revisions.data) {
    return;
  }

  var prevPublished = revisions.data.findIndex(function (item) {
    return item.id !== publishedId && item.meta.status === "published";
  });

  if (prevPublished === -1) {
    return;
  }

  cache.writeQuery(_objectSpread(_objectSpread({}, gqlParams), {}, {
    data: {
      revisions: dotProp.set(revisions, "data.".concat(prevPublished, ".meta.status"), "unpublished")
    }
  }));
};
//# sourceMappingURL=cache.js.map