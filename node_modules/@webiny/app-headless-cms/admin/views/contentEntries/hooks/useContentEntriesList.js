import _toConsumableArray from "@babel/runtime/helpers/toConsumableArray";
import _objectSpread from "@babel/runtime/helpers/objectSpread2";
import _slicedToArray from "@babel/runtime/helpers/slicedToArray";
import { useCallback, useEffect, useMemo, useState } from "react";
import get from "lodash/get";
import set from "lodash/set";
import unset from "lodash/unset";
import cloneDeep from "lodash/cloneDeep";
import debounce from "lodash/debounce";
import { useRouter } from "@webiny/react-router";
import { createListQuery } from "../../../graphql/contentEntries";
import { useQuery } from "../../../hooks";
import { useContentEntries } from "./useContentEntries";
export function useContentEntriesList() {
  var _useContentEntries = useContentEntries(),
      contentModel = _useContentEntries.contentModel,
      listQueryVariables = _useContentEntries.listQueryVariables,
      setListQueryVariables = _useContentEntries.setListQueryVariables,
      sorters = _useContentEntries.sorters,
      canCreate = _useContentEntries.canCreate;

  var _useState = useState(false),
      _useState2 = _slicedToArray(_useState, 2),
      loadMoreLoading = _useState2[0],
      setLoadMoreLoading = _useState2[1];

  var _useState3 = useState(""),
      _useState4 = _slicedToArray(_useState3, 2),
      filter = _useState4[0],
      setFilter = _useState4[1];

  var _useRouter = useRouter(),
      history = _useRouter.history;

  var baseUrl = "/cms/content-entries/".concat(contentModel.modelId); // Get entry ID and search query (if any)

  var query = new URLSearchParams(location.search);
  var entryId = query.get("id");
  var searchQuery = query.get("search");
  var updateSearch = useCallback(debounce(function (_ref) {
    var filter = _ref.filter,
        query = _ref.query;
    var search = query.get("search");

    if (typeof search !== "string" && !filter) {
      return;
    } // We use the title field with the "contains" operator for doing basic searches.


    var searchField = contentModel.titleFieldId + "_contains";
    setListQueryVariables(function (prev) {
      var next = cloneDeep(prev);

      if (filter) {
        set(next, "where.".concat(searchField), filter);
      } else {
        unset(next, "where.".concat(searchField));
      }

      return next;
    });

    if (search !== filter) {
      query.set("search", filter);
      history.push("".concat(baseUrl, "?").concat(query.toString()));
    }
  }, 250), [baseUrl]); // Set "filter" from search "query" on page load.

  useEffect(function () {
    if (searchQuery) {
      setFilter(searchQuery);
    }
  }, [baseUrl, searchQuery]); // When filter changes, run GQL query

  useEffect(function () {
    return updateSearch({
      filter: filter,
      query: query
    });
  }, [baseUrl, filter]); // Generate a query based on current content model

  var LIST_QUERY = useMemo(function () {
    return createListQuery(contentModel);
  }, [contentModel.modelId]);

  var _useQuery = useQuery(LIST_QUERY, {
    variables: listQueryVariables
  }),
      data = _useQuery.data,
      loading = _useQuery.loading,
      fetchMore = _useQuery.fetchMore;

  var onCreate = useCallback(function () {
    history.push("/cms/content-entries/".concat(contentModel.modelId, "?new=true"));
  }, [contentModel]);
  var filterByStatus = useCallback(function (entries, status) {
    if (!status || status === "all") {
      return entries;
    }

    return entries.filter(function (item) {
      return item.meta.status === status;
    });
  }, []); // Load more entries on scroll

  var loadMore = useCallback(function () {
    var meta = get(data, "content.meta", {});

    if (meta.hasMoreItems) {
      setLoadMoreLoading(true);
      fetchMore({
        variables: {
          after: meta.cursor
        },
        updateQuery: function updateQuery(prev, _ref2) {
          var fetchMoreResult = _ref2.fetchMoreResult;

          if (!fetchMoreResult) {
            return prev;
          }

          var next = _objectSpread({}, fetchMoreResult);

          next.content.data = [].concat(_toConsumableArray(prev.content.data), _toConsumableArray(fetchMoreResult.content.data));
          setLoadMoreLoading(false);
          return next;
        }
      });
    }
  }, [data]);
  var editEntry = useCallback(function (entry) {
    return function () {
      history.push("/cms/content-entries/".concat(contentModel.modelId, "?id=").concat(encodeURIComponent(entry.id)));
    };
  }, [contentModel.modelId]);
  return {
    contentModel: contentModel,
    listQueryVariables: listQueryVariables,
    setListQueryVariables: setListQueryVariables,
    sorters: sorters,
    entryId: entryId,
    loading: loading,
    data: filterByStatus(get(data, "content.data", []), listQueryVariables.status),
    loadMore: loadMore,
    loadMoreLoading: loadMoreLoading,
    canCreate: canCreate,
    onCreate: onCreate,
    filter: filter,
    setFilter: setFilter,
    editEntry: editEntry
  };
}
//# sourceMappingURL=useContentEntriesList.js.map