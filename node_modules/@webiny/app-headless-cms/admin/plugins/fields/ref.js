import _asyncToGenerator from "@babel/runtime/helpers/asyncToGenerator";
import _taggedTemplateLiteral from "@babel/runtime/helpers/taggedTemplateLiteral";

var _templateObject, _templateObject2, _templateObject3, _templateObject4, _templateObject5;

import _regeneratorRuntime from "@babel/runtime/regenerator";
import React, { useCallback, useMemo } from "react";
import get from "lodash/get";
import { useQuery } from "../../hooks";
import { LIST_CONTENT_MODELS } from "../../viewsGraphql";
import { validation, ValidationError } from "@webiny/validation";
import { Cell, Grid } from "@webiny/ui/Grid";
import { MultiAutoComplete } from "@webiny/ui/AutoComplete";
import { CircularProgress } from "@webiny/ui/Progress";
import { useSnackbar } from "@webiny/app-admin/hooks/useSnackbar";
import { ReactComponent as RefIcon } from "@svgr/webpack!./icons/round-link-24px.svg";
import { i18n } from "@webiny/app/i18n";
var t = i18n.ns("app-headless-cms/admin/fields");
var plugin = {
  type: "cms-editor-field-type",
  name: "cms-editor-field-type-ref",
  field: {
    type: "ref",
    validators: [],
    label: t(_templateObject || (_templateObject = _taggedTemplateLiteral(["Reference"]))),
    description: t(_templateObject2 || (_templateObject2 = _taggedTemplateLiteral(["Reference existing content entries. For example, a book can reference one or more authors."]))),
    icon: /*#__PURE__*/React.createElement(RefIcon, null),
    allowMultipleValues: true,
    allowPredefinedValues: false,
    multipleValuesLabel: t(_templateObject3 || (_templateObject3 = _taggedTemplateLiteral(["Use as a list of references"]))),
    createField: function createField() {
      return {
        type: this.type,
        settings: {
          models: []
        },
        validation: [],
        renderer: {
          name: ""
        }
      };
    },
    renderSettings: function renderSettings(_ref) {
      var _ref$form = _ref.form,
          Bind = _ref$form.Bind,
          formData = _ref$form.data,
          contentModel = _ref.contentModel;
      var lockedFields = get(contentModel, "lockedFields", []);
      var fieldId = get(formData, "fieldId", null);
      var lockedField = lockedFields.find(function (lockedField) {
        return lockedField.fieldId === fieldId;
      });

      var _useQuery = useQuery(LIST_CONTENT_MODELS),
          data = _useQuery.data,
          loading = _useQuery.loading,
          error = _useQuery.error;

      var _useSnackbar = useSnackbar(),
          showSnackbar = _useSnackbar.showSnackbar;

      if (error) {
        showSnackbar(error.message);
        return null;
      } // Format options for the Autocomplete component.


      var options = useMemo(function () {
        return get(data, "listContentModels.data", []).map(function (model) {
          return {
            id: model.modelId,
            name: model.name
          };
        });
      }, [data]);
      var atLeastOneItem = useCallback( /*#__PURE__*/function () {
        var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(value) {
          return _regeneratorRuntime.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  _context.prev = 0;
                  _context.next = 3;
                  return validation.validate(value, "required,minLength:1");

                case 3:
                  _context.next = 8;
                  break;

                case 5:
                  _context.prev = 5;
                  _context.t0 = _context["catch"](0);
                  throw new ValidationError("Please select at least 1 item");

                case 8:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee, null, [[0, 5]]);
        }));

        return function (_x) {
          return _ref2.apply(this, arguments);
        };
      }(), []);
      return /*#__PURE__*/React.createElement(Grid, null, loading && /*#__PURE__*/React.createElement(CircularProgress, null), /*#__PURE__*/React.createElement(Cell, {
        span: 12
      }, /*#__PURE__*/React.createElement(Bind, {
        name: "settings.models",
        validators: atLeastOneItem
      }, function (bind) {
        // Format value prop for MultiAutoComplete component.
        var formattedValueForAutoComplete = options.filter(function (option) {
          return bind.value.some(function (_ref3) {
            var modelId = _ref3.modelId;
            return option.id === modelId;
          });
        });
        return /*#__PURE__*/React.createElement(MultiAutoComplete, Object.assign({}, bind, {
          value: formattedValueForAutoComplete,
          onChange: function onChange(values) {
            bind.onChange(values.map(function (value) {
              return {
                modelId: value.id
              };
            }));
          },
          label: t(_templateObject4 || (_templateObject4 = _taggedTemplateLiteral(["Content Models"]))),
          description: t(_templateObject5 || (_templateObject5 = _taggedTemplateLiteral(["Cannot be changed later"]))),
          options: options,
          disabled: lockedField && lockedField.modelId
        }));
      })));
    },
    graphql: {
      queryField:
      /* GraphQL */
      "\n                {\n                    modelId\n                    entryId\n                }\n            "
    }
  }
};
export default plugin;
//# sourceMappingURL=ref.js.map