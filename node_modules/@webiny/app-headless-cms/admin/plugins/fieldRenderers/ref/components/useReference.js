import _defineProperty from "@babel/runtime/helpers/defineProperty";
import _objectSpread from "@babel/runtime/helpers/objectSpread2";
import _asyncToGenerator from "@babel/runtime/helpers/asyncToGenerator";
import _slicedToArray from "@babel/runtime/helpers/slicedToArray";
import _regeneratorRuntime from "@babel/runtime/regenerator";
import { useCallback, useEffect, useMemo, useRef, useState } from "react";
import { useApolloClient } from "../../../../hooks";
import * as GQL from "./graphql";
import { getOptions } from "./getOptions";

var convertQueryDataToEntryList = function convertQueryDataToEntryList(data) {
  return data.reduce(function (collection, entry) {
    collection[entry.id] = entry;
    return collection;
  }, {});
};

var convertValueEntryToData = function convertValueEntryToData(entry) {
  return {
    id: entry.id,
    model: {
      modelId: entry.modelId,
      name: entry.modelName
    },
    status: entry.published ? "published" : "draft",
    title: entry.name
  };
};

var convertDataEntryToValue = function convertDataEntryToValue(entry) {
  return {
    id: entry.id,
    modelId: entry.model.modelId,
    modelName: entry.model.name,
    published: entry.status === "published",
    name: entry.title
  };
};

var assignValueEntry = function assignValueEntry(entry, collection) {
  if (!entry) {
    return;
  }

  collection[entry.id] = convertValueEntryToData(entry);
};

export var useReference = function useReference(_ref) {
  var bind = _ref.bind,
      field = _ref.field;
  var allEntries = useRef({});
  var client = useApolloClient();

  var _useState = useState(""),
      _useState2 = _slicedToArray(_useState, 2),
      search = _useState2[0],
      setSearch = _useState2[1];

  var _useState3 = useState(false),
      _useState4 = _slicedToArray(_useState3, 2),
      loading = _useState4[0],
      setLoading = _useState4[1];

  var _useState5 = useState({}),
      _useState6 = _slicedToArray(_useState5, 2),
      entries = _useState6[0],
      setEntries = _useState6[1];

  var _useState7 = useState({}),
      _useState8 = _slicedToArray(_useState7, 2),
      latestEntries = _useState8[0],
      setLatestEntries = _useState8[1];

  var _useState9 = useState(null),
      _useState10 = _slicedToArray(_useState9, 2),
      valueEntry = _useState10[0],
      setValueEntry = _useState10[1];

  var models = field.settings.models;
  var modelsHash = models.join(",");
  var value = bind.value;
  var valueHash = value ? value.id : null;

  var searchEntries = /*#__PURE__*/function () {
    var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {
      var _yield$client$query, data, searchEntries;

      return _regeneratorRuntime.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              if (search) {
                _context.next = 2;
                break;
              }

              return _context.abrupt("return");

            case 2:
              setLoading(true);
              _context.next = 5;
              return client.query({
                query: GQL.SEARCH_CONTENT_ENTRIES,
                variables: {
                  modelIds: models.map(function (m) {
                    return m.modelId;
                  }),
                  query: search
                }
              });

            case 5:
              _yield$client$query = _context.sent;
              data = _yield$client$query.data;
              setLoading(false);
              searchEntries = convertQueryDataToEntryList(data.content.data);
              assignValueEntry(valueEntry, searchEntries);
              Object.assign(allEntries.current, searchEntries);
              setEntries(searchEntries);

            case 12:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));

    return function searchEntries() {
      return _ref2.apply(this, arguments);
    };
  }();

  useEffect(function () {
    searchEntries();
  }, [search]);
  useEffect(function () {
    client.query({
      query: GQL.SEARCH_CONTENT_ENTRIES,
      variables: {
        modelIds: models.map(function (m) {
          return m.modelId;
        }),
        query: "__latest__",
        limit: 10
      }
    }).then(function (_ref3) {
      var data = _ref3.data;
      var latestEntryData = convertQueryDataToEntryList(data.content.data);
      assignValueEntry(valueEntry, latestEntryData);
      setLatestEntries(latestEntryData);
      Object.assign(allEntries.current, latestEntryData);
    });
  }, [modelsHash]);
  useEffect(function () {
    if (!value || !models) {
      setValueEntry(function () {
        return null;
      });
      return;
    }

    var entry = allEntries.current[valueHash];

    if (entry) {
      // if entry exists set valueEntry to that one so we do not load new one
      setValueEntry(function () {
        return convertDataEntryToValue(entry);
      });
      return;
    }

    setLoading(true);
    client.query({
      query: GQL.GET_CONTENT_ENTRY,
      variables: {
        entry: {
          modelId: value.modelId,
          entryId: value.entryId
        }
      }
    }).then(function (res) {
      setLoading(false);
      var dataEntry = res.data.content.data;

      if (!dataEntry) {
        return;
      }

      allEntries.current[dataEntry.id] = dataEntry;
      setLatestEntries(function (prev) {
        return _objectSpread(_objectSpread({}, prev), {}, _defineProperty({}, dataEntry.id, dataEntry));
      }); // Calculate a couple of props for the Autocomplete component.

      setValueEntry(function () {
        return convertDataEntryToValue(dataEntry);
      });
    });
  }, [valueHash, modelsHash]);
  var onChange = useCallback(function (value, entry) {
    if (value !== null) {
      setSearch("");
      setValueEntry(function () {
        return entry;
      });
      return bind.onChange({
        modelId: entry.modelId,
        entryId: entry.id
      });
    }

    setValueEntry(function () {
      return null;
    });
    bind.onChange(null);
  }, []); // Format options for the Autocomplete component.

  var options = useMemo(function () {
    return getOptions(Object.values(entries));
  }, [entries]); // Format default options for the Autocomplete component.

  var defaultOptions = useMemo(function () {
    return getOptions(Object.values(latestEntries));
  }, [latestEntries]);
  var outputOptions = search ? options : defaultOptions || [];

  if (valueEntry && outputOptions.some(function (opt) {
    return opt.id === valueEntry.id;
  }) === false) {
    outputOptions.push(valueEntry);
  }

  return {
    onChange: onChange,
    setSearch: setSearch,
    value: valueEntry,
    loading: loading,
    options: outputOptions
  };
};
//# sourceMappingURL=useReference.js.map