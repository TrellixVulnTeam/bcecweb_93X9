import _toConsumableArray from "@babel/runtime/helpers/toConsumableArray";
import _asyncToGenerator from "@babel/runtime/helpers/asyncToGenerator";
import _slicedToArray from "@babel/runtime/helpers/slicedToArray";
import _regeneratorRuntime from "@babel/runtime/regenerator";
import { useCallback, useEffect, useMemo, useRef, useState } from "react";
import { useApolloClient } from "../../../../hooks";
import * as GQL from "./graphql";
import { getOptions } from "./getOptions";

function distinctBy(key, array) {
  var keys = array.map(function (value) {
    return value[key];
  });
  return array.filter(function (value, index) {
    return keys.indexOf(value[key]) === index;
  });
}

export var useReferences = function useReferences(_ref) {
  var bind = _ref.bind,
      field = _ref.field;
  var allEntries = useRef([]);
  var client = useApolloClient();

  var _useState = useState(""),
      _useState2 = _slicedToArray(_useState, 2),
      search = _useState2[0],
      setSearch = _useState2[1];

  var _useState3 = useState(false),
      _useState4 = _slicedToArray(_useState3, 2),
      loading = _useState4[0],
      setLoading = _useState4[1];

  var _useState5 = useState([]),
      _useState6 = _slicedToArray(_useState5, 2),
      entries = _useState6[0],
      setEntries = _useState6[1];

  var _useState7 = useState([]),
      _useState8 = _slicedToArray(_useState7, 2),
      latestEntries = _useState8[0],
      setLatestEntries = _useState8[1];

  var _useState9 = useState([]),
      _useState10 = _slicedToArray(_useState9, 2),
      valueEntries = _useState10[0],
      setValueEntries = _useState10[1];

  var models = field.settings.models;
  var modelsHash = models.join(",");
  var values = bind.value ? bind.value : [];

  var searchEntries = /*#__PURE__*/function () {
    var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {
      var _yield$client$query, data;

      return _regeneratorRuntime.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              if (search) {
                _context.next = 2;
                break;
              }

              return _context.abrupt("return");

            case 2:
              setLoading(true);
              _context.next = 5;
              return client.query({
                query: GQL.SEARCH_CONTENT_ENTRIES,
                variables: {
                  modelIds: models.map(function (m) {
                    return m.modelId;
                  }),
                  query: search
                }
              });

            case 5:
              _yield$client$query = _context.sent;
              data = _yield$client$query.data;
              setLoading(false);
              allEntries.current = distinctBy("id", [].concat(_toConsumableArray(allEntries.current), _toConsumableArray(data.content.data)));
              setEntries(data.content.data);

            case 10:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));

    return function searchEntries() {
      return _ref2.apply(this, arguments);
    };
  }();

  useEffect(function () {
    searchEntries();
  }, [search]);
  useEffect(function () {
    client.query({
      query: GQL.SEARCH_CONTENT_ENTRIES,
      variables: {
        modelIds: models.map(function (m) {
          return m.modelId;
        }),
        query: "__latest__",
        limit: 10
      }
    }).then(function (_ref3) {
      var data = _ref3.data;
      setLatestEntries(data.content.data);
      allEntries.current = _toConsumableArray(data.content.data);
    });
  }, [modelsHash]);
  useEffect(function () {
    if (!values || !values.length) {
      return;
    }

    setLoading(true);
    client.query({
      query: GQL.GET_CONTENT_ENTRIES,
      variables: {
        entries: values
      }
    }).then(function (res) {
      setLoading(false);
      var entries = res.data.content.data; // Calculate a couple of props for the Autocomplete component.

      setValueEntries(entries.map(function (entry) {
        return {
          id: entry.id,
          modelId: entry.model.modelId,
          modelName: entry.model.name,
          published: entry.status === "published",
          name: entry.title
        };
      }));
    });
  }, []);
  /**
   * onChange callback will update internal component state using the previously loaded entries by IDs.
   * It will also format the value to store to the DB.
   */

  var onChange = useCallback(function (values) {
    setSearch("");
    setValueEntries(values); // Update parent form

    bind.onChange(values.map(function (item) {
      return {
        modelId: item.modelId,
        entryId: item.id
      };
    }));
  }, []); // Format options for the Autocomplete component.

  var options = useMemo(function () {
    return getOptions(entries);
  }, [entries]); // Format default options for the Autocomplete component.

  var defaultOptions = useMemo(function () {
    return getOptions(latestEntries);
  }, [latestEntries]);
  return {
    onChange: onChange,
    loading: loading,
    setSearch: setSearch,
    // Selected entries
    entries: valueEntries,
    // Options to show when the autocomplete dropdown is visible
    options: search ? options : defaultOptions || []
  };
};
//# sourceMappingURL=useReferences.js.map