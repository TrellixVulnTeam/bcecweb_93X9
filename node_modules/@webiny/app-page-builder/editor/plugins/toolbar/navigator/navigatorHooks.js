import _slicedToArray from "@babel/runtime/helpers/slicedToArray";
import { useRef, useState } from "react";
import { useRecoilValue } from "recoil";
import { useDrag, useDrop } from "react-dnd";
import { elementByIdSelector, rootElementAtom } from "../../../recoil/modules";
import { MoveBlockActionEvent } from "../../../recoil/actions";
import { useEventActionHandler } from "../../../hooks/useEventActionHandler";
export var BLOCK = "block";
export var useMoveBlock = function useMoveBlock(elementId) {
  var rootElementId = useRecoilValue(rootElementAtom);
  var rootElementValue = useRecoilValue(elementByIdSelector(rootElementId));
  var handler = useEventActionHandler();

  var moveBlock = function moveBlock(args) {
    handler.trigger(new MoveBlockActionEvent(args));
  };

  var move = function move(current, next) {
    moveBlock({
      source: {
        id: elementId,
        position: current,
        type: "block"
      },
      target: {
        id: rootElementValue.elements[next],
        position: next,
        type: "block"
      },
      rootElementId: rootElementId
    });
  };

  return {
    move: move
  };
};
export var useSortableList = function useSortableList(_ref) {
  var index = _ref.index,
      move = _ref.move,
      id = _ref.id,
      type = _ref.type,
      beginDrag = _ref.beginDrag,
      endDrag = _ref.endDrag;
  var ref = useRef(null);

  var _useState = useState(false),
      _useState2 = _slicedToArray(_useState, 2),
      dropItemAbove = _useState2[0],
      setDropItemAbove = _useState2[1];

  var isDraggingDownwardsRef = useRef(false);

  var _useDrop = useDrop({
    accept: BLOCK,
    collect: function collect(monitor) {
      return {
        handlerId: monitor.getHandlerId(),
        isOver: monitor.isOver() && monitor.isOver({
          shallow: true
        })
      };
    },
    drop: function drop(item) {
      if (!ref.current) {
        return;
      }

      var dragIndex = item.index;
      var dropIndex = index;
      var draggingDownwards = isDraggingDownwardsRef.current; // Calculate effective drop position.

      // Calculate effective drop position.
      var effectiveDropIndex;

      if (draggingDownwards) {
        effectiveDropIndex = dropItemAbove ? dropIndex - 1 : dropIndex;
      } else {
        effectiveDropIndex = dropItemAbove ? dropIndex : dropIndex + 1;
      } // Don't replace items with themselves.


      // Don't replace items with themselves.
      if (dragIndex === effectiveDropIndex) {
        return;
      } // Time to actually perform the action


      // Time to actually perform the action
      move(dragIndex, effectiveDropIndex); // Note: we're mutating the monitor item here!
      // Generally it's better to avoid mutations,
      // but it's good here for the sake of performance
      // to avoid expensive index searches.

      // Note: we're mutating the monitor item here!
      // Generally it's better to avoid mutations,
      // but it's good here for the sake of performance
      // to avoid expensive index searches.
      item.index = dropIndex;
    },
    hover: function hover(item, monitor) {
      var _ref$current;

      if (!ref.current) {
        return;
      }

      var dragIndex = item.index;
      var hoverIndex = index; // Don't replace items with themselves

      // Don't replace items with themselves
      if (dragIndex === hoverIndex) {
        return;
      } // Set dragging downwards


      // Set dragging downwards
      isDraggingDownwardsRef.current = dragIndex < hoverIndex; // Determine rectangle on screen

      // Determine rectangle on screen
      var hoverBoundingRect = (_ref$current = ref.current) === null || _ref$current === void 0 ? void 0 : _ref$current.getBoundingClientRect(); // Get vertical middle

      // Get vertical middle
      var hoverMiddleY = (hoverBoundingRect.bottom - hoverBoundingRect.top) / 2; // Determine mouse position

      // Determine mouse position
      var clientOffset = monitor.getClientOffset(); // Get pixels to the top

      // Get pixels to the top
      var hoverClientY = clientOffset.y - hoverBoundingRect.top; // Perform the "drop above" move, only when the cursor is above 50% of the item's height.

      // Perform the "drop above" move, only when the cursor is above 50% of the item's height.
      var dropAbove = hoverClientY < hoverMiddleY;
      setDropItemAbove(dropAbove);
    },
    canDrop: function canDrop() {
      return type === BLOCK;
    }
  }),
      _useDrop2 = _slicedToArray(_useDrop, 2),
      _useDrop2$ = _useDrop2[0],
      handlerId = _useDrop2$.handlerId,
      isOver = _useDrop2$.isOver,
      drop = _useDrop2[1];

  var _useDrag = useDrag({
    item: {
      type: type,
      target: [BLOCK],
      id: id,
      index: index,
      dragInNavigator: true
    },
    collect: function collect(monitor) {
      return {
        isDragging: monitor.isDragging()
      };
    },
    begin: function begin(monitor) {
      if (typeof beginDrag === "function") {
        return beginDrag(monitor);
      }
    },
    end: function end(item, monitor) {
      if (typeof endDrag === "function") {
        return endDrag(item, monitor);
      }
    },
    canDrag: type === BLOCK
  }),
      _useDrag2 = _slicedToArray(_useDrag, 3),
      isDragging = _useDrag2[0].isDragging,
      drag = _useDrag2[1],
      preview = _useDrag2[2];

  drag(drop(ref));
  return {
    ref: ref,
    isDragging: isDragging,
    handlerId: handlerId,
    drag: drag,
    drop: drop,
    preview: preview,
    isOver: isOver,
    dropItemAbove: dropItemAbove
  };
};
//# sourceMappingURL=navigatorHooks.js.map