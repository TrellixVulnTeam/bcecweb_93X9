import _objectSpread from "@babel/runtime/helpers/objectSpread2";
import _slicedToArray from "@babel/runtime/helpers/slicedToArray";
import _objectWithoutProperties from "@babel/runtime/helpers/objectWithoutProperties";
var _excluded = ["children"];
import React, { useEffect, useState } from "react";

var emptyFunction = function emptyFunction() {
  return undefined;
};
/**
 * This component is used to wrap Input and Textarea components to optimize form re-render.
 * These 2 are the only components that trigger form model change on each character input.
 * This means, whenever you type a letter an entire form re-renders.
 * On complex forms you will feel and see a significant delay if this component is not used.
 *
 * The logic behind this component is to serve as a middleware between Form and Input/Textarea, and only notify form of a change when
 * a user stops typing for given period of time (400ms by default).
 */


export var DelayedOnChange = function DelayedOnChange(_ref) {
  var children = _ref.children,
      other = _objectWithoutProperties(_ref, _excluded);

  var onChange = other.onChange,
      _other$delay = other.delay,
      delay = _other$delay === void 0 ? 400 : _other$delay,
      initialValue = other.value;

  var _useState = useState(initialValue),
      _useState2 = _slicedToArray(_useState, 2),
      value = _useState2[0],
      setValue = _useState2[1]; // Sync state and props


  useEffect(function () {
    if (initialValue !== value) {
      setValue(initialValue);
    }
  }, [initialValue]);
  var localTimeout = React.useRef(undefined);

  var applyValue = function applyValue(value) {
    var callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : emptyFunction;
    localTimeout.current && clearTimeout(localTimeout.current);
    localTimeout.current = null;
    onChange(value, callback);
  };

  var onChangeLocal = React.useCallback(function (value) {
    setValue(value);
  }, []); // this is fired upon change value state

  var onValueStateChanged = function onValueStateChanged(nextValue) {
    localTimeout.current && clearTimeout(localTimeout.current);
    localTimeout.current = null;
    localTimeout.current = setTimeout(function () {
      return applyValue(nextValue);
    }, delay);
  }; // need to clear the timeout when unmounting the component


  useEffect(function () {
    return function () {
      if (!localTimeout.current) {
        return;
      }

      clearTimeout(localTimeout.current);
      localTimeout.current = null;
    };
  }, []);
  useEffect(function () {
    onValueStateChanged(value);
  }, [value]);

  var newProps = _objectSpread(_objectSpread({}, other), {}, {
    value: value,
    onChange: onChangeLocal
  });

  var renderProp = typeof children === "function" ? children : false;
  var child = renderProp ? renderProp(newProps) : /*#__PURE__*/React.cloneElement(children, newProps);

  var props = _objectSpread({}, child.props);

  var realOnKeyDown = props.onKeyDown || emptyFunction;
  var realOnBlur = props.onBlur || emptyFunction; // Need to apply value if input lost focus

  var onBlur = function onBlur(e) {
    e.persist();
    applyValue(e.target.value, function () {
      return realOnBlur(e);
    });
  }; // Need to listen for TAB key to apply new value immediately, without delay. Otherwise validation will be triggered with old value.


  var onKeyDown = function onKeyDown(e) {
    e.persist();

    if (e.key === "Tab") {
      applyValue(e.target.value, function () {
        return realOnKeyDown(e);
      });
    } else if (e.key === "Enter" && props["data-on-enter"]) {
      applyValue(e.target.value, function () {
        return realOnKeyDown(e);
      });
    } else {
      realOnKeyDown(e);
    }
  };

  return /*#__PURE__*/React.cloneElement(child, _objectSpread(_objectSpread({}, props), {}, {
    onBlur: onBlur,
    onKeyDown: onKeyDown
  }));
};
export default DelayedOnChange;
//# sourceMappingURL=DelayedOnChange.js.map