{"version":3,"sources":["../../../../src/editor/components/Editor/DragPreview.tsx"],"names":["React","useEffect","useState","useDragLayer","layerStyles","position","pointerEvents","zIndex","left","top","width","height","subscribedToOffsetChange","dragPreviewRef","onOffsetChange","monitor","offset","getClientOffset","transform","x","y","style","DragPreview","dragHelperOpacity","setDragHelperOpacity","subscribeToOffsetChange","isDragging","item","getItem","setTimeout","dragInNavigator","el","display","opacity","transition","backgroundColor","borderRadius"],"mappings":"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","sourcesContent":["import React, { useEffect, useState } from \"react\";\nimport { DragLayerMonitor, useDragLayer } from \"react-dnd\";\n\nconst layerStyles: React.CSSProperties = {\n    position: \"fixed\",\n    pointerEvents: \"none\",\n    zIndex: 100,\n    left: 0,\n    top: 0,\n    width: \"100%\",\n    height: \"100%\"\n};\n\nlet subscribedToOffsetChange = false;\nlet dragPreviewRef = null;\n\nconst onOffsetChange = monitor => () => {\n    if (!dragPreviewRef) {\n        return;\n    }\n\n    const offset = monitor.getClientOffset();\n    if (!offset) {\n        return;\n    }\n\n    const transform = `translate(${offset.x - 15}px, ${offset.y - 15}px)`;\n    dragPreviewRef.style[\"transform\"] = transform;\n    dragPreviewRef.style[\"-webkit-transform\"] = transform;\n};\n\nconst DragPreview = () => {\n    const [dragHelperOpacity, setDragHelperOpacity] = useState(0);\n\n    const { isDragging, item } = useDragLayer((monitor: DragLayerMonitor) => {\n        if (!subscribedToOffsetChange) {\n            // @ts-ignore\n            monitor.subscribeToOffsetChange(onOffsetChange(monitor));\n            subscribedToOffsetChange = true;\n        }\n\n        return {\n            isDragging: monitor.isDragging(),\n            item: monitor.getItem()\n        };\n    });\n\n    useEffect(() => {\n        return () => {\n            subscribedToOffsetChange = false;\n            dragPreviewRef = null;\n        };\n    }, []);\n\n    // We track the value of \"isDragging\" and apply opacity=1 (after 100ms), when it switches to true.\n    // Without this, the drag cursor would be shown in the top-left corner for a short amount of time, and then it\n    // would be repositioned correctly. Definitely looks like a glitch. This also adds a nice little fade-in effect.\n    useEffect(() => {\n        if (isDragging) {\n            setTimeout(() => {\n                setDragHelperOpacity(isDragging ? 1 : 0);\n            }, 100);\n        } else {\n            setDragHelperOpacity(0);\n        }\n    }, [isDragging]);\n\n    if (!isDragging) {\n        return null;\n    }\n    // We don't want to show the drag preview for items being drag in the navigator.\n    if (item && item.dragInNavigator) {\n        return null;\n    }\n\n    return (\n        <div style={layerStyles}>\n            <div\n                ref={el => (dragPreviewRef = el)}\n                style={{\n                    display: \"block\",\n                    opacity: dragHelperOpacity,\n                    transition: \"opacity .25s ease-in-out\"\n                }}\n            >\n                <div\n                    style={{\n                        width: 30,\n                        height: 30,\n                        backgroundColor: \"var(--mdc-theme-primary)\",\n                        borderRadius: \"50%\"\n                    }}\n                />\n            </div>\n        </div>\n    );\n};\n\nexport default DragPreview;\n"],"file":"DragPreview.js"}