import _asyncToGenerator from "@babel/runtime/helpers/asyncToGenerator";
import _objectSpread from "@babel/runtime/helpers/objectSpread2";
import _slicedToArray from "@babel/runtime/helpers/slicedToArray";
import _regeneratorRuntime from "@babel/runtime/regenerator";
import React, { useEffect, useReducer } from "react";
import { plugins } from "@webiny/plugins";
import { CircularProgress } from "@webiny/ui/Progress";
var globalState = {
  render: false,
  editor: false
}; // Since these plugins are loaded asynchronously, and some overrides might've been registered
// already by the developer (e.g. in the main App.tsx file), we only register new plugins.
// In other words, if the plugin with a particular name already exists, we skip its registration.

export function EditorPluginsLoader(_ref) {
  var children = _ref.children,
      location = _ref.location;

  var _useReducer = useReducer(function (state, newState) {
    return _objectSpread(_objectSpread({}, state), newState);
  }, globalState),
      _useReducer2 = _slicedToArray(_useReducer, 2),
      loaded = _useReducer2[0],
      setLoaded = _useReducer2[1];

  function loadPlugins() {
    return _loadPlugins.apply(this, arguments);
  }

  function _loadPlugins() {
    _loadPlugins = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {
      var _plugins$byType, _plugins$byType2, _plugins$byType2$, loadEditorPlugins, loadRenderPlugins, renderPlugins, editorPlugins;

      return _regeneratorRuntime.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              _plugins$byType = plugins.byType("pb-plugins-loader"), _plugins$byType2 = _slicedToArray(_plugins$byType, 1), _plugins$byType2$ = _plugins$byType2[0], loadEditorPlugins = _plugins$byType2$.loadEditorPlugins, loadRenderPlugins = _plugins$byType2$.loadRenderPlugins; // If we are on pages list route, import plugins required to render the page content.

              if (!(location.pathname.startsWith("/page-builder/pages") && !loaded.render)) {
                _context.next = 8;
                break;
              }

              _context.next = 4;
              return loadRenderPlugins();

            case 4:
              renderPlugins = _context.sent;
              // "skipExisting" will ensure existing plugins (with the same name) are not overridden.
              plugins.register(renderPlugins, {
                skipExisting: true
              });
              globalState.render = true;
              setLoaded({
                render: true
              });

            case 8:
              if (!(location.pathname.startsWith("/page-builder/editor") && !loaded.editor)) {
                _context.next = 16;
                break;
              }

              _context.next = 11;
              return Promise.all([loadEditorPlugins(), !loaded.render ? loadRenderPlugins() : null].filter(Boolean));

            case 11:
              editorPlugins = _context.sent;
              // "skipExisting" will ensure existing plugins (with the same name) are not overridden.
              plugins.register(editorPlugins, {
                skipExisting: true
              });
              globalState.editor = true;
              globalState.render = true;
              setLoaded({
                editor: true,
                render: true
              });

            case 16:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));
    return _loadPlugins.apply(this, arguments);
  }

  useEffect(function () {
    loadPlugins();
  }, []);

  if (location.pathname.startsWith("/page-builder/pages") && loaded.render) {
    return children;
  }

  if (location.pathname.startsWith("/page-builder/editor") && loaded.editor) {
    return children;
  }

  return /*#__PURE__*/React.createElement(CircularProgress, null);
}
//# sourceMappingURL=EditorPluginsLoader.js.map