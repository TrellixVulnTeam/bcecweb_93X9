import _toConsumableArray from "@babel/runtime/helpers/toConsumableArray";
import _objectSpread from "@babel/runtime/helpers/objectSpread2";
import _slicedToArray from "@babel/runtime/helpers/slicedToArray";
import dotProp from "dot-prop-immutable";
import orderBy from "lodash/orderBy";
import get from "lodash/get";
import * as GQL from "../../graphql/pages";
export var readPageListVariables = function readPageListVariables() {
  var variables;

  try {
    variables = JSON.parse(localStorage.getItem("wby_pb_pages_list_latest_variables"));
  } catch (_unused) {}

  return variables;
};
export var writePageListVariablesToLocalStorage = function writePageListVariablesToLocalStorage(variables) {
  // Needs to be refactored. Possibly, with our own GQL client, this is going to be much easier to handle.
  localStorage.setItem("wby_pb_pages_list_latest_variables", JSON.stringify(variables));
};

var extractVariables = function extractVariables(key) {
  // TODO: Find a better way to parse the query/id from cache
  var variables = key.replace("$ROOT_QUERY.pageBuilder.listPages(", "").replace(")", "");
  return JSON.parse(variables);
};

var modifyCacheForAllListPagesQuery = function modifyCacheForAllListPagesQuery(cache, operation) {
  var existingQueriesInCache = Object.keys(cache.data.data).filter(function (key) {
    return key.includes(".listPages") && !key.endsWith(".meta");
  });
  existingQueriesInCache.forEach(function (cacheKey) {
    var variables = extractVariables(cacheKey);
    operation(variables);
  });
};
/*
 * We need to preserve the order of entries with new entry addition
 * because we're not re-fetching the list but updating it directly inside cache.
 * */


var sortEntries = function sortEntries(list, sort) {
  if (!sort || typeof sort !== "object") {
    return list;
  }

  var _Object$keys = Object.keys(sort),
      _Object$keys2 = _slicedToArray(_Object$keys, 1),
      key = _Object$keys2[0];

  var value = sort[key];
  var order = value.toLowerCase();
  return orderBy(list, [key], [order]);
};

export var addPageToListCache = function addPageToListCache(cache, page) {
  modifyCacheForAllListPagesQuery(cache, function (variables) {
    var gqlParams = {
      query: GQL.LIST_PAGES,
      variables: variables
    };
    var data = cache.readQuery(gqlParams);
    var listPagesData = get(data, "pageBuilder.listPages.data");

    if (!listPagesData) {
      return;
    }

    cache.writeQuery(_objectSpread(_objectSpread({}, gqlParams), {}, {
      data: dotProp.set(data, "pageBuilder.listPages.data", sortEntries([page].concat(_toConsumableArray(listPagesData)), variables.sort))
    }));
  });
};
export var updateLatestRevisionInListCache = function updateLatestRevisionInListCache(cache, revision) {
  modifyCacheForAllListPagesQuery(cache, function (variables) {
    var gqlParams = {
      query: GQL.LIST_PAGES,
      variables: variables
    };
    var data = cache.readQuery(gqlParams);
    var listPagesData = get(data, "pageBuilder.listPages.data");

    if (!listPagesData) {
      return;
    }

    var _revision$id$split = revision.id.split("#"),
        _revision$id$split2 = _slicedToArray(_revision$id$split, 1),
        uniqueId = _revision$id$split2[0];

    var index = listPagesData.findIndex(function (item) {
      return item.id.startsWith(uniqueId);
    });

    if (index === -1) {
      return;
    }

    cache.writeQuery(_objectSpread(_objectSpread({}, gqlParams), {}, {
      data: dotProp.set(data, "pageBuilder.listPages.data.".concat(index), revision)
    }));
  });
};
export var removePageFromListCache = function removePageFromListCache(cache, page) {
  // Delete the item from list cache
  modifyCacheForAllListPagesQuery(cache, function (variables) {
    var gqlParams = {
      query: GQL.LIST_PAGES,
      variables: variables
    };
    var data = cache.readQuery(gqlParams);
    var listPagesData = get(data, "pageBuilder.listPages.data");

    if (!listPagesData) {
      return;
    }

    var _page$id$split = page.id.split("#"),
        _page$id$split2 = _slicedToArray(_page$id$split, 1),
        uniqueId = _page$id$split2[0];

    var index = listPagesData.findIndex(function (item) {
      return item.id.startsWith(uniqueId);
    });

    if (index === -1) {
      return;
    }

    cache.writeQuery(_objectSpread(_objectSpread({}, gqlParams), {}, {
      data: dotProp.delete(data, "pageBuilder.listPages.data.".concat(index))
    }));
  });
};
export var removeRevisionFromEntryCache = function removeRevisionFromEntryCache(cache, revision) {
  var gqlParams = {
    query: GQL.GET_PAGE,
    variables: {
      id: revision.id
    }
  };
  var data = cache.readQuery(gqlParams);
  var revisions = get(data, "pageBuilder.getPage.data.revisions");

  if (!revisions) {
    return;
  }

  var index = revisions.findIndex(function (item) {
    return item.id === revision.id;
  });
  var newRevisions = dotProp.delete(revisions, index);
  cache.writeQuery(_objectSpread(_objectSpread({}, gqlParams), {}, {
    data: dotProp.set(data, "pageBuilder.getPage.data.revisions", newRevisions)
  })); // Return new revisions

  return newRevisions;
};
//# sourceMappingURL=cache.js.map