import _asyncToGenerator from "@babel/runtime/helpers/asyncToGenerator";
import _regeneratorRuntime from "@babel/runtime/regenerator";
import React from "react";
import { set } from "dot-prop-immutable";
import { useApolloClient } from "@apollo/react-hooks";
import { useSnackbar } from "@webiny/app-admin/hooks/useSnackbar";
import { PUBLISH_PAGE, UNPUBLISH_PAGE, GET_PAGE } from "../../../graphql/pages";
export function usePublishRevisionHandler(_ref) {
  var page = _ref.page;
  var client = useApolloClient();

  var _useSnackbar = useSnackbar(),
      showSnackbar = _useSnackbar.showSnackbar;

  var publishRevision = /*#__PURE__*/function () {
    var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(revision) {
      var _yield$client$mutate, res, error;

      return _regeneratorRuntime.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              _context.next = 2;
              return client.mutate({
                mutation: PUBLISH_PAGE,
                variables: {
                  id: revision.id
                },
                update: function update(cache, _ref3) {
                  var data = _ref3.data;

                  // Don't do anything if there was an error during publishing!
                  if (data.pageBuilder.publishPage.error) {
                    return;
                  } // Update revisions


                  // Update revisions
                  var pageFromCache = cache.readQuery({
                    query: GET_PAGE,
                    variables: {
                      id: page.id
                    }
                  });
                  page.revisions.forEach(function (r) {
                    // Update published/locked fields on the revision that was just published.
                    if (r.id === revision.id) {
                      r.status = "published";
                      r.locked = true;
                      return;
                    } // Unpublish other published revisions


                    // Unpublish other published revisions
                    if (r.status === "published") {
                      r.status = "unpublished";
                    }
                  }); // Write our data back to the cache.

                  // Write our data back to the cache.
                  cache.writeQuery({
                    query: GET_PAGE,
                    data: set(pageFromCache, "pageBuilder.getPage.data", page)
                  });
                }
              });

            case 2:
              _yield$client$mutate = _context.sent;
              res = _yield$client$mutate.data;
              error = res.pageBuilder.publishPage.error;

              if (!error) {
                _context.next = 7;
                break;
              }

              return _context.abrupt("return", showSnackbar(error.message));

            case 7:
              showSnackbar( /*#__PURE__*/React.createElement("span", null, "Successfully published revision ", /*#__PURE__*/React.createElement("strong", null, "#", revision.version), "!"));

            case 8:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));

    return function publishRevision(_x) {
      return _ref2.apply(this, arguments);
    };
  }();

  var unpublishRevision = /*#__PURE__*/function () {
    var _ref4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(revision) {
      var _yield$client$mutate2, res, error;

      return _regeneratorRuntime.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              _context2.next = 2;
              return client.mutate({
                mutation: UNPUBLISH_PAGE,
                variables: {
                  id: revision.id
                },
                update: function update(cache, _ref5) {
                  var data = _ref5.data;

                  // Don't do anything if there was an error during publishing!
                  if (data.pageBuilder.unpublishPage.error) {
                    return;
                  } // Update revisions


                  // Update revisions
                  var pageFromCache = cache.readQuery({
                    query: GET_PAGE,
                    variables: {
                      id: page.id
                    }
                  });
                  page.revisions.forEach(function (r) {
                    // Update published/locked fields on the revision that was just published.
                    if (r.id === revision.id) {
                      r.status = "unpublished";
                      r.locked = true;
                      return;
                    }
                  }); // Write our data back to the cache.

                  // Write our data back to the cache.
                  cache.writeQuery({
                    query: GET_PAGE,
                    data: set(pageFromCache, "pageBuilder.getPage.data", page)
                  });
                }
              });

            case 2:
              _yield$client$mutate2 = _context2.sent;
              res = _yield$client$mutate2.data;
              error = res.pageBuilder.unpublishPage.error;

              if (!error) {
                _context2.next = 7;
                break;
              }

              return _context2.abrupt("return", showSnackbar(error.message));

            case 7:
              showSnackbar( /*#__PURE__*/React.createElement("span", null, "Successfully unpublished revision ", /*#__PURE__*/React.createElement("strong", null, "#", revision.version), "!"));

            case 8:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2);
    }));

    return function unpublishRevision(_x2) {
      return _ref4.apply(this, arguments);
    };
  }();

  return {
    publishRevision: publishRevision,
    unpublishRevision: unpublishRevision
  };
}
//# sourceMappingURL=usePublishRevisionHandler.js.map