"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _md = _interopRequireDefault(require("md5"));

var _responses = require("@webiny/handler-graphql/responses");

var _GraphQLSchemaPlugin = require("@webiny/handler-graphql/plugins/GraphQLSchemaPlugin");

var _apiSecurity = require("@webiny/api-security");

const gravatar = user => {
  return "https://www.gravatar.com/avatar/" + (0, _md.default)(user.login);
};

var _default = new _GraphQLSchemaPlugin.GraphQLSchemaPlugin({
  typeDefs:
  /* GraphQL */
  `
        type TenantAccess {
            """
            Tenant ID
            """
            id: ID

            """
            Tenant name
            """
            name: String

            """
            Tenant permissions
            """
            permissions: [JSON]
        }

        type SecurityIdentity {
            login: String
            access: [TenantAccess]
            firstName: String
            lastName: String
            avatar: JSON
            gravatar: String
        }

        type SecurityUserGroup {
            name: String
            slug: String
        }

        type SecurityUser {
            login: String
            firstName: String
            lastName: String
            avatar: JSON
            gravatar: String
            createdOn: DateTime
            """
            The group this user belongs to within current tenant.
            """
            group: SecurityUserGroup
        }

        """
        This input type is used by administrators to create other user's accounts within the same tenant.
        """
        input SecurityUserCreateInput {
            login: String!
            firstName: String!
            lastName: String!
            avatar: JSON
            group: String!
        }

        """
        This input type is used by administrators to update other user's accounts within the same tenant.
        """
        input SecurityUserUpdateInput {
            firstName: String
            lastName: String
            avatar: JSON
            group: String
        }

        """
        This input type is used by the user who is updating his own account
        """
        input SecurityCurrentUserInput {
            firstName: String
            lastName: String
            avatar: JSON
        }

        type SecurityUserResponse {
            data: SecurityUser
            error: SecurityError
        }

        type SecurityUserListResponse {
            data: [SecurityUser]
            error: SecurityError
        }

        type SecurityIdentityLoginResponse {
            data: SecurityIdentity
            error: SecurityError
        }

        extend type SecurityQuery {
            "Get a single user by id or specific search criteria"
            getUser(login: String): SecurityUserResponse

            "Get current user"
            getCurrentUser: SecurityUserResponse

            "Get a list of users"
            listUsers: SecurityUserListResponse
        }

        extend type SecurityMutation {
            "Login using idToken obtained from a 3rd party identity provider"
            login: SecurityIdentityLoginResponse

            "Update current user"
            updateCurrentUser(data: SecurityCurrentUserInput!): SecurityUserResponse

            createUser(data: SecurityUserCreateInput!): SecurityUserResponse

            updateUser(login: String!, data: SecurityUserUpdateInput!): SecurityUserResponse

            deleteUser(login: String!): SecurityBooleanResponse
        }
    `,
  resolvers: {
    SecurityUser: {
      gravatar,

      async avatar(user) {
        return user.avatar;
      },

      async group(user, args, {
        security,
        tenancy
      }) {
        const tenant = tenancy.getCurrentTenant();
        const allPermissions = await security.users.getUserAccess(user.login);
        const tenantAccess = allPermissions.find(p => p.tenant.id === tenant.id);

        if (tenantAccess) {
          return {
            slug: tenantAccess.group.slug,
            name: tenantAccess.group.name
          };
        }

        return null;
      }

    },
    SecurityIdentity: {
      gravatar,
      login: (_, args, context) => {
        return context.security.getIdentity().id;
      },

      async avatar(user) {
        return user.avatar;
      },

      async access(user, args, context) {
        const access = await context.security.users.getUserAccess(user.login);
        return access.map(item => ({
          id: item.tenant.id,
          name: item.tenant.name,
          permissions: item.group.permissions
        }));
      }

    },
    SecurityQuery: {
      getUser: async (_, args, context) => {
        const {
          login
        } = args;

        try {
          const user = await context.security.users.getUser(login);

          if (!user) {
            return new _responses.NotFoundResponse(`User "${login}" was not found!`);
          }

          return new _responses.Response(user);
        } catch (e) {
          return new _responses.ErrorResponse(e);
        }
      },
      getCurrentUser: async (_, args, context) => {
        const identity = context.security.getIdentity();

        if (!identity) {
          throw new _apiSecurity.NotAuthorizedError();
        }

        const user = await context.security.users.getUser(identity.id, {
          auth: false
        });

        if (!user) {
          return new _responses.NotFoundResponse(`User with ID ${identity.id} was not found!`);
        }

        return new _responses.Response(user);
      },
      listUsers: async (_, args, context) => {
        try {
          const userList = await context.security.users.listUsers();
          return new _responses.ListResponse(userList);
        } catch (e) {
          return new _responses.ListErrorResponse(e);
        }
      }
    },
    SecurityMutation: {
      login: async (root, args, context) => {
        try {
          const user = await context.security.users.login();
          return new _responses.Response(user);
        } catch (e) {
          return new _responses.ErrorResponse(e);
        }
      },
      updateCurrentUser: async (_, args, context) => {
        const {
          security
        } = context;
        const identity = security.getIdentity();

        if (!identity) {
          throw new Error("Not authorized!");
        }

        let user = await security.users.getUser(identity.id);

        if (!user) {
          return new _responses.NotFoundResponse("User not found!");
        }

        try {
          user = await security.users.updateUser(user.login, args.data);
          return new _responses.Response(user);
        } catch (e) {
          return new _responses.ErrorResponse(e);
        }
      },
      createUser: async (_, {
        data
      }, context) => {
        try {
          const user = await context.security.users.createUser(data);
          return new _responses.Response(user);
        } catch (e) {
          return new _responses.ErrorResponse(e);
        }
      },
      updateUser: async (root, {
        data,
        login
      }, {
        security
      }) => {
        try {
          const user = await security.users.updateUser(login, data);
          return new _responses.Response(user);
        } catch (e) {
          return new _responses.ErrorResponse(e);
        }
      },
      deleteUser: async (root, {
        login
      }, context) => {
        try {
          await context.security.users.deleteUser(login);
          return new _responses.Response(true);
        } catch (e) {
          return new _responses.ErrorResponse(e);
        }
      }
    }
  }
});

exports.default = _default;
//# sourceMappingURL=user.gql.js.map