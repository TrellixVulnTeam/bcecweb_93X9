"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _commodoFieldsObject = require("commodo-fields-object");

var _fields = require("@commodo/fields");

var _validation = require("@webiny/validation");

var _error = _interopRequireDefault(require("@webiny/error"));

var _ContextPlugin = require("@webiny/handler/plugins/ContextPlugin");

var _GroupsStorageOperationsProvider = require("../plugins/GroupsStorageOperationsProvider");

var _handlerGraphql = require("@webiny/handler-graphql");

var _apiSecurity = require("@webiny/api-security");

var _deepEqual = _interopRequireDefault(require("deep-equal"));

var _storageOperations = require("./storageOperations");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

const CreateDataModel = (0, _fields.withFields)({
  tenant: (0, _fields.string)({
    validation: _validation.validation.create("required")
  }),
  name: (0, _fields.string)({
    validation: _validation.validation.create("required,minLength:3")
  }),
  slug: (0, _fields.string)({
    validation: _validation.validation.create("required,minLength:3")
  }),
  description: (0, _fields.string)({
    validation: _validation.validation.create("maxLength:500")
  }),
  permissions: (0, _commodoFieldsObject.object)({
    list: true,
    validation: _validation.validation.create("required")
  })
})();
const UpdateDataModel = (0, _fields.withFields)({
  name: (0, _fields.string)({
    validation: _validation.validation.create("minLength:3")
  }),
  description: (0, _fields.string)({
    validation: _validation.validation.create("maxLength:500")
  }),
  permissions: (0, _commodoFieldsObject.object)({
    list: true
  })
})();

var _default = new _ContextPlugin.ContextPlugin(async context => {
  const storageOperations = await (0, _storageOperations.getStorageOperations)(context, _GroupsStorageOperationsProvider.GroupsStorageOperationsProvider.type);

  const checkPermission = async options => {
    if (options && options.auth === false) {
      return;
    }

    const permission = await context.security.getPermission("security.group");

    if (!permission) {
      throw new _apiSecurity.NotAuthorizedError();
    }
  };

  context.security.groups = {
    async getGroup(slug, options) {
      await checkPermission(options);
      const tenant = context.tenancy.getCurrentTenant();
      let group = null;

      try {
        group = await storageOperations.get(tenant, {
          slug
        });
      } catch (ex) {
        throw new _error.default(ex.message || "Could not get group.", ex.code || "GET_GROUP_ERROR", {
          slug
        });
      }

      if (!group) {
        throw new _handlerGraphql.NotFoundError(`Unable to find group with slug: ${slug}`);
      }

      return group;
    },

    async listGroups(options) {
      await checkPermission(options);
      const tenant = context.tenancy.getCurrentTenant();

      try {
        return await storageOperations.list(tenant, {
          sort: ["createdOn_ASC"]
        });
      } catch (ex) {
        throw new _error.default(ex.message || "Could not list API keys.", ex.code || "LIST_API_KEY_ERROR");
      }
    },

    async createGroup(input, options) {
      await checkPermission(options);
      const identity = context.security.getIdentity();
      const tenant = context.tenancy.getCurrentTenant();
      await new CreateDataModel().populate(_objectSpread(_objectSpread({}, input), {}, {
        tenant: tenant.id
      })).validate();
      const existing = await storageOperations.get(tenant, {
        slug: input.slug
      });

      if (existing) {
        throw new _error.default(`Group with slug "${input.slug}" already exists.`, "GROUP_EXISTS");
      }

      const group = _objectSpread(_objectSpread({
        tenant: tenant.id,
        system: false
      }, input), {}, {
        createdOn: new Date().toISOString(),
        createdBy: identity ? {
          id: identity.id,
          displayName: identity.displayName,
          type: identity.type
        } : null
      });

      try {
        return await storageOperations.create(tenant, {
          group
        });
      } catch (ex) {
        throw new _error.default(ex.message || "Could not create group.", ex.code || "CREATE_GROUP_ERROR", {
          group
        });
      }
    },

    async updateGroup(slug, input) {
      await checkPermission();
      const tenant = context.tenancy.getCurrentTenant();
      const model = await new UpdateDataModel().populate(input);
      await model.validate();
      const original = await storageOperations.get(tenant, {
        slug
      });

      if (!original) {
        throw new _handlerGraphql.NotFoundError(`Group "${slug}" was not found!`);
      }

      const data = await model.toJSON({
        onlyDirty: true
      });
      const permissionsChanged = !(0, _deepEqual.default)(data.permissions, original.permissions);

      const group = _objectSpread(_objectSpread({}, original), data);

      try {
        const result = await storageOperations.update(tenant, {
          original,
          group
        });

        if (permissionsChanged) {
          await storageOperations.updateUserLinks(tenant, {
            group: result
          });
        }

        return result;
      } catch (ex) {
        throw new _error.default(ex.message || "Could not update group.", ex.code || "UPDATE_GROUP_ERROR", {
          group
        });
      }
    },

    async deleteGroup(slug) {
      await checkPermission();
      const tenant = context.tenancy.getCurrentTenant();
      const group = await storageOperations.get(tenant, {
        slug
      });

      if (!group) {
        throw new _handlerGraphql.NotFoundError(`Group "${slug}" was not found!`);
      }

      try {
        await storageOperations.delete(tenant, {
          group
        });
        return true;
      } catch (ex) {
        throw new _error.default(ex.message || "Could not delete group.", ex.code || "DELETE_GROUP_ERROR", {
          group
        });
      }
    }

  };
});

exports.default = _default;
//# sourceMappingURL=groups.crud.js.map