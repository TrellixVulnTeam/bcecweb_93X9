"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _objectWithoutProperties2 = _interopRequireDefault(require("@babel/runtime/helpers/objectWithoutProperties"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _mdbid = _interopRequireDefault(require("mdbid"));

var _lodash = _interopRequireDefault(require("lodash.clonedeep"));

var _fields = require("@commodo/fields");

var _validation = require("@webiny/validation");

var _apiSecurity = require("@webiny/api-security");

var _handlerGraphql = require("@webiny/handler-graphql");

var _error = _interopRequireDefault(require("@webiny/error"));

var _UserPlugin = require("../plugins/UserPlugin");

var _users = require("./users.loaders");

var _users2 = _interopRequireDefault(require("./users.validation"));

var _UserStorageOperationsProvider = require("../plugins/UserStorageOperationsProvider");

var _ContextPlugin = require("@webiny/handler/plugins/ContextPlugin");

var _crypto = _interopRequireDefault(require("crypto"));

var _storageOperations = require("./storageOperations");

const _excluded = ["group"],
      _excluded2 = ["group"];

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

const CreateAccessTokenDataModel = (0, _fields.withFields)({
  name: (0, _fields.string)({
    validation: _validation.validation.create("required,maxLength:100")
  }),
  token: (0, _fields.string)({
    validation: _validation.validation.create("required,maxLength:64")
  })
})();
const UpdateAccessTokenDataModel = (0, _fields.withFields)({
  name: (0, _fields.string)({
    validation: _validation.validation.create("required")
  })
})();

const executeCallback = async (plugins, callback, params) => {
  for (const plugin of plugins) {
    if (typeof plugin[callback] === "function") {
      await plugin[callback](params);
    }
  }
};

const generateToken = (tokenLength = 48) => {
  const token = _crypto.default.randomBytes(Math.ceil(tokenLength / 2)).toString("hex").slice(0, tokenLength - 1); // Personal access tokens are prefixed with a letter "p" to make token verification easier.
  // When authentication plugins kick in, they will be able to tell if they should handle the token by
  // checking the first letter and either process the token or skip authentication completely.


  return `p${token}`;
};

var _default = new _ContextPlugin.ContextPlugin(async context => {
  const storageOperations = await (0, _storageOperations.getStorageOperations)(context, _UserStorageOperationsProvider.UserStorageOperationsProvider.type);
  const userPlugins = context.plugins.byType(_UserPlugin.UserPlugin.type);
  /**
   * Validation plugin for creating/updating the user.
   */

  context.plugins.register(_users2.default);
  /**
   * We need the data loaders to cache what ever we can.
   */

  const loaders = new _users.UserLoaders({
    context,
    storageOperations
  });

  const checkPermission = async options => {
    if (options && options.auth === false) {
      return;
    }

    const permission = await context.security.getPermission("security.user");

    if (!permission) {
      throw new _apiSecurity.NotAuthorizedError();
    }
  };

  context.security.users = {
    async login() {
      const {
        security
      } = context;
      const identity = security.getIdentity();

      if (!identity) {
        throw new _apiSecurity.NotAuthorizedError();
      }

      let user = await context.security.users.getUser(identity.id, {
        auth: false
      });
      let firstLogin = false;

      if (!user) {
        firstLogin = true; // Create a "Security User"

        user = await context.security.users.createUser({
          login: identity.id,
          firstName: identity.firstName || "",
          lastName: identity.lastName || "",
          avatar: identity.avatar
        }, {
          auth: false
        });
      }

      await executeCallback(userPlugins, "onLogin", {
        context,
        user,
        firstLogin
      });
      return user;
    },

    async createToken(input) {
      const identity = context.security.getIdentity();

      if (!identity) {
        throw new _apiSecurity.NotAuthorizedError();
      }

      const data = _objectSpread(_objectSpread({}, input), {}, {
        token: generateToken()
      });

      await new CreateAccessTokenDataModel().populate(data).validate();

      const token = _objectSpread(_objectSpread({}, data), {}, {
        id: (0, _mdbid.default)(),
        login: identity.id,
        createdOn: new Date().toISOString()
      });

      try {
        return await storageOperations.createToken({
          identity,
          token
        });
      } catch (ex) {
        throw new _error.default(ex.messagge || "Could not create user access token.", ex.code || "CREATE_USER_ACCESS_TOKEN_ERROR", _objectSpread(_objectSpread({}, ex.data || {}), {}, {
          token
        }));
      }
    },

    async createUser(userData, options) {
      const {
        security,
        tenancy
      } = context;
      const {
        group: groupSlug
      } = userData,
            data = (0, _objectWithoutProperties2.default)(userData, _excluded);
      await checkPermission(options);
      const login = data.login.toLowerCase();
      const identity = security.getIdentity();

      try {
        const existing = await storageOperations.getUser({
          id: login
        });

        if (existing) {
          throw new Error();
        }
      } catch (ex) {
        throw new _error.default(ex.message || "User with that login already exists.", ex.code || "USER_EXISTS", _objectSpread(_objectSpread({}, ex.data || {}), {}, {
          id: login
        }));
      }

      let createdBy = null;

      if (identity) {
        createdBy = {
          id: identity.id,
          displayName: identity.displayName,
          type: identity.type
        };
      }

      const user = _objectSpread(_objectSpread({}, data), {}, {
        id: login,
        login,
        createdOn: new Date().toISOString(),
        createdBy
      });
      /**
       * Always delete the password from the user data, just in case something passed it into the input.
       */


      delete user["password"];
      let result;

      try {
        await executeCallback(userPlugins, "beforeCreate", {
          context,
          user,
          inputData: data
        });
        result = await storageOperations.createUser({
          user
        });
        await executeCallback(userPlugins, "afterCreate", {
          context,
          user: result,
          inputData: data
        });
        const tenant = tenancy.getCurrentTenant();
        const group = await security.groups.getGroup(groupSlug, options);
        await security.users.linkUserToTenant(result.login, tenant, group);
        return result;
      } catch (ex) {
        throw new _error.default(ex.message || "Could not create user.", ex.code || "CREATE_USER_ERROR", _objectSpread(_objectSpread({}, ex.data || {}), {}, {
          user: result || user
        }));
      }
    },

    async deleteToken(id) {
      const identity = context.security.getIdentity();

      if (!identity) {
        throw new _apiSecurity.NotAuthorizedError();
      }

      const token = await context.security.users.getPersonalAccessToken(identity.id, id);

      if (!token) {
        throw new _handlerGraphql.NotFoundError(`PAT "${id}" was not found!`);
      }

      try {
        await storageOperations.deleteToken({
          identity,
          token
        });
      } catch (ex) {
        throw new _error.default(ex.message || "Could not delete user access token.", ex.code || "DELETE_USER_ACCESS_TOKEN_ERROR", _objectSpread(_objectSpread({}, ex.data || {}), {}, {
          identity,
          token
        }));
      }

      return true;
    },

    async deleteUser(login) {
      const {
        security
      } = context;
      await checkPermission();
      const user = await context.security.users.getUser(login);
      const identity = security.getIdentity();

      if (!user) {
        throw new _handlerGraphql.NotFoundError(`User "${login}" was not found!`);
      }

      if (user.login === identity.id) {
        throw new _error.default(`You can't delete your own user account.`);
      }

      try {
        await executeCallback(userPlugins, "beforeDelete", {
          context,
          user
        });
        await storageOperations.deleteUser({
          user
        });
        loaders.clearLoadersCache(login);
        await executeCallback(userPlugins, "afterDelete", {
          context,
          user
        });
      } catch (ex) {
        throw new _error.default(ex.messagge || "Could not delete user.", ex.code || "DELETE_USER_ERROR", _objectSpread(_objectSpread({}, ex.data || {}), {}, {
          user
        }));
      }

      return true;
    },

    async getPersonalAccessToken(login, tokenId) {
      try {
        return storageOperations.getPersonalAccessToken({
          login,
          tokenId
        });
      } catch (ex) {
        throw new _error.default(ex.messagge || "Could not get user access token.", ex.code || "GET_USER_ACCESS_TOKEN_ERROR", _objectSpread(_objectSpread({}, ex.data || {}), {}, {
          login,
          tokenId
        }));
      }
    },

    async getUser(login, options) {
      await checkPermission(options);
      return loaders.getUser.load(login);
    },

    async getUserAccess(login) {
      return loaders.getUserAccess.load(login);
    },

    async getUserByPersonalAccessToken(token) {
      try {
        return await storageOperations.getUserByPersonalAccessToken({
          token
        });
      } catch (ex) {
        throw new _error.default(ex.message || "Could not get user via PAT.", ex.code || "GET_USER_VIA_PAT_ERROR", _objectSpread(_objectSpread({}, ex.data || {}), {}, {
          token
        }));
      }
    },

    async linkUserToTenant(id, tenant, group) {
      const user = await context.security.users.getUser(id, {
        auth: false
      });

      if (!user) {
        throw new _error.default("User not found.", "USER_NOT_FOUND", {
          id
        });
      }

      const link = {
        id: user.id || user.login,
        tenant: {
          id: tenant.id,
          name: tenant.name
        },
        group: {
          slug: group.slug,
          name: group.name,
          permissions: group.permissions
        }
      };

      try {
        await storageOperations.linkUserToTenant({
          user,
          tenant,
          group,
          link
        });
      } catch (ex) {
        throw new _error.default(ex.messsage || "Cannot link user to tenant.", ex.code || "LINK_USER_TO_TENANT_ERROR", _objectSpread(_objectSpread({}, ex.data || {}), {}, {
          link,
          user
        }));
      }
      /**
       * Add the data into cache so it is not loaded again if required in this request.
       */


      await loaders.addDataLoaderAccessCache(id, link);
    },

    async unlinkUserFromTenant(id, tenant) {
      const user = await context.security.users.getUser(id, {
        auth: false
      });

      if (!user) {
        throw new _error.default("User not found.", "USER_NOT_FOUND", {
          id
        });
      }

      try {
        await storageOperations.unlinkUserFromTenant({
          tenant,
          user
        });
      } catch (ex) {
        throw new _error.default(ex.messsage || "Cannot unlink user from tenant.", ex.code || "UNLINK_USER_FROM_TENANT_ERROR", _objectSpread(_objectSpread({}, ex.data || {}), {}, {
          tenant,
          user
        }));
      }

      await loaders.deleteDataLoaderAccessCache(id, tenant);
    },

    async listTokens(login) {
      try {
        return storageOperations.listTokens({
          login
        });
      } catch (ex) {
        throw new _error.default(ex.messsage || "Cannot list user tokens.", ex.code || "LIST_TOKENS_ERROR", _objectSpread(_objectSpread({}, ex.data || {}), {}, {
          login
        }));
      }
    },

    async listUsers(params, options) {
      const {
        tenancy
      } = context;
      await checkPermission(options);
      const {
        tenant: tenantParam
      } = params || {};
      const tenant = tenantParam || tenancy.getCurrentTenant().id;

      try {
        return storageOperations.listUsers({
          where: {
            tenant
          },
          sort: ["createdOn_ASC"]
        });
      } catch (ex) {
        throw new _error.default(ex.messsage || "Cannot list users.", ex.code || "LIST_USERS_ERROR", _objectSpread(_objectSpread({}, ex.data || {}), {}, {
          tenant
        }));
      }
    },

    async updateToken(tokenId, data) {
      const identity = context.security.getIdentity();

      if (!identity) {
        throw new _apiSecurity.NotAuthorizedError();
      }

      const {
        name
      } = data;
      await new UpdateAccessTokenDataModel().populate({
        name
      }).validate();
      const original = await context.security.users.getPersonalAccessToken(identity.id, tokenId);

      if (!original) {
        throw new _handlerGraphql.NotFoundError();
      }

      const token = _objectSpread(_objectSpread({}, original), {}, {
        name
      });

      try {
        return await storageOperations.updateToken({
          original,
          token
        });
      } catch (ex) {
        throw new _error.default(ex.messsage || "Cannot update token.", ex.code || "UPDATE_TOKEN_ERROR", _objectSpread(_objectSpread({}, ex.data || {}), {}, {
          original,
          token
        }));
      }
    },

    async updateUser(login, data) {
      const {
        security,
        tenancy
      } = context;
      const permission = await security.getPermission("security.user");

      if (!permission) {
        throw new _apiSecurity.NotAuthorizedError();
      }

      const originalUser = await security.users.getUser(login);

      if (!originalUser) {
        throw new _handlerGraphql.NotFoundError(`User "${login}" was not found!`);
      } // Group doesn't go into the user record.
      // A user can belong to different groups on different tenants, so we don't store it into the main user record.


      const _cloneDeep = (0, _lodash.default)(data),
            {
        group: groupSlug
      } = _cloneDeep,
            updateData = (0, _objectWithoutProperties2.default)(_cloneDeep, _excluded2); // Make sure "group" is not sent to the storage layer.


      delete originalUser["group"];

      try {
        await executeCallback(userPlugins, "beforeUpdate", {
          context,
          user: originalUser,
          updateData,
          inputData: data
        });

        const user = _objectSpread(_objectSpread({}, originalUser), updateData);

        const result = await storageOperations.updateUser({
          original: originalUser,
          user
        });
        await executeCallback(userPlugins, "afterUpdate", {
          context,
          user,
          inputData: data
        });
        /**
         * Cache clear and updating.
         */

        await loaders.updateDataLoaderUserCache(login, updateData);
        loaders.clearDataLoaderAccessCache(login);
        /**
         * If there is a group defined, remove the existing one and add the new one.
         */

        if (groupSlug) {
          const tenant = tenancy.getCurrentTenant();
          const group = await security.groups.getGroup(groupSlug);
          await security.users.unlinkUserFromTenant(result.login, tenant);
          await security.users.linkUserToTenant(result.login, tenant, group);
        }

        return result;
      } catch (ex) {
        throw new _error.default(ex.messsage || "Cannot update user.", ex.code || "UPDATE_USER_ERROR", ex.data || {});
      }
    }

  };
});

exports.default = _default;
//# sourceMappingURL=users.crud.js.map