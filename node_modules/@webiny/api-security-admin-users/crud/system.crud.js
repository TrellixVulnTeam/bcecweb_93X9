"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _ContextPlugin = require("@webiny/handler/plugins/ContextPlugin");

var _SystemStorageOperationsProvider = require("../plugins/SystemStorageOperationsProvider");

var _error = _interopRequireDefault(require("@webiny/error"));

var _storageOperations = require("./storageOperations");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

const createDefaultGroups = async context => {
  let anonymousGroup = null;
  let fullAccessGroup = null;
  const options = {
    auth: false
  };
  const groups = await context.security.groups.listGroups(options);
  groups.forEach(group => {
    if (group.slug === "full-access") {
      fullAccessGroup = group;
    }

    if (group.slug === "anonymous") {
      anonymousGroup = group;
    }
  });

  if (!fullAccessGroup) {
    fullAccessGroup = await context.security.groups.createGroup({
      name: "Full Access",
      description: "Grants full access to all apps.",
      system: true,
      slug: "full-access",
      permissions: [{
        name: "*"
      }]
    }, options);
  }

  if (!anonymousGroup) {
    anonymousGroup = await context.security.groups.createGroup({
      name: "Anonymous",
      description: "Permissions for anonymous users (public access).",
      system: true,
      slug: "anonymous",
      permissions: []
    }, options);
  }

  return {
    fullAccessGroup,
    anonymousGroup
  };
};

var _default = new _ContextPlugin.ContextPlugin(async context => {
  const storageOperations = await (0, _storageOperations.getStorageOperations)(context, _SystemStorageOperationsProvider.SystemStorageOperationsProvider.type);
  context.security.system = {
    async get() {
      const rootTenant = await context.tenancy.getRootTenant();

      if (!rootTenant) {
        return null;
      }

      try {
        return await storageOperations.get();
      } catch (ex) {
        throw new _error.default(ex.message || "Could not load the system data.", ex.code || "GET_SYSTEM_ERROR");
      }
    },

    async getVersion() {
      const rootTenant = await context.tenancy.getRootTenant();

      if (!rootTenant) {
        return null;
      }

      const system = await context.security.system.get();
      return system ? system.version : null;
    },

    async setVersion(version) {
      const original = await context.security.system.get();
      const system = {
        version
      };

      if (original) {
        try {
          return await storageOperations.update({
            original,
            system
          });
        } catch (ex) {
          throw new _error.default(ex.message || "Could not update existing system data.", ex.code || "UPDATE_SYSTEM_ERROR", {
            original,
            system
          });
        }
      }

      try {
        return await storageOperations.create({
          system
        });
      } catch (ex) {
        throw new _error.default(ex.message || "Could not create the system data.", ex.code || "CREATE_SYSTEM_ERROR", {
          system
        });
      }
    },

    async install(input) {
      const rootTenant = await context.tenancy.getRootTenant();

      if (rootTenant) {
        throw new _error.default("Security is already installed.", "SECURITY_INSTALL_ABORTED");
      } // Create root tenant


      const tenant = await context.tenancy.createTenant({
        id: "root",
        name: "Root",
        parent: null
      });
      context.tenancy.setCurrentTenant(tenant);
      let fullAccessGroup;

      try {
        // Create default groups
        const {
          fullAccessGroup: group
        } = await createDefaultGroups(context);
        fullAccessGroup = group;
      } catch (ex) {
        throw new _error.default("Could not create default groups.", "CREATE_DEFAULT_GROUPS_ERROR", {
          message: ex.message,
          code: ex.code,
          data: ex.data
        });
      }

      const user = _objectSpread(_objectSpread({}, input), {}, {
        group: fullAccessGroup.slug
      });

      try {
        // Create new user
        await context.security.users.createUser(user, {
          auth: false
        });
      } catch (ex) {
        await context.tenancy.deleteTenant("root");
        throw new _error.default(ex.message, "SECURITY_INSTALL_ABORTED", ex.data || {});
      } // Store app version


      await context.security.system.setVersion(context.WEBINY_VERSION);
    }

  };
});

exports.default = _default;
//# sourceMappingURL=system.crud.js.map