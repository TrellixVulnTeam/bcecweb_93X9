"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _crypto = _interopRequireDefault(require("crypto"));

var _fields = require("@commodo/fields");

var _commodoFieldsObject = require("commodo-fields-object");

var _validation = require("@webiny/validation");

var _mdbid = _interopRequireDefault(require("mdbid"));

var _apiSecurity = require("@webiny/api-security");

var _handlerGraphql = require("@webiny/handler-graphql");

var _ApiKeyStorageOperationsProvider = require("../plugins/ApiKeyStorageOperationsProvider");

var _error = _interopRequireDefault(require("@webiny/error"));

var _ContextPlugin = require("@webiny/handler/plugins/ContextPlugin");

var _storageOperations = require("./storageOperations");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

const APIKeyModel = (0, _fields.withFields)({
  name: (0, _fields.string)({
    validation: _validation.validation.create("required")
  }),
  description: (0, _fields.string)({
    validation: _validation.validation.create("required")
  }),
  permissions: (0, _commodoFieldsObject.object)({
    list: true,
    value: []
  })
})();

const generateToken = (tokenLength = 48) => {
  const token = _crypto.default.randomBytes(Math.ceil(tokenLength / 2)).toString("hex"); // API Keys are prefixed with a letter "a" to make token verification easier.
  // When authentication plugins kick in, they will be able to tell if they should handle the token by
  // checking the first letter and either process the token or skip authentication completely.


  if (token.startsWith("a")) {
    return token;
  }

  return `a${token.slice(0, tokenLength - 1)}`;
};

var _default = new _ContextPlugin.ContextPlugin(async context => {
  const {
    security,
    tenancy
  } = context;
  const storageOperations = await (0, _storageOperations.getStorageOperations)(context, _ApiKeyStorageOperationsProvider.ApiKeyStorageOperationsProvider.type);
  context.security.apiKeys = {
    async getApiKeyByToken(token) {
      try {
        return await storageOperations.getByToken({
          token
        });
      } catch (ex) {
        throw new _error.default(ex.message || "Could not get API key by token.", ex.code || "GET_API_KEY_BY_TOKEN_ERROR", {
          token
        });
      }
    },

    async getApiKey(id) {
      // Check if it's an ID or an actual API key (API keys start with a letter "a")
      const permission = await security.getPermission("security.apiKey");

      if (!permission) {
        throw new _apiSecurity.NotAuthorizedError();
      }

      try {
        return await storageOperations.get({
          id
        });
      } catch (ex) {
        throw new _error.default(ex.message || "Could not get API key.", ex.code || "GET_API_KEY_ERROR", {
          id
        });
      }
    },

    async listApiKeys() {
      const permission = await security.getPermission("security.apiKey");

      if (!permission) {
        throw new _apiSecurity.NotAuthorizedError();
      }

      try {
        return await storageOperations.list({
          sort: ["createdOn_ASC"]
        });
      } catch (ex) {
        throw new _error.default(ex.message || "Could not list API keys.", ex.code || "LIST_API_KEY_ERROR");
      }
    },

    async createApiKey(data) {
      const identity = security.getIdentity();
      const tenant = tenancy.getCurrentTenant();
      const permission = await security.getPermission("security.apiKey");

      if (!permission) {
        throw new _apiSecurity.NotAuthorizedError();
      }

      await new APIKeyModel().populate(data).validate();

      const apiKey = _objectSpread({
        id: (0, _mdbid.default)(),
        tenant: tenant.id,
        token: generateToken(),
        createdBy: {
          id: identity.id,
          displayName: identity.displayName,
          type: identity.type
        },
        createdOn: new Date().toISOString()
      }, data);

      try {
        return await storageOperations.create({
          apiKey
        });
      } catch (ex) {
        throw new _error.default(ex.message || "Could not create API key.", ex.code || "CREATE_API_KEY_ERROR", {
          apiKey
        });
      }
    },

    async updateApiKey(id, data) {
      const permission = await security.getPermission("security.apiKey");

      if (!permission) {
        throw new _apiSecurity.NotAuthorizedError();
      }

      const model = new APIKeyModel().populate(data);
      await model.validate();
      const changedData = await model.toJSON({
        onlyDirty: true
      });
      const original = await this.getApiKey(id);

      if (!original) {
        throw new _handlerGraphql.NotFoundError(`API key "${id}" was not found!`);
      }

      const apiKey = _objectSpread(_objectSpread({}, original), changedData);

      try {
        return await storageOperations.update({
          original,
          apiKey
        });
      } catch (ex) {
        throw new _error.default(ex.message || "Could not update API key.", ex.code || "UPDATE_API_KEY_ERROR", {
          original,
          apiKey
        });
      }
    },

    async deleteApiKey(id) {
      const permission = await security.getPermission("security.apiKey");

      if (!permission) {
        throw new _apiSecurity.NotAuthorizedError();
      }

      const apiKey = await this.getApiKey(id);

      if (!apiKey) {
        throw new _handlerGraphql.NotFoundError(`API key "${id}" was not found!`);
      }

      try {
        await storageOperations.delete({
          apiKey
        });
        return true;
      } catch (ex) {
        throw new _error.default(ex.message || "Could not delete API key.", ex.code || "DELETE_API_KEY_ERROR", {
          apiKey
        });
      }
    }

  };
});

exports.default = _default;
//# sourceMappingURL=apiKey.crud.js.map