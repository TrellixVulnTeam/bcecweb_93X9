{"version":3,"sources":["../../src/crud/users.crud.ts"],"names":["CreateAccessTokenDataModel","name","validation","create","token","UpdateAccessTokenDataModel","executeCallback","plugins","callback","params","plugin","generateToken","tokenLength","crypto","randomBytes","Math","ceil","toString","slice","ContextPlugin","context","storageOperations","UserStorageOperationsProvider","type","userPlugins","byType","UserPlugin","register","validationPlugin","loaders","UserLoaders","checkPermission","options","auth","permission","security","getPermission","NotAuthorizedError","users","login","identity","getIdentity","user","getUser","id","firstLogin","createUser","firstName","lastName","avatar","createToken","input","data","populate","validate","createdOn","Date","toISOString","ex","WebinyError","messagge","code","userData","tenancy","group","groupSlug","toLowerCase","existing","Error","message","createdBy","displayName","result","inputData","tenant","getCurrentTenant","groups","getGroup","linkUserToTenant","deleteToken","getPersonalAccessToken","NotFoundError","deleteUser","clearLoadersCache","tokenId","load","getUserAccess","getUserByPersonalAccessToken","link","slug","permissions","messsage","addDataLoaderAccessCache","unlinkUserFromTenant","deleteDataLoaderAccessCache","listTokens","listUsers","tenantParam","where","sort","updateToken","original","updateUser","originalUser","updateData","updateDataLoaderUserCache","clearDataLoaderAccessCache"],"mappings":"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","sourcesContent":["import mdbid from \"mdbid\";\nimport cloneDeep from \"lodash.clonedeep\";\nimport { withFields, string } from \"@commodo/fields\";\nimport { validation } from \"@webiny/validation\";\nimport { Tenant } from \"@webiny/api-tenancy/types\";\nimport { NotAuthorizedError } from \"@webiny/api-security\";\nimport { NotFoundError } from \"@webiny/handler-graphql\";\nimport WebinyError from \"@webiny/error\";\nimport { UserPlugin } from \"~/plugins/UserPlugin\";\nimport {\n    AdminUsersContext,\n    CrudOptions,\n    Group,\n    TenantAccess,\n    User,\n    UserPersonalAccessToken,\n    UserStorageOperations\n} from \"~/types\";\nimport { UserLoaders } from \"./users.loaders\";\nimport validationPlugin from \"./users.validation\";\nimport { UserStorageOperationsProvider } from \"~/plugins/UserStorageOperationsProvider\";\nimport { ContextPlugin } from \"@webiny/handler/plugins/ContextPlugin\";\nimport crypto from \"crypto\";\nimport { getStorageOperations } from \"~/crud/storageOperations\";\n\nconst CreateAccessTokenDataModel = withFields({\n    name: string({ validation: validation.create(\"required,maxLength:100\") }),\n    token: string({ validation: validation.create(\"required,maxLength:64\") })\n})();\n\nconst UpdateAccessTokenDataModel = withFields({\n    name: string({ validation: validation.create(\"required\") })\n})();\n\nconst executeCallback = async <TCallbackFunction extends (params: any) => void | Promise<void>>(\n    plugins: UserPlugin[],\n    callback: string,\n    params: Parameters<TCallbackFunction>[0]\n) => {\n    for (const plugin of plugins) {\n        if (typeof plugin[callback] === \"function\") {\n            await plugin[callback](params);\n        }\n    }\n};\n\nconst generateToken = (tokenLength = 48) => {\n    const token = crypto\n        .randomBytes(Math.ceil(tokenLength / 2))\n        .toString(\"hex\")\n        .slice(0, tokenLength - 1);\n\n    // Personal access tokens are prefixed with a letter \"p\" to make token verification easier.\n    // When authentication plugins kick in, they will be able to tell if they should handle the token by\n    // checking the first letter and either process the token or skip authentication completely.\n    return `p${token}`;\n};\n\nexport default new ContextPlugin<AdminUsersContext>(async context => {\n    const storageOperations = await getStorageOperations<UserStorageOperations>(\n        context,\n        UserStorageOperationsProvider.type\n    );\n\n    const userPlugins = context.plugins.byType<UserPlugin>(UserPlugin.type);\n    /**\n     * Validation plugin for creating/updating the user.\n     */\n    context.plugins.register(validationPlugin);\n    /**\n     * We need the data loaders to cache what ever we can.\n     */\n    const loaders = new UserLoaders({ context, storageOperations });\n\n    const checkPermission = async (options?: CrudOptions) => {\n        if (options && options.auth === false) {\n            return;\n        }\n        const permission = await context.security.getPermission(\"security.user\");\n\n        if (!permission) {\n            throw new NotAuthorizedError();\n        }\n    };\n\n    context.security.users = {\n        async login(): Promise<User> {\n            const { security } = context;\n            const identity = security.getIdentity();\n\n            if (!identity) {\n                throw new NotAuthorizedError();\n            }\n\n            let user = await context.security.users.getUser(identity.id, { auth: false });\n\n            let firstLogin = false;\n\n            if (!user) {\n                firstLogin = true;\n                // Create a \"Security User\"\n                user = await context.security.users.createUser(\n                    {\n                        login: identity.id,\n                        firstName: identity.firstName || \"\",\n                        lastName: identity.lastName || \"\",\n                        avatar: identity.avatar\n                    },\n                    { auth: false }\n                );\n            }\n\n            await executeCallback<UserPlugin[\"onLogin\"]>(userPlugins, \"onLogin\", {\n                context,\n                user,\n                firstLogin\n            });\n\n            return user;\n        },\n\n        async createToken(input): Promise<UserPersonalAccessToken> {\n            const identity = context.security.getIdentity();\n            if (!identity) {\n                throw new NotAuthorizedError();\n            }\n            const data = {\n                ...input,\n                token: generateToken()\n            };\n            await new CreateAccessTokenDataModel().populate(data).validate();\n\n            const token: UserPersonalAccessToken = {\n                ...data,\n                id: mdbid(),\n                login: identity.id,\n                createdOn: new Date().toISOString()\n            };\n            try {\n                return await storageOperations.createToken({\n                    identity,\n                    token\n                });\n            } catch (ex) {\n                throw new WebinyError(\n                    ex.messagge || \"Could not create user access token.\",\n                    ex.code || \"CREATE_USER_ACCESS_TOKEN_ERROR\",\n                    {\n                        ...(ex.data || {}),\n                        token\n                    }\n                );\n            }\n        },\n\n        async createUser(userData, options): Promise<User> {\n            const { security, tenancy } = context;\n            const { group: groupSlug, ...data } = userData;\n\n            await checkPermission(options);\n\n            const login = data.login.toLowerCase();\n            const identity = security.getIdentity();\n\n            try {\n                const existing = await storageOperations.getUser({\n                    id: login\n                });\n\n                if (existing) {\n                    throw new Error();\n                }\n            } catch (ex) {\n                throw new WebinyError(\n                    ex.message || \"User with that login already exists.\",\n                    ex.code || \"USER_EXISTS\",\n                    {\n                        ...(ex.data || {}),\n                        id: login\n                    }\n                );\n            }\n            let createdBy = null;\n            if (identity) {\n                createdBy = {\n                    id: identity.id,\n                    displayName: identity.displayName,\n                    type: identity.type\n                };\n            }\n\n            const user: User = {\n                ...data,\n                id: login,\n                login,\n                createdOn: new Date().toISOString(),\n                createdBy\n            };\n            /**\n             * Always delete the password from the user data, just in case something passed it into the input.\n             */\n            delete user[\"password\"];\n\n            let result: User;\n            try {\n                await executeCallback<UserPlugin[\"beforeCreate\"]>(userPlugins, \"beforeCreate\", {\n                    context,\n                    user,\n                    inputData: data\n                });\n                result = await storageOperations.createUser({\n                    user\n                });\n                await executeCallback<UserPlugin[\"afterCreate\"]>(userPlugins, \"afterCreate\", {\n                    context,\n                    user: result,\n                    inputData: data\n                });\n                const tenant = tenancy.getCurrentTenant();\n                const group = await security.groups.getGroup(groupSlug, options);\n                await security.users.linkUserToTenant(result.login, tenant, group);\n                return result;\n            } catch (ex) {\n                throw new WebinyError(\n                    ex.message || \"Could not create user.\",\n                    ex.code || \"CREATE_USER_ERROR\",\n                    {\n                        ...(ex.data || {}),\n                        user: result || user\n                    }\n                );\n            }\n        },\n\n        async deleteToken(id): Promise<boolean> {\n            const identity = context.security.getIdentity();\n            if (!identity) {\n                throw new NotAuthorizedError();\n            }\n\n            const token = await context.security.users.getPersonalAccessToken(identity.id, id);\n\n            if (!token) {\n                throw new NotFoundError(`PAT \"${id}\" was not found!`);\n            }\n\n            try {\n                await storageOperations.deleteToken({\n                    identity,\n                    token\n                });\n            } catch (ex) {\n                throw new WebinyError(\n                    ex.message || \"Could not delete user access token.\",\n                    ex.code || \"DELETE_USER_ACCESS_TOKEN_ERROR\",\n                    {\n                        ...(ex.data || {}),\n                        identity,\n                        token\n                    }\n                );\n            }\n\n            return true;\n        },\n\n        async deleteUser(login): Promise<boolean> {\n            const { security } = context;\n\n            await checkPermission();\n\n            const user = await context.security.users.getUser(login);\n            const identity = security.getIdentity();\n\n            if (!user) {\n                throw new NotFoundError(`User \"${login}\" was not found!`);\n            }\n\n            if (user.login === identity.id) {\n                throw new WebinyError(`You can't delete your own user account.`);\n            }\n\n            try {\n                await executeCallback<UserPlugin[\"beforeDelete\"]>(userPlugins, \"beforeDelete\", {\n                    context,\n                    user\n                });\n\n                await storageOperations.deleteUser({\n                    user\n                });\n\n                loaders.clearLoadersCache(login);\n\n                await executeCallback<UserPlugin[\"afterDelete\"]>(userPlugins, \"afterDelete\", {\n                    context,\n                    user\n                });\n            } catch (ex) {\n                throw new WebinyError(\n                    ex.messagge || \"Could not delete user.\",\n                    ex.code || \"DELETE_USER_ERROR\",\n                    {\n                        ...(ex.data || {}),\n                        user\n                    }\n                );\n            }\n\n            return true;\n        },\n\n        async getPersonalAccessToken(login, tokenId): Promise<UserPersonalAccessToken> {\n            try {\n                return storageOperations.getPersonalAccessToken({\n                    login,\n                    tokenId\n                });\n            } catch (ex) {\n                throw new WebinyError(\n                    ex.messagge || \"Could not get user access token.\",\n                    ex.code || \"GET_USER_ACCESS_TOKEN_ERROR\",\n                    {\n                        ...(ex.data || {}),\n                        login,\n                        tokenId\n                    }\n                );\n            }\n        },\n\n        async getUser(login, options): Promise<User> {\n            await checkPermission(options);\n\n            return loaders.getUser.load(login);\n        },\n\n        async getUserAccess(login): Promise<TenantAccess[]> {\n            return loaders.getUserAccess.load(login);\n        },\n\n        async getUserByPersonalAccessToken(token): Promise<User> {\n            try {\n                return await storageOperations.getUserByPersonalAccessToken({\n                    token\n                });\n            } catch (ex) {\n                throw new WebinyError(\n                    ex.message || \"Could not get user via PAT.\",\n                    ex.code || \"GET_USER_VIA_PAT_ERROR\",\n                    {\n                        ...(ex.data || {}),\n                        token\n                    }\n                );\n            }\n        },\n\n        async linkUserToTenant(id: string, tenant: Tenant, group: Group): Promise<void> {\n            const user = await context.security.users.getUser(id, {\n                auth: false\n            });\n            if (!user) {\n                throw new WebinyError(\"User not found.\", \"USER_NOT_FOUND\", {\n                    id\n                });\n            }\n            const link: TenantAccess = {\n                id: user.id || user.login,\n                tenant: {\n                    id: tenant.id,\n                    name: tenant.name\n                },\n                group: {\n                    slug: group.slug,\n                    name: group.name,\n                    permissions: group.permissions\n                }\n            };\n\n            try {\n                await storageOperations.linkUserToTenant({\n                    user,\n                    tenant,\n                    group,\n                    link\n                });\n            } catch (ex) {\n                throw new WebinyError(\n                    ex.messsage || \"Cannot link user to tenant.\",\n                    ex.code || \"LINK_USER_TO_TENANT_ERROR\",\n                    {\n                        ...(ex.data || {}),\n                        link,\n                        user\n                    }\n                );\n            }\n            /**\n             * Add the data into cache so it is not loaded again if required in this request.\n             */\n            await loaders.addDataLoaderAccessCache(id, link);\n        },\n\n        async unlinkUserFromTenant(id, tenant): Promise<void> {\n            const user = await context.security.users.getUser(id, {\n                auth: false\n            });\n            if (!user) {\n                throw new WebinyError(\"User not found.\", \"USER_NOT_FOUND\", {\n                    id\n                });\n            }\n\n            try {\n                await storageOperations.unlinkUserFromTenant({\n                    tenant,\n                    user\n                });\n            } catch (ex) {\n                throw new WebinyError(\n                    ex.messsage || \"Cannot unlink user from tenant.\",\n                    ex.code || \"UNLINK_USER_FROM_TENANT_ERROR\",\n                    {\n                        ...(ex.data || {}),\n                        tenant,\n                        user\n                    }\n                );\n            }\n            await loaders.deleteDataLoaderAccessCache(id, tenant);\n        },\n\n        async listTokens(login): Promise<UserPersonalAccessToken[]> {\n            try {\n                return storageOperations.listTokens({\n                    login\n                });\n            } catch (ex) {\n                throw new WebinyError(\n                    ex.messsage || \"Cannot list user tokens.\",\n                    ex.code || \"LIST_TOKENS_ERROR\",\n                    {\n                        ...(ex.data || {}),\n                        login\n                    }\n                );\n            }\n        },\n\n        async listUsers(params, options): Promise<User[]> {\n            const { tenancy } = context;\n\n            await checkPermission(options);\n\n            const { tenant: tenantParam } = params || {};\n\n            const tenant = tenantParam || tenancy.getCurrentTenant().id;\n\n            try {\n                return storageOperations.listUsers({\n                    where: {\n                        tenant\n                    },\n                    sort: [\"createdOn_ASC\"]\n                });\n            } catch (ex) {\n                throw new WebinyError(\n                    ex.messsage || \"Cannot list users.\",\n                    ex.code || \"LIST_USERS_ERROR\",\n                    {\n                        ...(ex.data || {}),\n                        tenant\n                    }\n                );\n            }\n        },\n\n        async updateToken(tokenId, data) {\n            const identity = context.security.getIdentity();\n            if (!identity) {\n                throw new NotAuthorizedError();\n            }\n\n            const { name } = data;\n            await new UpdateAccessTokenDataModel().populate({ name }).validate();\n\n            const original = await context.security.users.getPersonalAccessToken(\n                identity.id,\n                tokenId\n            );\n            if (!original) {\n                throw new NotFoundError();\n            }\n\n            const token: UserPersonalAccessToken = {\n                ...original,\n                name\n            };\n            try {\n                return await storageOperations.updateToken({\n                    original,\n                    token\n                });\n            } catch (ex) {\n                throw new WebinyError(\n                    ex.messsage || \"Cannot update token.\",\n                    ex.code || \"UPDATE_TOKEN_ERROR\",\n                    {\n                        ...(ex.data || {}),\n                        original,\n                        token\n                    }\n                );\n            }\n        },\n\n        async updateUser(login, data): Promise<User> {\n            const { security, tenancy } = context;\n            const permission = await security.getPermission(\"security.user\");\n\n            if (!permission) {\n                throw new NotAuthorizedError();\n            }\n\n            const originalUser = await security.users.getUser(login);\n            if (!originalUser) {\n                throw new NotFoundError(`User \"${login}\" was not found!`);\n            }\n\n            // Group doesn't go into the user record.\n            // A user can belong to different groups on different tenants, so we don't store it into the main user record.\n            const { group: groupSlug, ...updateData } = cloneDeep(data);\n\n            // Make sure \"group\" is not sent to the storage layer.\n            delete originalUser[\"group\"];\n\n            try {\n                await executeCallback<UserPlugin[\"beforeUpdate\"]>(userPlugins, \"beforeUpdate\", {\n                    context,\n                    user: originalUser,\n                    updateData,\n                    inputData: data\n                });\n\n                const user = { ...originalUser, ...updateData };\n\n                const result = await storageOperations.updateUser({\n                    original: originalUser,\n                    user\n                });\n                await executeCallback<UserPlugin[\"afterUpdate\"]>(userPlugins, \"afterUpdate\", {\n                    context,\n                    user,\n                    inputData: data\n                });\n                /**\n                 * Cache clear and updating.\n                 */\n                await loaders.updateDataLoaderUserCache(login, updateData);\n                loaders.clearDataLoaderAccessCache(login);\n                /**\n                 * If there is a group defined, remove the existing one and add the new one.\n                 */\n                if (groupSlug) {\n                    const tenant = tenancy.getCurrentTenant();\n                    const group = await security.groups.getGroup(groupSlug);\n                    await security.users.unlinkUserFromTenant(result.login, tenant);\n                    await security.users.linkUserToTenant(result.login, tenant, group);\n                }\n                return result;\n            } catch (ex) {\n                throw new WebinyError(\n                    ex.messsage || \"Cannot update user.\",\n                    ex.code || \"UPDATE_USER_ERROR\",\n                    ex.data || {}\n                );\n            }\n        }\n    };\n});\n"],"file":"users.crud.js"}