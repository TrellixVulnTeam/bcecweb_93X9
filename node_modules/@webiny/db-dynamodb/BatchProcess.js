"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

class BatchProcess {
  constructor(batch, documentClient) {
    (0, _defineProperty2.default)(this, "documentClient", void 0);
    (0, _defineProperty2.default)(this, "batch", void 0);
    (0, _defineProperty2.default)(this, "resolveBuild", void 0);
    (0, _defineProperty2.default)(this, "rejectBuild", void 0);
    (0, _defineProperty2.default)(this, "queryBuild", void 0);
    (0, _defineProperty2.default)(this, "resolveExecution", void 0);
    (0, _defineProperty2.default)(this, "rejectExecution", void 0);
    (0, _defineProperty2.default)(this, "queryExecution", void 0);
    (0, _defineProperty2.default)(this, "operations", void 0);
    (0, _defineProperty2.default)(this, "batchType", void 0);
    (0, _defineProperty2.default)(this, "results", void 0);
    (0, _defineProperty2.default)(this, "response", void 0);
    this.documentClient = documentClient;
    this.batch = batch;
    this.resolveBuild = null;
    this.rejectBuild = null;
    this.queryBuild = new Promise((resolve, reject) => {
      this.resolveBuild = resolve;
      this.rejectBuild = reject;
    });
    this.resolveExecution = null;
    this.rejectExecution = null;
    this.queryExecution = new Promise((resolve, reject) => {
      this.resolveExecution = resolve;
      this.rejectExecution = reject;
    });
    this.operations = [];
    this.results = [];
    this.response = [];
    this.batchType;
  }

  waitStartExecution() {
    return this.queryBuild;
  }

  waitExecution() {
    return this.queryExecution;
  }

  addBatchOperation(type, args, meta = {}) {
    if (!this.batchType) {
      this.batchType = type;
    } else if (this.batchType !== type) {
      const initial = this.batchType;
      const index = this.operations.length;
      this.rejectBuild({
        message: `Cannot batch operations - all operations must be of the same type (the initial operation type was "${initial}", and operation type on index "${index}" is "${type}").`
      });
      return;
    }

    this.operations.push([args, meta]);
    const index = this.operations.length - 1;
    return () => this.results[index];
  }

  addBatchWrite(args) {
    return this.addBatchOperation("batchWrite", args);
  }

  addBatchDelete(args) {
    return this.addBatchOperation("batchWrite", _objectSpread({}, args), {
      delete: true
    });
  }

  addBatchGet(args) {
    return this.addBatchOperation("batchGet", args);
  }

  allOperationsAdded() {
    return this.operations.length === this.batch.operations.length;
  }

  startExecution() {
    this.resolveBuild();
    const documentClientArgs = {
      ReturnConsumedCapacity: "TOTAL",
      RequestItems: {}
    };

    const reject = e => {
      e.message = `An error occurred while executing "${this.batchType}" batch operation: ${e.message}`;
      return this.rejectExecution(e);
    };

    let resolve = response => {
      this.response = response;
      this.resolveExecution();
    };

    switch (this.batchType) {
      case "batchWrite":
        documentClientArgs.RequestItems = {};

        for (let i = 0; i < this.operations.length; i++) {
          const [args, meta] = this.operations[i];

          if (!documentClientArgs.RequestItems[args.table]) {
            documentClientArgs.RequestItems[args.table] = [];
          }

          const push = {};

          if (meta.delete) {
            push.DeleteRequest = {
              Key: args.query
            };
          } else {
            push.PutRequest = {
              Item: args.data
            };
          }

          documentClientArgs.RequestItems[args.table].push(push);
        }

        break;

      case "batchGet":
        documentClientArgs.RequestItems = {};

        for (let i = 0; i < this.operations.length; i++) {
          const [args] = this.operations[i];

          if (!documentClientArgs.RequestItems[args.table]) {
            documentClientArgs.RequestItems[args.table] = {
              Keys: []
            };
          }

          documentClientArgs.RequestItems[args.table].Keys.push(args.query);
        }

        resolve = response => {
          this.response = response;
          const results = []; // The results of batchGet aren't ordered so we have to figure out the order of results ourselves.

          for (let i = 0; i < this.operations.length; i++) {
            const [args] = this.operations[i];
            const responseItems = response.Responses[args.table];
            let foundResult = null;

            outer: for (let j = 0; j < responseItems.length; j++) {
              const responseItem = responseItems[j];

              for (const queryKey in args.query) {
                if (typeof responseItem[queryKey] === "undefined" || args.query[queryKey] !== responseItem[queryKey]) {
                  continue outer;
                }
              }

              foundResult = responseItem;
            }

            results.push(foundResult);
          }

          this.results = results;
          this.resolveExecution();
        };

        break;
    }

    return this.documentClient[this.batchType](documentClientArgs, (error, result) => {
      if (error) {
        reject(error);
      } else {
        resolve(result);
      }
    });
  }

}

var _default = BatchProcess;
exports.default = _default;
//# sourceMappingURL=BatchProcess.js.map