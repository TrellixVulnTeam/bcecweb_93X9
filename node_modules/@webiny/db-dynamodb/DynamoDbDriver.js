"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _dynamodb = require("aws-sdk/clients/dynamodb");

var _BatchProcess = _interopRequireDefault(require("./BatchProcess"));

var _QueryGenerator = _interopRequireDefault(require("./QueryGenerator"));

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

const LOG_KEYS = [{
  primary: true,
  unique: true,
  name: "primary",
  fields: [{
    name: "PK"
  }, {
    name: "SK"
  }]
}];

class DynamoDbDriver {
  constructor({
    documentClient
  } = {}) {
    (0, _defineProperty2.default)(this, "batchProcesses", void 0);
    (0, _defineProperty2.default)(this, "documentClient", void 0);
    this.batchProcesses = {};
    this.documentClient = documentClient || new _dynamodb.DocumentClient();
  }

  getClient() {
    return this.documentClient;
  }

  async create({
    table,
    data,
    meta,
    __batch: batch
  }) {
    if (!batch) {
      const result = await this.documentClient.put({
        TableName: table,
        Item: data,
        ReturnConsumedCapacity: meta ? "TOTAL" : "NONE"
      }).promise();
      return [true, {
        response: result.$response
      }];
    }

    const batchProcess = this.getBatchProcess(batch);
    batchProcess.addBatchWrite({
      table,
      data
    });

    if (batchProcess.allOperationsAdded()) {
      batchProcess.startExecution();
    } else {
      await batchProcess.waitStartExecution();
    }

    await batchProcess.waitExecution();
    return [true, {
      response: batchProcess.response
    }];
  }

  async update({
    query,
    data,
    table,
    meta,
    __batch: batch
  }) {
    if (!batch) {
      const update = {
        UpdateExpression: "SET ",
        ExpressionAttributeNames: {},
        ExpressionAttributeValues: {}
      };
      const updateExpression = [];

      for (const key in data) {
        updateExpression.push(`#${key} = :${key}`);
        update.ExpressionAttributeNames[`#${key}`] = key;
        update.ExpressionAttributeValues[`:${key}`] = data[key];
      }

      update.UpdateExpression += updateExpression.join(", ");
      const result = await this.documentClient.update(_objectSpread({
        TableName: table,
        Key: query,
        ReturnConsumedCapacity: meta ? "TOTAL" : "NONE"
      }, update)).promise();
      return [true, {
        response: result.$response
      }];
    }

    const batchProcess = this.getBatchProcess(batch);
    batchProcess.addBatchWrite({
      table,
      data
    });

    if (batchProcess.allOperationsAdded()) {
      batchProcess.startExecution();
    } else {
      await batchProcess.waitStartExecution();
    }

    await batchProcess.waitExecution();
    return [true, {
      response: batchProcess.response
    }];
  }

  async delete({
    query,
    table,
    meta,
    __batch: batch
  }) {
    if (!batch) {
      const result = await this.documentClient.delete({
        TableName: table,
        Key: query,
        ReturnConsumedCapacity: meta ? "TOTAL" : "NONE"
      }).promise();
      return [true, {
        response: result.$response
      }];
    }

    const batchProcess = this.getBatchProcess(batch);
    batchProcess.addBatchDelete({
      table,
      query
    });

    if (batchProcess.allOperationsAdded()) {
      batchProcess.startExecution();
    } else {
      await batchProcess.waitStartExecution();
    }

    await batchProcess.waitExecution();
    return [true, {
      response: batchProcess.response
    }];
  }

  async read({
    table,
    query,
    sort,
    limit,
    keys,
    meta,
    __batch: batch
  }) {
    if (!batch) {
      const queryGenerator = new _QueryGenerator.default();
      const queryParams = queryGenerator.generate({
        query,
        keys,
        sort,
        limit,
        tableName: table
      });
      const response = await this.documentClient.query(_objectSpread(_objectSpread({}, queryParams), {}, {
        ReturnConsumedCapacity: meta ? "TOTAL" : "NONE"
      })).promise();

      if (Array.isArray(response.Items)) {
        return [response.Items, {
          response: response.$response
        }];
      }

      return [[], {
        response: response.$response
      }];
    } // DynamoDb doesn't support batch queries, so we can immediately assume the GetRequest operation.


    const batchProcess = this.getBatchProcess(batch);
    const getResult = batchProcess.addBatchGet({
      table,
      query
    });

    if (batchProcess.allOperationsAdded()) {
      batchProcess.startExecution();
    } else {
      await batchProcess.waitStartExecution();
    }

    await batchProcess.waitExecution();
    const result = getResult();

    if (result) {
      return [[result], {
        response: batchProcess.response
      }];
    }

    return [[], {
      response: batchProcess.response
    }];
  }

  async createLog({
    id,
    operation,
    data,
    table
  }) {
    await this.create({
      table: table,
      keys: LOG_KEYS,
      data: _objectSpread({
        PK: "log",
        SK: id,
        id,
        operation
      }, data)
    });
    return [true, {}];
  }

  async readLogs({
    table
  }) {
    return this.read({
      table,
      keys: LOG_KEYS,
      query: {
        PK: "log",
        SK: {
          $gte: " "
        }
      }
    });
  }

  getBatchProcess(__batch) {
    if (!this.batchProcesses[__batch.instance.id]) {
      this.batchProcesses[__batch.instance.id] = new _BatchProcess.default(__batch.instance, this.documentClient);
    }

    return this.batchProcesses[__batch.instance.id];
  }

}

var _default = DynamoDbDriver;
exports.default = _default;
//# sourceMappingURL=DynamoDbDriver.js.map