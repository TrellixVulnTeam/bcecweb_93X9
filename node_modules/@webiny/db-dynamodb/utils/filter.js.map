{"version":3,"sources":["../../src/utils/filter.ts"],"names":["getMappedPlugins","params","context","plugins","byType","type","reduce","plugin","op","property","extractWhereArgs","key","result","split","field","shift","rawOp","length","join","operation","negate","match","replace","createFilters","where","keys","Object","filterPlugins","ValueFilterPlugin","fieldPathPlugins","FieldPathPlugin","transformValuePlugins","ValueTransformPlugin","map","value","undefined","filterPlugin","WebinyError","transformValuePlugin","find","canTransform","fieldPathPlugin","canCreate","compareValue","path","createPath","filter","Boolean","transform","Array","isArray","v","createFilterCallable","filters","item","dotProp","get","matched","matches","filterItems","items"],"mappings":";;;;;;;;;AAAA;;AACA;;AAEA;;AACA;;AACA;;AAuBA,MAAMA,gBAAgB,GAAsBC,MAAnB,IAAqE;AAC1F,SAAOA,MAAM,CAACC,OAAP,CAAeC,OAAf,CAAuBC,MAAvB,CAAiCH,MAAM,CAACI,IAAxC,EAA8CC,MAA9C,CAAqD,CAACH,OAAD,EAAUI,MAAV,KAAqB;AAC7E,UAAMC,EAAE,GAAGD,MAAM,CAACN,MAAM,CAACQ,QAAR,CAAjB;AACAN,IAAAA,OAAO,CAACK,EAAD,CAAP,GAAcD,MAAd;AACA,WAAOJ,OAAP;AACH,GAJM,EAIJ,EAJI,CAAP;AAKH,CAND;;AAQA,MAAMO,gBAAgB,GAAIC,GAAD,IAAiB;AACtC,QAAMC,MAAM,GAAGD,GAAG,CAACE,KAAJ,CAAU,GAAV,CAAf;AACA,QAAMC,KAAK,GAAGF,MAAM,CAACG,KAAP,EAAd;AACA,QAAMC,KAAK,GAAGJ,MAAM,CAACK,MAAP,KAAkB,CAAlB,GAAsB,IAAtB,GAA6BL,MAAM,CAACM,IAAP,CAAY,GAAZ,CAA3C;AACA;AACJ;AACA;;AACI,MAAIF,KAAK,KAAK,KAAd,EAAqB;AACjB,WAAO;AACHF,MAAAA,KADG;AAEHK,MAAAA,SAAS,EAAE,IAFR;AAGHC,MAAAA,MAAM,EAAE;AAHL,KAAP;AAKH;;AACD,QAAMA,MAAM,GAAGJ,KAAK,CAACK,KAAN,CAAY,MAAZ,MAAwB,IAAvC;AACA,QAAMF,SAAS,GAAGH,KAAK,CAACM,OAAN,CAAc,MAAd,EAAsB,EAAtB,CAAlB;AACA,SAAO;AAAER,IAAAA,KAAF;AAASK,IAAAA,SAAT;AAAoBC,IAAAA;AAApB,GAAP;AACH,CAjBD;;AAmBA,MAAMG,aAAa,GAAItB,MAAD,IAA6C;AAC/D,QAAM;AAAEC,IAAAA,OAAF;AAAWsB,IAAAA;AAAX,MAAqBvB,MAA3B;AAEA,QAAMwB,IAAI,GAAGC,MAAM,CAACD,IAAP,CAAYD,KAAZ,CAAb;AACA;AACJ;AACA;;AACI,MAAIC,IAAI,CAACR,MAAL,KAAgB,CAApB,EAAuB;AACnB,WAAO,EAAP;AACH;;AACD,QAAMU,aAAa,GAAG3B,gBAAgB,CAAoB;AACtDE,IAAAA,OADsD;AAEtDG,IAAAA,IAAI,EAAEuB,qCAAkBvB,IAF8B;AAGtDI,IAAAA,QAAQ,EAAE;AAH4C,GAApB,CAAtC;AAKA,QAAMoB,gBAAgB,GAAG3B,OAAO,CAACC,OAAR,CAAgBC,MAAhB,CAAwC0B,iCAAgBzB,IAAxD,CAAzB;AACA,QAAM0B,qBAAqB,GAAG7B,OAAO,CAACC,OAAR,CAAgBC,MAAhB,CAC1B4B,2CAAqB3B,IADK,CAA9B;AAIA,SAAOoB,IAAI,CACNQ,GADE,CACEtB,GAAG,IAAI;AACR,UAAM;AAAEG,MAAAA,KAAF;AAASK,MAAAA,SAAT;AAAoBC,MAAAA;AAApB,QAA+BV,gBAAgB,CAACC,GAAD,CAArD;AACA,UAAMuB,KAAK,GAAGV,KAAK,CAACb,GAAD,CAAnB;;AACA,QAAIuB,KAAK,KAAKC,SAAd,EAAyB;AACrB,aAAO,IAAP;AACH;;AAED,UAAMC,YAAY,GAAGT,aAAa,CAACR,SAAD,CAAlC;;AACA,QAAI,CAACiB,YAAL,EAAmB;AACf,YAAM,IAAIC,cAAJ,CAAiB,mCAAjB,EAAqD,qBAArD,EAA4E;AAC9ElB,QAAAA;AAD8E,OAA5E,CAAN;AAGH;;AACD,UAAMmB,oBAAoB,GAAGP,qBAAqB,CAACQ,IAAtB,CAA2BhC,MAAM,IAC1DA,MAAM,CAACiC,YAAP,CAAoB1B,KAApB,CADyB,CAA7B;AAGA,UAAM2B,eAAe,GAAGZ,gBAAgB,CAACU,IAAjB,CAAsBhC,MAAM,IAAIA,MAAM,CAACmC,SAAP,CAAiB5B,KAAjB,CAAhC,CAAxB;AAEA,WAAO;AACHA,MAAAA,KADG;AAEH6B,MAAAA,YAAY,EAAET,KAFX;AAGHE,MAAAA,YAHG;AAIHE,MAAAA,oBAJG;AAKHM,MAAAA,IAAI,EAAEH,eAAe,GAAGA,eAAe,CAACI,UAAhB,CAA2B/B,KAA3B,CAAH,GAAuCA,KALzD;AAMHM,MAAAA;AANG,KAAP;AAQH,GA3BE,EA4BF0B,MA5BE,CA4BKC,OA5BL,CAAP;AA6BH,CAjDD;AAkDA;AACA;AACA;;;AACA,MAAMC,SAAS,GAAG,CAACd,KAAD,EAAaI,oBAAb,KAAkE;AAChF,MAAI,CAACA,oBAAL,EAA2B;AACvB,WAAOJ,KAAP;AACH;;AACD,MAAIe,KAAK,CAACC,OAAN,CAAchB,KAAd,CAAJ,EAA0B;AACtB,WAAOA,KAAK,CAACD,GAAN,CAAUkB,CAAC,IAAIb,oBAAoB,CAACU,SAArB,CAA+BG,CAA/B,CAAf,CAAP;AACH;;AACD,SAAOb,oBAAoB,CAACU,SAArB,CAA+Bd,KAA/B,CAAP;AACH,CARD;AASA;AACA;AACA;;;AACA,MAAMkB,oBAAoB,GAAG,CAAC;AAAE5B,EAAAA,KAAF;AAAStB,EAAAA;AAAT,CAAD,KAAyD;AAClF,QAAMmD,OAAO,GAAG9B,aAAa,CAAC;AAC1BC,IAAAA,KAD0B;AAE1BtB,IAAAA;AAF0B,GAAD,CAA7B;AAIA;AACJ;AACA;AACA;;AACI,MAAImD,OAAO,CAACpC,MAAR,KAAmB,CAAvB,EAA0B;AACtB,WAAO,IAAP;AACH;;AAED,SAAQqC,IAAD,IAAe;AAClB,SAAK,MAAMR,MAAX,IAAqBO,OAArB,EAA8B;AAC1B,YAAMnB,KAAK,GAAGc,SAAS,CAACO,iBAAQC,GAAR,CAAYF,IAAZ,EAAkBR,MAAM,CAACF,IAAzB,CAAD,EAAiCE,MAAM,CAACR,oBAAxC,CAAvB;AACA,YAAMK,YAAY,GAAGK,SAAS,CAACF,MAAM,CAACH,YAAR,EAAsBG,MAAM,CAACR,oBAA7B,CAA9B;AACA,YAAMmB,OAAO,GAAGX,MAAM,CAACV,YAAP,CAAoBsB,OAApB,CAA4B;AACxCxB,QAAAA,KADwC;AAExCS,QAAAA;AAFwC,OAA5B,CAAhB;;AAIA,UAAI,CAACG,MAAM,CAAC1B,MAAP,GAAgB,CAACqC,OAAjB,GAA2BA,OAA5B,MAAyC,KAA7C,EAAoD;AAChD,eAAO,KAAP;AACH;AACJ;;AACD,WAAO,IAAP;AACH,GAbD;AAcH,CA3BD;;AA6BO,MAAME,WAAW,GAAyB1D,MAAtB,IAAiD;AACxE,QAAM;AAAE2D,IAAAA,KAAF;AAASpC,IAAAA,KAAT;AAAgBtB,IAAAA;AAAhB,MAA4BD,MAAlC;AACA,QAAM6C,MAAM,GAAGM,oBAAoB,CAAC;AAChC5B,IAAAA,KADgC;AAEhCtB,IAAAA;AAFgC,GAAD,CAAnC;AAIA;AACJ;AACA;;AACI,MAAI,CAAC4C,MAAL,EAAa;AACT,WAAOc,KAAP;AACH;;AACD,SAAOA,KAAK,CAACd,MAAN,CAAaA,MAAb,CAAP;AACH,CAbM","sourcesContent":["import dotProp from \"dot-prop\";\nimport WebinyError from \"@webiny/error\";\nimport { Plugin } from \"@webiny/plugins\";\nimport { ValueFilterPlugin } from \"~/plugins/definitions/ValueFilterPlugin\";\nimport { ValueTransformPlugin } from \"~/plugins/definitions/ValueTransformPlugin\";\nimport { FieldPathPlugin } from \"~/plugins/definitions/FieldPathPlugin\";\nimport { ContextInterface } from \"@webiny/handler/types\";\n\nexport interface Params<T extends any = any> {\n    items: T[];\n    where: Record<string, any>;\n    context: ContextInterface;\n}\n\ninterface MappedPluginParams {\n    context: ContextInterface;\n    type: string;\n    property: string;\n}\n\ninterface Filter {\n    compareValue: any;\n    filterPlugin: ValueFilterPlugin;\n    transformValuePlugin: ValueTransformPlugin;\n    path: string;\n    negate: boolean;\n}\n\nconst getMappedPlugins = <T extends Plugin>(params: MappedPluginParams): Record<string, T> => {\n    return params.context.plugins.byType<T>(params.type).reduce((plugins, plugin) => {\n        const op = plugin[params.property];\n        plugins[op] = plugin;\n        return plugins;\n    }, {});\n};\n\nconst extractWhereArgs = (key: string) => {\n    const result = key.split(\"_\");\n    const field = result.shift();\n    const rawOp = result.length === 0 ? \"eq\" : result.join(\"_\");\n    /**\n     * When rawOp is not, it means it is equal negated so just return that.\n     */\n    if (rawOp === \"not\") {\n        return {\n            field,\n            operation: \"eq\",\n            negate: true\n        };\n    }\n    const negate = rawOp.match(\"not_\") !== null;\n    const operation = rawOp.replace(\"not_\", \"\");\n    return { field, operation, negate };\n};\n\nconst createFilters = (params: Omit<Params, \"items\">): Filter[] => {\n    const { context, where } = params;\n\n    const keys = Object.keys(where);\n    /**\n     * Skip everything if there are no conditions to be applied.\n     */\n    if (keys.length === 0) {\n        return [];\n    }\n    const filterPlugins = getMappedPlugins<ValueFilterPlugin>({\n        context,\n        type: ValueFilterPlugin.type,\n        property: \"operation\"\n    });\n    const fieldPathPlugins = context.plugins.byType<FieldPathPlugin>(FieldPathPlugin.type);\n    const transformValuePlugins = context.plugins.byType<ValueTransformPlugin>(\n        ValueTransformPlugin.type\n    );\n\n    return keys\n        .map(key => {\n            const { field, operation, negate } = extractWhereArgs(key);\n            const value = where[key];\n            if (value === undefined) {\n                return null;\n            }\n\n            const filterPlugin = filterPlugins[operation];\n            if (!filterPlugin) {\n                throw new WebinyError(`Missing filter plugin definition.`, \"FILTER_PLUGIN_ERROR\", {\n                    operation\n                });\n            }\n            const transformValuePlugin = transformValuePlugins.find(plugin =>\n                plugin.canTransform(field)\n            );\n            const fieldPathPlugin = fieldPathPlugins.find(plugin => plugin.canCreate(field));\n\n            return {\n                field,\n                compareValue: value,\n                filterPlugin,\n                transformValuePlugin,\n                path: fieldPathPlugin ? fieldPathPlugin.createPath(field) : field,\n                negate\n            };\n        })\n        .filter(Boolean);\n};\n/**\n * Transforms the value with given transformer callable.\n */\nconst transform = (value: any, transformValuePlugin?: ValueTransformPlugin): any => {\n    if (!transformValuePlugin) {\n        return value;\n    }\n    if (Array.isArray(value)) {\n        return value.map(v => transformValuePlugin.transform(v));\n    }\n    return transformValuePlugin.transform(value);\n};\n/**\n * Creates a filter callable that we can send to the .filter() method of the array.\n */\nconst createFilterCallable = ({ where, context }): ((item: any) => boolean) | null => {\n    const filters = createFilters({\n        where,\n        context\n    });\n    /**\n     * Just return null so there are no filters to be applied.\n     * Later in the code we check for null so we do not loop through the items.\n     */\n    if (filters.length === 0) {\n        return null;\n    }\n\n    return (item: any) => {\n        for (const filter of filters) {\n            const value = transform(dotProp.get(item, filter.path), filter.transformValuePlugin);\n            const compareValue = transform(filter.compareValue, filter.transformValuePlugin);\n            const matched = filter.filterPlugin.matches({\n                value,\n                compareValue\n            });\n            if ((filter.negate ? !matched : matched) === false) {\n                return false;\n            }\n        }\n        return true;\n    };\n};\n\nexport const filterItems = <T extends any = any>(params: Params<T>): T[] => {\n    const { items, where, context } = params;\n    const filter = createFilterCallable({\n        where,\n        context\n    });\n    /**\n     * No point in going through all the items when there are no filters to be applied.\n     */\n    if (!filter) {\n        return items;\n    }\n    return items.filter(filter);\n};\n"],"file":"filter.js"}