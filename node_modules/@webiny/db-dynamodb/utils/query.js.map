{"version":3,"sources":["../../src/utils/query.ts"],"names":["query","params","entity","previous","partitionKey","options","result","next","items","Items","Array","isArray","WebinyError","queryOne","limit","queryAll","results","previousResult","undefined","push"],"mappings":";;;;;;;;;;;AACA;;;;;;AAsBA;AACA;AACA;AACA;AACA;AACA,MAAMA,KAAK,GAAG,MAAUC,MAAV,IAA2D;AACrE,QAAM;AAAEC,IAAAA,MAAF;AAAUC,IAAAA,QAAV;AAAoBC,IAAAA,YAApB;AAAkCC,IAAAA;AAAlC,MAA8CJ,MAApD;AACA,MAAIK,MAAJ;AACA;AACJ;AACA;AACA;;AACI,MAAI,CAACH,QAAL,EAAe;AACXG,IAAAA,MAAM,GAAG,MAAMJ,MAAM,CAACF,KAAP,CAAaI,YAAb,EAA2BC,OAA3B,CAAf;AACH,GAFD,MAEO,IAAI,OAAOF,QAAQ,CAACI,IAAhB,KAAyB,UAA7B,EAAyC;AAC5C;AACR;AACA;AACA;AACA;AACQD,IAAAA,MAAM,GAAG,MAAMH,QAAQ,CAACI,IAAT,EAAf;;AACA,QAAID,MAAM,KAAK,KAAf,EAAsB;AAClB,aAAO;AACHA,QAAAA,MAAM,EAAE,IADL;AAEHE,QAAAA,KAAK,EAAE;AAFJ,OAAP;AAIH;AACJ,GAbM,MAaA;AACH;AACR;AACA;AACA;AACA;AACQ,WAAO;AACHF,MAAAA,MAAM,EAAE,IADL;AAEHE,MAAAA,KAAK,EAAE;AAFJ,KAAP;AAIH;AACD;AACJ;AACA;;;AACI,MAAI,CAACF,MAAD,IAAW,CAACA,MAAM,CAACG,KAAnB,IAA4B,CAACC,KAAK,CAACC,OAAN,CAAcL,MAAM,CAACG,KAArB,CAAjC,EAA8D;AAC1D,UAAM,IAAIG,cAAJ,CACF,sDADE,EAEF,aAFE,EAGF;AACIR,MAAAA,YADJ;AAEIC,MAAAA;AAFJ,KAHE,CAAN;AAQH;;AACD,SAAO;AACHC,IAAAA,MADG;AAEHE,IAAAA,KAAK,EAAEF,MAAM,CAACG;AAFX,GAAP;AAIH,CAlDD;AAmDA;AACA;AACA;;;AACO,MAAMI,QAAQ,GAAG,MAAUZ,MAAV,IAAwD;AAC5E,QAAM;AAAEO,IAAAA;AAAF,MAAY,MAAMR,KAAK,iCACtBC,MADsB;AAEzBI,IAAAA,OAAO,kCACCJ,MAAM,CAACI,OAAP,IAAkB,EADnB;AAEHS,MAAAA,KAAK,EAAE;AAFJ;AAFkB,KAA7B;AAOA,SAAON,KAAK,CAAC,CAAD,CAAL,IAAY,IAAnB;AACH,CATM;AAUP;AACA;AACA;;;;;AACO,MAAMO,QAAQ,GAAG,MAAUd,MAAV,IAAmD;AACvE,QAAMO,KAAU,GAAG,EAAnB;AACA,MAAIQ,OAAJ;AACA,MAAIC,cAAmB,GAAGC,SAA1B;;AACA,SAAQF,OAAO,GAAG,MAAMhB,KAAK,iCAAMC,MAAN;AAAcE,IAAAA,QAAQ,EAAEc;AAAxB,KAA7B,EAAyE;AACrET,IAAAA,KAAK,CAACW,IAAN,CAAW,GAAGH,OAAO,CAACR,KAAtB;;AACA,QAAI,CAACQ,OAAO,CAACV,MAAb,EAAqB;AACjB,aAAOE,KAAP;AACH;;AACDS,IAAAA,cAAc,GAAGD,OAAO,CAACV,MAAzB;AACH;;AACD,SAAOE,KAAP;AACH,CAZM","sourcesContent":["import { queryOptions as DynamoDBToolboxQueryOptions } from \"dynamodb-toolbox/dist/classes/Table\";\nimport WebinyError from \"@webiny/error\";\nimport { Entity } from \"dynamodb-toolbox\";\n\nexport interface QueryAllParams {\n    entity: Entity<any>;\n    partitionKey: string;\n    options?: DynamoDBToolboxQueryOptions;\n}\n\nexport interface QueryOneParams extends QueryAllParams {\n    options?: Omit<DynamoDBToolboxQueryOptions, \"limit\">;\n}\n\nexport interface QueryParams extends QueryAllParams {\n    previous?: any;\n}\n\nexport interface QueryResult<T> {\n    result: any | null;\n    items: T[];\n}\n\n/**\n * Will run query only once. Pass the previous to run the query again to fetch new data.\n * It returns the result and the items it found.\n * Result is required to fetch the items that were not fetched in the previous run.\n */\nconst query = async <T>(params: QueryParams): Promise<QueryResult<T>> => {\n    const { entity, previous, partitionKey, options } = params;\n    let result;\n    /**\n     * In case there is no previous result we must make a new query.\n     * This is the first query on the given partition key.\n     */\n    if (!previous) {\n        result = await entity.query(partitionKey, options);\n    } else if (typeof previous.next === \"function\") {\n        /**\n         * In case we have a previous result and it has a next method, we run it.\n         * In case result of the next method is false, it means it has nothing else to read\n         * and we return a null to keep the query from repeating.\n         */\n        result = await previous.next();\n        if (result === false) {\n            return {\n                result: null,\n                items: []\n            };\n        }\n    } else {\n        /**\n         * This could probably never happen but keep it here just in case to break the query loop.\n         * Basically, either previous does not exist or it exists and it does not have the next method\n         * and at that point a result returned will be null and loop should not start again.\n         */\n        return {\n            result: null,\n            items: []\n        };\n    }\n    /**\n     * We expect the result to contain an Items array and if not, something went wrong, very wrong.\n     */\n    if (!result || !result.Items || !Array.isArray(result.Items)) {\n        throw new WebinyError(\n            \"Error when querying for content entries - no result.\",\n            \"QUERY_ERROR\",\n            {\n                partitionKey,\n                options\n            }\n        );\n    }\n    return {\n        result,\n        items: result.Items\n    };\n};\n/**\n * Will run the query to fetch the first possible item from the database.\n */\nexport const queryOne = async <T>(params: QueryOneParams): Promise<T | null> => {\n    const { items } = await query<T>({\n        ...params,\n        options: {\n            ...(params.options || {}),\n            limit: 1\n        }\n    });\n    return items[0] || null;\n};\n/**\n * Will run the query to fetch the results no matter how much iterations it needs to go through.\n */\nexport const queryAll = async <T>(params: QueryAllParams): Promise<T[]> => {\n    const items: T[] = [];\n    let results: QueryResult<T>;\n    let previousResult: any = undefined;\n    while ((results = await query({ ...params, previous: previousResult }))) {\n        items.push(...results.items);\n        if (!results.result) {\n            return items;\n        }\n        previousResult = results.result;\n    }\n    return items;\n};\n"],"file":"query.js"}