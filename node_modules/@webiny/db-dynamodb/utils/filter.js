"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.filterItems = void 0;

var _dotProp = _interopRequireDefault(require("dot-prop"));

var _error = _interopRequireDefault(require("@webiny/error"));

var _ValueFilterPlugin = require("../plugins/definitions/ValueFilterPlugin");

var _ValueTransformPlugin = require("../plugins/definitions/ValueTransformPlugin");

var _FieldPathPlugin = require("../plugins/definitions/FieldPathPlugin");

const getMappedPlugins = params => {
  return params.context.plugins.byType(params.type).reduce((plugins, plugin) => {
    const op = plugin[params.property];
    plugins[op] = plugin;
    return plugins;
  }, {});
};

const extractWhereArgs = key => {
  const result = key.split("_");
  const field = result.shift();
  const rawOp = result.length === 0 ? "eq" : result.join("_");
  /**
   * When rawOp is not, it means it is equal negated so just return that.
   */

  if (rawOp === "not") {
    return {
      field,
      operation: "eq",
      negate: true
    };
  }

  const negate = rawOp.match("not_") !== null;
  const operation = rawOp.replace("not_", "");
  return {
    field,
    operation,
    negate
  };
};

const createFilters = params => {
  const {
    context,
    where
  } = params;
  const keys = Object.keys(where);
  /**
   * Skip everything if there are no conditions to be applied.
   */

  if (keys.length === 0) {
    return [];
  }

  const filterPlugins = getMappedPlugins({
    context,
    type: _ValueFilterPlugin.ValueFilterPlugin.type,
    property: "operation"
  });
  const fieldPathPlugins = context.plugins.byType(_FieldPathPlugin.FieldPathPlugin.type);
  const transformValuePlugins = context.plugins.byType(_ValueTransformPlugin.ValueTransformPlugin.type);
  return keys.map(key => {
    const {
      field,
      operation,
      negate
    } = extractWhereArgs(key);
    const value = where[key];

    if (value === undefined) {
      return null;
    }

    const filterPlugin = filterPlugins[operation];

    if (!filterPlugin) {
      throw new _error.default(`Missing filter plugin definition.`, "FILTER_PLUGIN_ERROR", {
        operation
      });
    }

    const transformValuePlugin = transformValuePlugins.find(plugin => plugin.canTransform(field));
    const fieldPathPlugin = fieldPathPlugins.find(plugin => plugin.canCreate(field));
    return {
      field,
      compareValue: value,
      filterPlugin,
      transformValuePlugin,
      path: fieldPathPlugin ? fieldPathPlugin.createPath(field) : field,
      negate
    };
  }).filter(Boolean);
};
/**
 * Transforms the value with given transformer callable.
 */


const transform = (value, transformValuePlugin) => {
  if (!transformValuePlugin) {
    return value;
  }

  if (Array.isArray(value)) {
    return value.map(v => transformValuePlugin.transform(v));
  }

  return transformValuePlugin.transform(value);
};
/**
 * Creates a filter callable that we can send to the .filter() method of the array.
 */


const createFilterCallable = ({
  where,
  context
}) => {
  const filters = createFilters({
    where,
    context
  });
  /**
   * Just return null so there are no filters to be applied.
   * Later in the code we check for null so we do not loop through the items.
   */

  if (filters.length === 0) {
    return null;
  }

  return item => {
    for (const filter of filters) {
      const value = transform(_dotProp.default.get(item, filter.path), filter.transformValuePlugin);
      const compareValue = transform(filter.compareValue, filter.transformValuePlugin);
      const matched = filter.filterPlugin.matches({
        value,
        compareValue
      });

      if ((filter.negate ? !matched : matched) === false) {
        return false;
      }
    }

    return true;
  };
};

const filterItems = params => {
  const {
    items,
    where,
    context
  } = params;
  const filter = createFilterCallable({
    where,
    context
  });
  /**
   * No point in going through all the items when there are no filters to be applied.
   */

  if (!filter) {
    return items;
  }

  return items.filter(filter);
};

exports.filterItems = filterItems;
//# sourceMappingURL=filter.js.map