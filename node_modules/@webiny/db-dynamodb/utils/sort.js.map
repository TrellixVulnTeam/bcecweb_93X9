{"version":3,"sources":["../../src/utils/sort.ts"],"names":["extractSort","sortBy","fields","result","split","length","WebinyError","field","order","includes","reverse","sortItems","params","context","items","sort","push","firstSort","fieldPathPlugin","plugins","byType","FieldPathPlugin","type","find","plugin","canCreate","path","createPath","sortedItems"],"mappings":";;;;;;;;;AAAA;;AACA;;AACA;;AAOA,MAAMA,WAAW,GAAG,CAACC,MAAD,EAAiBC,MAAjB,KAAyD;AACzE,QAAMC,MAAM,GAAGF,MAAM,CAACG,KAAP,CAAa,GAAb,CAAf;;AACA,MAAID,MAAM,CAACE,MAAP,KAAkB,CAAtB,EAAyB;AACrB,UAAM,IAAIC,cAAJ,CACF,yDADE,EAEF,YAFE,EAGF;AACIL,MAAAA;AADJ,KAHE,CAAN;AAOH;;AACD,QAAM,CAACM,KAAD,EAAQC,KAAR,IAAiBL,MAAvB;;AAEA,MAAI,CAACI,KAAL,EAAY;AACR,UAAM,IAAID,cAAJ,CAAgB,+BAAhB,EAAiD,qBAAjD,EAAwE;AAC1EC,MAAAA,KAD0E;AAE1EC,MAAAA,KAF0E;AAG1EN,MAAAA;AAH0E,KAAxE,CAAN;AAKH,GAND,MAMO,IAAIA,MAAM,CAACO,QAAP,CAAgBF,KAAhB,MAA2B,KAA/B,EAAsC;AACzC,UAAM,IAAID,cAAJ,CAAiB,gCAA+BC,KAAM,IAAtD,EAA2D,wBAA3D,EAAqF;AACvFL,MAAAA,MADuF;AAEvFK,MAAAA;AAFuF,KAArF,CAAN;AAIH;;AAED,SAAO;AACHA,IAAAA,KADG;AAEHG,IAAAA,OAAO,EAAEF,KAAK,KAAK;AAFhB,GAAP;AAIH,CA9BD;;AAsCO,MAAMG,SAAS,GAAyBC,MAAtB,IAAiD;AACtE,QAAM;AAAEC,IAAAA,OAAF;AAAWC,IAAAA,KAAX;AAAkBC,IAAAA,IAAI,GAAG,EAAzB;AAA6Bb,IAAAA;AAA7B,MAAwCU,MAA9C;;AACA,MAAIE,KAAK,CAACT,MAAN,IAAgB,CAApB,EAAuB;AACnB,WAAOS,KAAP;AACH,GAFD,MAEO,IAAIC,IAAI,CAACV,MAAL,KAAgB,CAApB,EAAuB;AAC1BU,IAAAA,IAAI,CAACC,IAAL,CAAU,gBAAV;AACH,GAFM,MAEA,IAAID,IAAI,CAACV,MAAL,GAAc,CAAlB,EAAqB;AACxB,UAAM,IAAIC,cAAJ,CAAgB,sCAAhB,EAAwD,YAAxD,EAAsE;AACxES,MAAAA,IAAI,EAAEA;AADkE,KAAtE,CAAN;AAGH;;AACD,QAAM,CAACE,SAAD,IAAcF,IAApB;;AACA,MAAI,CAACE,SAAL,EAAgB;AACZ,UAAM,IAAIX,cAAJ,CAAgB,wBAAhB,EAA0C,YAA1C,EAAwD;AAC1DS,MAAAA;AAD0D,KAAxD,CAAN;AAGH;;AAED,QAAM;AAAER,IAAAA,KAAF;AAASG,IAAAA;AAAT,MAAqBV,WAAW,CAACiB,SAAD,EAAYf,MAAZ,CAAtC;AAEA,QAAMgB,eAAe,GAAGL,OAAO,CAACM,OAAR,CACnBC,MADmB,CACKC,iCAAgBC,IADrB,EAEnBC,IAFmB,CAEdC,MAAM,IAAIA,MAAM,CAACC,SAAP,CAAiBlB,KAAjB,CAFI,CAAxB;AAGA,QAAMmB,IAAI,GAAGR,eAAe,GAAGA,eAAe,CAACS,UAAhB,CAA2BpB,KAA3B,CAAH,GAAuCA,KAAnE;AAEA,QAAMqB,WAAW,GAAG,qBAAad,KAAb,EAAoBY,IAApB,CAApB;;AACA,MAAI,CAAChB,OAAL,EAAc;AACV,WAAOkB,WAAP;AACH;;AACD,SAAOA,WAAW,CAAClB,OAAZ,EAAP;AACH,CA9BM","sourcesContent":["import lodashSortBy from \"lodash.sortby\";\nimport WebinyError from \"@webiny/error\";\nimport { FieldPathPlugin } from \"~/plugins/definitions/FieldPathPlugin\";\nimport { ContextInterface } from \"@webiny/handler/types\";\n\ninterface ExtractSortResult {\n    reverse: boolean;\n    field: string;\n}\nconst extractSort = (sortBy: string, fields: string[]): ExtractSortResult => {\n    const result = sortBy.split(\"_\");\n    if (result.length !== 2) {\n        throw new WebinyError(\n            \"Problem in determining the sorting for the entry items.\",\n            \"SORT_ERROR\",\n            {\n                sortBy\n            }\n        );\n    }\n    const [field, order] = result;\n\n    if (!field) {\n        throw new WebinyError(\"Sorting field does not exist.\", \"SORTING_FIELD_ERROR\", {\n            field,\n            order,\n            fields\n        });\n    } else if (fields.includes(field) === false) {\n        throw new WebinyError(`Cannot sort by given field: \"${field}\".`, \"UNSUPPORTED_SORT_ERROR\", {\n            fields,\n            field\n        });\n    }\n\n    return {\n        field,\n        reverse: order === \"DESC\"\n    };\n};\n\ninterface Params<T> {\n    context: ContextInterface;\n    items: T[];\n    sort: string[];\n    fields: string[];\n}\nexport const sortItems = <T extends any = any>(params: Params<T>): T[] => {\n    const { context, items, sort = [], fields } = params;\n    if (items.length <= 1) {\n        return items;\n    } else if (sort.length === 0) {\n        sort.push(\"createdOn_DESC\");\n    } else if (sort.length > 1) {\n        throw new WebinyError(\"Sorting is limited to a single field\", \"SORT_ERROR\", {\n            sort: sort\n        });\n    }\n    const [firstSort] = sort;\n    if (!firstSort) {\n        throw new WebinyError(\"Empty sort array item.\", \"SORT_ERROR\", {\n            sort\n        });\n    }\n\n    const { field, reverse } = extractSort(firstSort, fields);\n\n    const fieldPathPlugin = context.plugins\n        .byType<FieldPathPlugin>(FieldPathPlugin.type)\n        .find(plugin => plugin.canCreate(field));\n    const path = fieldPathPlugin ? fieldPathPlugin.createPath(field) : field;\n\n    const sortedItems = lodashSortBy(items, path);\n    if (!reverse) {\n        return sortedItems;\n    }\n    return sortedItems.reverse();\n};\n"],"file":"sort.js"}