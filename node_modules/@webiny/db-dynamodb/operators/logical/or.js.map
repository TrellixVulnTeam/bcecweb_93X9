{"version":3,"sources":["../../../src/operators/logical/or.ts"],"names":["processQuery","query","orArgs","processStatement","args","expression","attributeNames","attributeValues","Object","assign","or","canProcess","key","process","value","Array","isArray","i","length","orKey","orValue","entries"],"mappings":";;;;;;;AAEA,MAAMA,YAAY,GAAG,CAACC,KAAD,EAAQC,MAAR,EAAgBC,gBAAhB,KAAqC;AACtD,QAAMC,IAAI,GAAG;AACTC,IAAAA,UAAU,EAAE,EADH;AAETC,IAAAA,cAAc,EAAE,EAFP;AAGTC,IAAAA,eAAe,EAAE;AAHR,GAAb;AAMAJ,EAAAA,gBAAgB,CAAC;AAAEC,IAAAA,IAAF;AAAQH,IAAAA;AAAR,GAAD,CAAhB;AAEAO,EAAAA,MAAM,CAACC,MAAP,CAAcP,MAAM,CAACI,cAArB,EAAqCF,IAAI,CAACE,cAA1C;AACAE,EAAAA,MAAM,CAACC,MAAP,CAAcP,MAAM,CAACK,eAArB,EAAsCH,IAAI,CAACG,eAA3C;;AAEA,MAAIL,MAAM,CAACG,UAAP,KAAsB,EAA1B,EAA8B;AAC1BH,IAAAA,MAAM,CAACG,UAAP,GAAoBD,IAAI,CAACC,UAAzB;AACH,GAFD,MAEO;AACHH,IAAAA,MAAM,CAACG,UAAP,IAAqB,SAASD,IAAI,CAACC,UAAnC;AACH;AACJ,CAjBD;;AAmBA,MAAMK,EAAY,GAAG;AACjBC,EAAAA,UAAU,EAAE,CAAC;AAAEC,IAAAA;AAAF,GAAD,KAAa;AACrB,WAAOA,GAAG,KAAK,KAAf;AACH,GAHgB;AAIjBC,EAAAA,OAAO,EAAE,CAAC;AAAEC,IAAAA,KAAF;AAASV,IAAAA,IAAT;AAAeD,IAAAA;AAAf,GAAD,KAAuC;AAC5C,UAAMD,MAAM,GAAG;AACXG,MAAAA,UAAU,EAAE,EADD;AAEXC,MAAAA,cAAc,EAAE,EAFL;AAGXC,MAAAA,eAAe,EAAE;AAHN,KAAf;;AAMA,QAAIQ,KAAK,CAACC,OAAN,CAAcF,KAAd,CAAJ,EAA0B;AACtB,WAAK,IAAIG,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGH,KAAK,CAACI,MAA1B,EAAkCD,CAAC,EAAnC,EAAuC;AACnCjB,QAAAA,YAAY,CAACc,KAAK,CAACG,CAAD,CAAN,EAAWf,MAAX,EAAmBC,gBAAnB,CAAZ;AACH;AACJ,KAJD,MAIO;AACH,WAAK,MAAM,CAACgB,KAAD,EAAQC,OAAR,CAAX,IAA+BZ,MAAM,CAACa,OAAP,CAAeP,KAAf,CAA/B,EAAsD;AAClDd,QAAAA,YAAY,CAAC;AAAE,WAACmB,KAAD,GAASC;AAAX,SAAD,EAAuBlB,MAAvB,EAA+BC,gBAA/B,CAAZ;AACH;AACJ;;AAEDC,IAAAA,IAAI,CAACC,UAAL,IAAmB,MAAMH,MAAM,CAACG,UAAb,GAA0B,GAA7C;AACAG,IAAAA,MAAM,CAACC,MAAP,CAAcL,IAAI,CAACE,cAAnB,EAAmCJ,MAAM,CAACI,cAA1C;AACAE,IAAAA,MAAM,CAACC,MAAP,CAAcL,IAAI,CAACG,eAAnB,EAAoCL,MAAM,CAACK,eAA3C;AACH;AAxBgB,CAArB;eA2BeG,E","sourcesContent":["import { Operator } from \"../../types\";\n\nconst processQuery = (query, orArgs, processStatement) => {\n    const args = {\n        expression: \"\",\n        attributeNames: {},\n        attributeValues: {}\n    };\n\n    processStatement({ args, query });\n\n    Object.assign(orArgs.attributeNames, args.attributeNames);\n    Object.assign(orArgs.attributeValues, args.attributeValues);\n\n    if (orArgs.expression === \"\") {\n        orArgs.expression = args.expression;\n    } else {\n        orArgs.expression += \" or \" + args.expression;\n    }\n};\n\nconst or: Operator = {\n    canProcess: ({ key }) => {\n        return key === \"$or\";\n    },\n    process: ({ value, args, processStatement }) => {\n        const orArgs = {\n            expression: \"\",\n            attributeNames: {},\n            attributeValues: {}\n        };\n\n        if (Array.isArray(value)) {\n            for (let i = 0; i < value.length; i++) {\n                processQuery(value[i], orArgs, processStatement);\n            }\n        } else {\n            for (const [orKey, orValue] of Object.entries(value)) {\n                processQuery({ [orKey]: orValue }, orArgs, processStatement);\n            }\n        }\n\n        args.expression += \"(\" + orArgs.expression + \")\";\n        Object.assign(args.attributeNames, orArgs.attributeNames);\n        Object.assign(args.attributeValues, orArgs.attributeValues);\n    }\n};\n\nexport default or;\n"],"file":"or.js"}