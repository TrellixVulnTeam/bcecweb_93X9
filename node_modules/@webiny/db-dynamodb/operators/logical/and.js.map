{"version":3,"sources":["../../../src/operators/logical/and.ts"],"names":["processQuery","query","andArgs","processStatement","args","expression","attributeNames","attributeValues","Object","assign","and","canProcess","key","process","value","Array","isArray","i","length","andKey","andValue","entries"],"mappings":";;;;;;;AAEA,MAAMA,YAAY,GAAG,CAACC,KAAD,EAAQC,OAAR,EAAiBC,gBAAjB,KAAsC;AACvD,QAAMC,IAAI,GAAG;AACTC,IAAAA,UAAU,EAAE,EADH;AAETC,IAAAA,cAAc,EAAE,EAFP;AAGTC,IAAAA,eAAe,EAAE;AAHR,GAAb;AAMAJ,EAAAA,gBAAgB,CAAC;AAAEC,IAAAA,IAAF;AAAQH,IAAAA;AAAR,GAAD,CAAhB;AAEAO,EAAAA,MAAM,CAACC,MAAP,CAAcP,OAAO,CAACI,cAAtB,EAAsCF,IAAI,CAACE,cAA3C;AACAE,EAAAA,MAAM,CAACC,MAAP,CAAcP,OAAO,CAACK,eAAtB,EAAuCH,IAAI,CAACG,eAA5C;;AAEA,MAAIL,OAAO,CAACG,UAAR,KAAuB,EAA3B,EAA+B;AAC3BH,IAAAA,OAAO,CAACG,UAAR,GAAqBD,IAAI,CAACC,UAA1B;AACH,GAFD,MAEO;AACHH,IAAAA,OAAO,CAACG,UAAR,IAAsB,UAAUD,IAAI,CAACC,UAArC;AACH;AACJ,CAjBD;;AAmBA,MAAMK,GAAa,GAAG;AAClBC,EAAAA,UAAU,EAAE,CAAC;AAAEC,IAAAA;AAAF,GAAD,KAAa;AACrB,WAAOA,GAAG,KAAK,MAAf;AACH,GAHiB;AAIlBC,EAAAA,OAAO,EAAE,CAAC;AAAEC,IAAAA,KAAF;AAASV,IAAAA,IAAT;AAAeD,IAAAA;AAAf,GAAD,KAAuC;AAC5C,UAAMD,OAAO,GAAG;AACZG,MAAAA,UAAU,EAAE,EADA;AAEZC,MAAAA,cAAc,EAAE,EAFJ;AAGZC,MAAAA,eAAe,EAAE;AAHL,KAAhB;;AAMA,QAAIQ,KAAK,CAACC,OAAN,CAAcF,KAAd,CAAJ,EAA0B;AACtB,WAAK,IAAIG,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGH,KAAK,CAACI,MAA1B,EAAkCD,CAAC,EAAnC,EAAuC;AACnCjB,QAAAA,YAAY,CAACc,KAAK,CAACG,CAAD,CAAN,EAAWf,OAAX,EAAoBC,gBAApB,CAAZ;AACH;AACJ,KAJD,MAIO;AACH,WAAK,MAAM,CAACgB,MAAD,EAASC,QAAT,CAAX,IAAiCZ,MAAM,CAACa,OAAP,CAAeP,KAAf,CAAjC,EAAwD;AACpDd,QAAAA,YAAY,CAAC;AAAE,WAACmB,MAAD,GAAUC;AAAZ,SAAD,EAAyBlB,OAAzB,EAAkCC,gBAAlC,CAAZ;AACH;AACJ;;AAEDC,IAAAA,IAAI,CAACC,UAAL,IAAmB,MAAMH,OAAO,CAACG,UAAd,GAA2B,GAA9C;AACAG,IAAAA,MAAM,CAACC,MAAP,CAAcL,IAAI,CAACE,cAAnB,EAAmCJ,OAAO,CAACI,cAA3C;AACAE,IAAAA,MAAM,CAACC,MAAP,CAAcL,IAAI,CAACG,eAAnB,EAAoCL,OAAO,CAACK,eAA5C;AACH;AAxBiB,CAAtB;eA2BeG,G","sourcesContent":["import { Operator } from \"../../types\";\n\nconst processQuery = (query, andArgs, processStatement) => {\n    const args = {\n        expression: \"\",\n        attributeNames: {},\n        attributeValues: {}\n    };\n\n    processStatement({ args, query });\n\n    Object.assign(andArgs.attributeNames, args.attributeNames);\n    Object.assign(andArgs.attributeValues, args.attributeValues);\n\n    if (andArgs.expression === \"\") {\n        andArgs.expression = args.expression;\n    } else {\n        andArgs.expression += \" and \" + args.expression;\n    }\n};\n\nconst and: Operator = {\n    canProcess: ({ key }) => {\n        return key === \"$and\";\n    },\n    process: ({ value, args, processStatement }) => {\n        const andArgs = {\n            expression: \"\",\n            attributeNames: {},\n            attributeValues: {}\n        };\n\n        if (Array.isArray(value)) {\n            for (let i = 0; i < value.length; i++) {\n                processQuery(value[i], andArgs, processStatement);\n            }\n        } else {\n            for (const [andKey, andValue] of Object.entries(value)) {\n                processQuery({ [andKey]: andValue }, andArgs, processStatement);\n            }\n        }\n\n        args.expression += \"(\" + andArgs.expression + \")\";\n        Object.assign(args.attributeNames, andArgs.attributeNames);\n        Object.assign(args.attributeValues, andArgs.attributeValues);\n    }\n};\n\nexport default and;\n"],"file":"and.js"}