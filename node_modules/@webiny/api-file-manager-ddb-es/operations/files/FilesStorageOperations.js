"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.FilesStorageOperations = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _error = _interopRequireDefault(require("@webiny/error"));

var _table = _interopRequireDefault(require("../../definitions/table"));

var _tableElasticsearch = _interopRequireDefault(require("../../definitions/tableElasticsearch"));

var _filesEntity = _interopRequireDefault(require("../../definitions/filesEntity"));

var _filesElasticsearchEntity = _interopRequireDefault(require("../../definitions/filesElasticsearchEntity"));

var _configurations = _interopRequireDefault(require("../configurations"));

var _lodash = _interopRequireDefault(require("lodash.omit"));

var _lodash2 = _interopRequireDefault(require("lodash.chunk"));

var _cursors = require("@webiny/api-elasticsearch/cursors");

var _body = require("./body");

var _transformers = require("./transformers");

var _FileIndexTransformPlugin = require("../../plugins/FileIndexTransformPlugin");

var _limit = require("@webiny/api-elasticsearch/limit");

var _compression = require("@webiny/api-elasticsearch/compression");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

const SORT_KEY = "A";
/**
 * This is required due to sometimes file data sent is from the DynamoDB and we want to remove the unnecessary stuff.
 */

const cleanStorageFile = file => {
  return (0, _lodash.default)(file, ["PK", "SK", "TYPE", "created", "modified", "entity"]);
};

class FilesStorageOperations {
  get esIndex() {
    if (!this._esIndex) {
      const {
        index: esIndex
      } = _configurations.default.es(this.context);

      this._esIndex = esIndex;
    }

    return this._esIndex;
  }

  get esClient() {
    const ctx = this.context;

    if (!ctx.elasticsearch) {
      throw new _error.default("Missing Elasticsearch client on the context.", "ELASTICSEARCH_CLIENT_ERROR");
    }

    return ctx.elasticsearch;
  }

  get partitionKeyPrefix() {
    const tenant = this.context.tenancy.getCurrentTenant();
    const locale = this.context.i18nContent.getLocale();

    if (!tenant) {
      throw new _error.default("Tenant missing.", "TENANT_NOT_FOUND");
    }

    if (!locale) {
      throw new Error("Locale missing.");
    }

    return `T#${tenant.id}#L#${locale.code}#FM`;
  }

  constructor({
    context
  }) {
    (0, _defineProperty2.default)(this, "context", void 0);
    (0, _defineProperty2.default)(this, "_table", void 0);
    (0, _defineProperty2.default)(this, "_esTable", void 0);
    (0, _defineProperty2.default)(this, "_entity", void 0);
    (0, _defineProperty2.default)(this, "_esEntity", void 0);
    (0, _defineProperty2.default)(this, "_esIndex", void 0);
    this.context = context;
    this._table = (0, _table.default)({
      context
    });
    this._entity = (0, _filesEntity.default)({
      context,
      table: this._table
    });
    this._esTable = (0, _tableElasticsearch.default)({
      context
    });
    this._esEntity = (0, _filesElasticsearchEntity.default)({
      context,
      table: this._esTable
    });
  }

  async get(id) {
    try {
      const file = await this._entity.get({
        PK: this.getPartitionKey(id),
        SK: SORT_KEY
      });

      if (!file || !file.Item) {
        return null;
      }

      return cleanStorageFile(file.Item);
    } catch (ex) {
      throw new _error.default(ex.message || "Could not fetch requested file.", ex.code || "GET_FILE_ERROR", {
        id
      });
    }
  }

  async create(params) {
    const {
      file
    } = params;
    const keys = {
      PK: this.getPartitionKey(file.id),
      SK: SORT_KEY
    };

    const item = _objectSpread(_objectSpread({}, keys), {}, {
      TYPE: "fm.file"
    }, file);

    const esData = await (0, _transformers.transformToIndex)({
      plugins: this.getFileIndexTransformPlugins(),
      file
    });
    const esCompressedData = await (0, _compression.compress)(this.context, esData);

    const esItem = _objectSpread(_objectSpread({}, keys), {}, {
      index: this.esIndex,
      data: esCompressedData
    });

    try {
      await this._entity.put(item);
      await this._esEntity.put(esItem);
    } catch (ex) {
      throw new _error.default(ex.message || "Could not create a new file in the DynamoDB.", ex.code || "CREATE_FILE_ERROR", {
        item,
        esItem
      });
    }

    return file;
  }

  async update({
    file
  }) {
    const keys = {
      PK: this.getPartitionKey(file.id),
      SK: SORT_KEY
    };

    const item = _objectSpread(_objectSpread({}, keys), {}, {
      TYPE: "fm.file"
    }, file);

    const esData = await (0, _transformers.transformToIndex)({
      plugins: this.getFileIndexTransformPlugins(),
      file
    });
    const esCompressedData = await (0, _compression.compress)(this.context, esData);

    const esItem = _objectSpread(_objectSpread({}, keys), {}, {
      index: this.esIndex,
      data: esCompressedData
    });

    try {
      await this._entity.put(item);
      await this._esEntity.put(esItem);
    } catch (ex) {
      throw new _error.default(ex.message || "Could not update a file in the DynamoDB.", ex.code || "UPDATE_FILE_ERROR", {
        item,
        esItem
      });
    }

    return file;
  }

  async delete(id) {
    const keys = {
      PK: this.getPartitionKey(id),
      SK: SORT_KEY
    };

    try {
      await this._table.batchWrite([this._entity.deleteBatch(keys), this._esEntity.deleteBatch(keys)]);
    } catch (ex) {
      throw new _error.default(ex.message || "Could not delete file from the DynamoDB.", ex.code || "DELETE_FILE_ERROR", {
        id
      });
    }
  }

  async createBatch({
    files
  }) {
    const fileChunks = (0, _lodash2.default)(files, 12);

    for (const fileChunk of fileChunks) {
      const batches = [];

      for (const file of fileChunk) {
        const keys = {
          PK: this.getPartitionKey(file.id),
          SK: SORT_KEY
        };
        batches.push(this._entity.putBatch(_objectSpread(_objectSpread({}, keys), {}, {
          TYPE: "fm.file"
        }, file)));
        const esCompressedData = await (0, _compression.compress)(this.context, file);
        batches.push(this._esEntity.putBatch(_objectSpread(_objectSpread({}, keys), {}, {
          index: this.esIndex,
          data: esCompressedData
        })));
      }

      try {
        await this._table.batchWrite(batches);
      } catch (ex) {
        throw new _error.default(ex.message || "Could not batch insert a list of files.", ex.code || "BATCH_CREATE_FILES_ERROR", {
          files: fileChunk,
          items: batches
        });
      }
    }

    return files;
  }

  async list(params) {
    const {
      where,
      limit,
      after,
      sort
    } = params;
    const body = (0, _body.createElasticsearchBody)({
      context: this.context,
      where,
      limit,
      sort,
      after
    });
    let response;

    try {
      response = await this.esClient.search(_objectSpread(_objectSpread({}, _configurations.default.es(this.context)), {}, {
        body
      }));
    } catch (ex) {
      throw new _error.default(ex.message || "Could not search for the files.", ex.code || "FILE_LIST_ERROR", {
        where,
        esBody: body
      });
    }

    const plugins = this.getFileIndexTransformPlugins();
    const {
      hits,
      total
    } = response.body.hits;
    const files = await Promise.all(hits.map(async item => {
      return await (0, _transformers.transformFromIndex)({
        plugins,
        file: item._source
      });
    }));
    let hasMoreItems = false;

    if (files.length > limit) {
      files.pop();
      hasMoreItems = true;
    }

    const meta = {
      hasMoreItems,
      totalCount: total.value,
      cursor: files.length > 0 ? (0, _cursors.encodeCursor)(hits[files.length - 1].sort) : null
    };
    return [files, meta];
  }

  async tags(params) {
    const {
      where,
      limit: initialLimit
    } = params;

    const esDefaults = _configurations.default.es(this.context);

    const must = [];

    if (where.locale) {
      must.push({
        term: {
          "locale.keyword": where.locale
        }
      });
    } // When ES index is shared between tenants, we need to filter records by tenant ID


    const sharedIndex = process.env.ELASTICSEARCH_SHARED_INDEXES === "true";

    if (sharedIndex) {
      const tenant = this.context.tenancy.getCurrentTenant();
      must.push({
        term: {
          "tenant.keyword": tenant.id
        }
      });
    }

    const limit = (0, _limit.createLimit)(initialLimit);
    const body = {
      query: {
        bool: {
          must
        }
      },
      size: limit + 1,
      aggs: {
        listTags: {
          terms: {
            field: "tags.keyword"
          }
        }
      },
      search_after: (0, _cursors.decodeCursor)(null)
    };
    let response = undefined;

    try {
      response = await this.esClient.search(_objectSpread(_objectSpread({}, esDefaults), {}, {
        body
      }));
    } catch (ex) {
      throw new _error.default(ex.message || "Error in the Elasticsearch query.", ex.code || "ELASTICSEARCH_ERROR", {
        body
      });
    }

    const tags = response.body.aggregations.listTags.buckets.map(item => item.key) || [];
    let hasMoreItems = false;
    const totalCount = tags.length;

    if (totalCount > limit + 1) {
      tags.pop();
      hasMoreItems = true;
    }

    const meta = {
      hasMoreItems,
      totalCount,
      cursor: null //tags.length > 0 ? encodeCursor(hits[files.length - 1].sort) : null

    };
    return [tags, meta];
  }
  /**
   * Create the partition key for the file.
   */


  getPartitionKey(id) {
    return `${this.partitionKeyPrefix}#F#${id}`;
  }

  getFileIndexTransformPlugins() {
    return this.context.plugins.byType(_FileIndexTransformPlugin.FileIndexTransformPlugin.type);
  }

}

exports.FilesStorageOperations = FilesStorageOperations;
//# sourceMappingURL=FilesStorageOperations.js.map