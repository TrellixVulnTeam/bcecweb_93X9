{"version":3,"sources":["../../../src/operations/files/body.ts"],"names":["parseWhereKeyRegExp","RegExp","parseWhereKey","key","match","Error","field","operation","op","substr","findFieldPlugin","plugins","fieldPlugin","WebinyError","findOperatorPlugin","operator","createElasticsearchQuery","params","context","where","initialWhere","fieldPlugins","query","must","filter","should","must_not","operatorPlugins","byType","ElasticsearchQueryBuilderOperatorPlugin","type","reduce","acc","plugin","getOperator","sharedIndex","process","env","ELASTICSEARCH_SHARED_INDEXES","tenant","tenancy","getCurrentTenant","push","term","id","search","bool","wildcard","name","terms","tags","toLowerCase","split","hasOwnProperty","initialValue","undefined","operatorPlugin","path","getPath","basePath","getBasePath","value","toSearchValue","apply","keyword","createElasticsearchBody","sort","limit","initialLimit","after","ElasticsearchFieldPlugin","entity","queryModifierPlugins","ElasticsearchQueryModifierPlugin","pl","searchAfter","constant_score","size","search_after"],"mappings":"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","sourcesContent":["import {\n    FileManagerContext,\n    FileManagerFilesStorageOperationsListParamsWhere\n} from \"@webiny/api-file-manager/types\";\nimport { decodeCursor } from \"@webiny/api-elasticsearch/cursors\";\nimport {\n    ElasticsearchBoolQueryConfig,\n    SearchBody as ElasticTsSearchBody\n} from \"@webiny/api-elasticsearch/types\";\nimport { ElasticsearchQueryModifierPlugin } from \"@webiny/api-elasticsearch/plugins/definition/ElasticsearchQueryModifierPlugin\";\nimport { ElasticsearchFieldPlugin } from \"@webiny/api-elasticsearch/plugins/definition/ElasticsearchFieldPlugin\";\nimport { ElasticsearchQueryBuilderOperatorPlugin } from \"@webiny/api-elasticsearch/plugins/definition/ElasticsearchQueryBuilderOperatorPlugin\";\nimport { createLimit } from \"@webiny/api-elasticsearch/limit\";\nimport { createSort } from \"@webiny/api-elasticsearch/sort\";\nimport { normalizeValue } from \"@webiny/api-elasticsearch/normalize\";\nimport WebinyError from \"@webiny/error\";\n\ninterface CreateElasticsearchBodyParams {\n    context: FileManagerContext;\n    where: FileManagerFilesStorageOperationsListParamsWhere;\n    limit: number;\n    after?: string;\n    sort: string[];\n}\n\nconst parseWhereKeyRegExp = new RegExp(/^([a-zA-Z0-9]+)(_[a-zA-Z0-9_]+)?$/);\n\nconst parseWhereKey = (key: string) => {\n    const match = key.match(parseWhereKeyRegExp);\n\n    if (!match) {\n        throw new Error(`It is not possible to search by key \"${key}\"`);\n    }\n\n    const [, field, operation = \"eq\"] = match;\n    const op = operation.match(/^_/) ? operation.substr(1) : operation;\n\n    if (!field.match(/^([a-zA-Z]+)$/)) {\n        throw new Error(`Cannot search by \"${field}\".`);\n    }\n\n    return { field, op };\n};\n\nconst findFieldPlugin = (\n    plugins: Record<string, ElasticsearchFieldPlugin>,\n    field: string\n): ElasticsearchFieldPlugin => {\n    const fieldPlugin = plugins[field] || plugins[\"*\"];\n    if (fieldPlugin) {\n        return fieldPlugin;\n    }\n    throw new WebinyError(`Missing plugin for the field \"${field}\".`, \"PLUGIN_ERROR\", {\n        field\n    });\n};\n\nconst findOperatorPlugin = (\n    plugins: Record<string, ElasticsearchQueryBuilderOperatorPlugin>,\n    operator: string\n): ElasticsearchQueryBuilderOperatorPlugin => {\n    const fieldPlugin = plugins[operator];\n    if (fieldPlugin) {\n        return fieldPlugin;\n    }\n    throw new WebinyError(`Missing plugin for the operator \"${operator}\"`, \"PLUGIN_ERROR\", {\n        operator\n    });\n};\n\nconst createElasticsearchQuery = (\n    params: CreateElasticsearchBodyParams & { plugins: Record<string, ElasticsearchFieldPlugin> }\n) => {\n    const { context, where: initialWhere, plugins: fieldPlugins } = params;\n    const query: ElasticsearchBoolQueryConfig = {\n        must: [],\n        filter: [],\n        should: [],\n        must_not: []\n    };\n    /**\n     * Be aware that, if having more registered operator plugins of same type, the last one will be used.\n     */\n    const operatorPlugins: Record<string, ElasticsearchQueryBuilderOperatorPlugin> = context.plugins\n        .byType<ElasticsearchQueryBuilderOperatorPlugin>(\n            ElasticsearchQueryBuilderOperatorPlugin.type\n        )\n        .reduce((acc, plugin) => {\n            acc[plugin.getOperator()] = plugin;\n            return acc;\n        }, {});\n\n    const where = {\n        ...initialWhere\n    };\n    /**\n     * !!! IMPORTANT !!! There are few specific cases where we hardcode the query conditions.\n     *\n     * When ES index is shared between tenants, we need to filter records by tenant ID.\n     */\n    const sharedIndex = process.env.ELASTICSEARCH_SHARED_INDEXES === \"true\";\n    if (sharedIndex) {\n        const tenant = context.tenancy.getCurrentTenant();\n        query.must.push({ term: { \"tenant.keyword\": tenant.id } });\n        /**\n         * Remove so it is not applied again later.\n         * Possibly tenant is not defined, but just in case, remove it.\n         */\n        delete where.tenant;\n    }\n    /**\n     * If there is a search value passed in where, it is treated a bit differently.\n     * The search value is pushed to search in file name and file tags, where for tags.\n     * For tags, the search value is split by space.\n     * It produces something like \"AND (name contains search value OR tags contains 'search words')\"\n     */\n    if (where.search) {\n        const search = normalizeValue(where.search);\n        query.must.push({\n            bool: {\n                should: [\n                    {\n                        wildcard: {\n                            name: `*${search}*`\n                        }\n                    },\n                    {\n                        terms: {\n                            tags: search.toLowerCase().split(\" \")\n                        }\n                    }\n                ]\n            }\n        });\n        /**\n         * Remove because this field actually does not exist and Elasticsearch would throw an error.\n         */\n        delete where.search;\n    }\n    /**\n     * We apply other conditions as they are passed via the where value.\n     */\n    for (const key in where) {\n        if (where.hasOwnProperty(key) === false) {\n            continue;\n        }\n        const initialValue = where[key];\n        /**\n         * There is a possibility that undefined is sent as a value, so just skip it.\n         */\n        if (initialValue === undefined) {\n            continue;\n        }\n        const { field, op } = parseWhereKey(key);\n        const fieldPlugin = findFieldPlugin(fieldPlugins, field);\n        const operatorPlugin = findOperatorPlugin(operatorPlugins, op);\n\n        /**\n         * Get the path but in the case of * (all fields, replace * with the field.\n         * Custom path would return its own value anyways.\n         */\n        const path = fieldPlugin.getPath(field);\n        const basePath = fieldPlugin.getBasePath(field);\n        /**\n         * Transform the value for the search.\n         */\n        const value = fieldPlugin.toSearchValue({\n            context,\n            value: initialValue,\n            path,\n            basePath\n        });\n\n        operatorPlugin.apply(query, {\n            context,\n            value,\n            path,\n            basePath: basePath,\n            keyword: fieldPlugin.keyword\n        });\n    }\n\n    return query;\n};\n\nexport const createElasticsearchBody = (\n    params: CreateElasticsearchBodyParams\n): ElasticTsSearchBody => {\n    const { context, where, sort, limit: initialLimit, after } = params;\n\n    const fieldPlugins: Record<string, ElasticsearchFieldPlugin> = context.plugins\n        .byType<ElasticsearchFieldPlugin>(ElasticsearchFieldPlugin.type)\n        .filter(plugin => {\n            return plugin.entity === \"FilesElasticsearch\";\n        })\n        .reduce((acc, plugin) => {\n            acc[plugin.field] = plugin;\n            return acc;\n        }, {});\n\n    const limit = createLimit(initialLimit, 100);\n\n    const query = createElasticsearchQuery({\n        ...params,\n        plugins: fieldPlugins\n    });\n\n    const queryModifierPlugins = context.plugins.byType<ElasticsearchQueryModifierPlugin>(\n        ElasticsearchQueryModifierPlugin.type\n    );\n    for (const pl of queryModifierPlugins) {\n        pl.apply({\n            context,\n            query,\n            where,\n            sort,\n            limit,\n            after\n        });\n    }\n\n    const searchAfter = decodeCursor(after);\n    return {\n        query: {\n            constant_score: {\n                filter: {\n                    bool: {\n                        ...query\n                    }\n                }\n            }\n        },\n        size: limit + 1,\n        /**\n         * Casting as any is required due to search_after is accepting an array of values.\n         * Which is correct in some cases. In our case, it is not.\n         * https://www.elastic.co/guide/en/elasticsearch/reference/7.13/paginate-search-results.html\n         */\n        search_after: searchAfter as any,\n        sort: createSort({\n            context,\n            sort,\n            plugins: fieldPlugins\n        })\n    };\n};\n"],"file":"body.js"}