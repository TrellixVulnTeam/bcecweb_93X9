"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createElasticsearchBody = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _cursors = require("@webiny/api-elasticsearch/cursors");

var _ElasticsearchQueryModifierPlugin = require("@webiny/api-elasticsearch/plugins/definition/ElasticsearchQueryModifierPlugin");

var _ElasticsearchFieldPlugin = require("@webiny/api-elasticsearch/plugins/definition/ElasticsearchFieldPlugin");

var _ElasticsearchQueryBuilderOperatorPlugin = require("@webiny/api-elasticsearch/plugins/definition/ElasticsearchQueryBuilderOperatorPlugin");

var _limit = require("@webiny/api-elasticsearch/limit");

var _sort = require("@webiny/api-elasticsearch/sort");

var _normalize = require("@webiny/api-elasticsearch/normalize");

var _error = _interopRequireDefault(require("@webiny/error"));

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

const parseWhereKeyRegExp = new RegExp(/^([a-zA-Z0-9]+)(_[a-zA-Z0-9_]+)?$/);

const parseWhereKey = key => {
  const match = key.match(parseWhereKeyRegExp);

  if (!match) {
    throw new Error(`It is not possible to search by key "${key}"`);
  }

  const [, field, operation = "eq"] = match;
  const op = operation.match(/^_/) ? operation.substr(1) : operation;

  if (!field.match(/^([a-zA-Z]+)$/)) {
    throw new Error(`Cannot search by "${field}".`);
  }

  return {
    field,
    op
  };
};

const findFieldPlugin = (plugins, field) => {
  const fieldPlugin = plugins[field] || plugins["*"];

  if (fieldPlugin) {
    return fieldPlugin;
  }

  throw new _error.default(`Missing plugin for the field "${field}".`, "PLUGIN_ERROR", {
    field
  });
};

const findOperatorPlugin = (plugins, operator) => {
  const fieldPlugin = plugins[operator];

  if (fieldPlugin) {
    return fieldPlugin;
  }

  throw new _error.default(`Missing plugin for the operator "${operator}"`, "PLUGIN_ERROR", {
    operator
  });
};

const createElasticsearchQuery = params => {
  const {
    context,
    where: initialWhere,
    plugins: fieldPlugins
  } = params;
  const query = {
    must: [],
    filter: [],
    should: [],
    must_not: []
  };
  /**
   * Be aware that, if having more registered operator plugins of same type, the last one will be used.
   */

  const operatorPlugins = context.plugins.byType(_ElasticsearchQueryBuilderOperatorPlugin.ElasticsearchQueryBuilderOperatorPlugin.type).reduce((acc, plugin) => {
    acc[plugin.getOperator()] = plugin;
    return acc;
  }, {});

  const where = _objectSpread({}, initialWhere);
  /**
   * !!! IMPORTANT !!! There are few specific cases where we hardcode the query conditions.
   *
   * When ES index is shared between tenants, we need to filter records by tenant ID.
   */


  const sharedIndex = process.env.ELASTICSEARCH_SHARED_INDEXES === "true";

  if (sharedIndex) {
    const tenant = context.tenancy.getCurrentTenant();
    query.must.push({
      term: {
        "tenant.keyword": tenant.id
      }
    });
    /**
     * Remove so it is not applied again later.
     * Possibly tenant is not defined, but just in case, remove it.
     */

    delete where.tenant;
  }
  /**
   * If there is a search value passed in where, it is treated a bit differently.
   * The search value is pushed to search in file name and file tags, where for tags.
   * For tags, the search value is split by space.
   * It produces something like "AND (name contains search value OR tags contains 'search words')"
   */


  if (where.search) {
    const search = (0, _normalize.normalizeValue)(where.search);
    query.must.push({
      bool: {
        should: [{
          wildcard: {
            name: `*${search}*`
          }
        }, {
          terms: {
            tags: search.toLowerCase().split(" ")
          }
        }]
      }
    });
    /**
     * Remove because this field actually does not exist and Elasticsearch would throw an error.
     */

    delete where.search;
  }
  /**
   * We apply other conditions as they are passed via the where value.
   */


  for (const key in where) {
    if (where.hasOwnProperty(key) === false) {
      continue;
    }

    const initialValue = where[key];
    /**
     * There is a possibility that undefined is sent as a value, so just skip it.
     */

    if (initialValue === undefined) {
      continue;
    }

    const {
      field,
      op
    } = parseWhereKey(key);
    const fieldPlugin = findFieldPlugin(fieldPlugins, field);
    const operatorPlugin = findOperatorPlugin(operatorPlugins, op);
    /**
     * Get the path but in the case of * (all fields, replace * with the field.
     * Custom path would return its own value anyways.
     */

    const path = fieldPlugin.getPath(field);
    const basePath = fieldPlugin.getBasePath(field);
    /**
     * Transform the value for the search.
     */

    const value = fieldPlugin.toSearchValue({
      context,
      value: initialValue,
      path,
      basePath
    });
    operatorPlugin.apply(query, {
      context,
      value,
      path,
      basePath: basePath,
      keyword: fieldPlugin.keyword
    });
  }

  return query;
};

const createElasticsearchBody = params => {
  const {
    context,
    where,
    sort,
    limit: initialLimit,
    after
  } = params;
  const fieldPlugins = context.plugins.byType(_ElasticsearchFieldPlugin.ElasticsearchFieldPlugin.type).filter(plugin => {
    return plugin.entity === "FilesElasticsearch";
  }).reduce((acc, plugin) => {
    acc[plugin.field] = plugin;
    return acc;
  }, {});
  const limit = (0, _limit.createLimit)(initialLimit, 100);
  const query = createElasticsearchQuery(_objectSpread(_objectSpread({}, params), {}, {
    plugins: fieldPlugins
  }));
  const queryModifierPlugins = context.plugins.byType(_ElasticsearchQueryModifierPlugin.ElasticsearchQueryModifierPlugin.type);

  for (const pl of queryModifierPlugins) {
    pl.apply({
      context,
      query,
      where,
      sort,
      limit,
      after
    });
  }

  const searchAfter = (0, _cursors.decodeCursor)(after);
  return {
    query: {
      constant_score: {
        filter: {
          bool: _objectSpread({}, query)
        }
      }
    },
    size: limit + 1,

    /**
     * Casting as any is required due to search_after is accepting an array of values.
     * Which is correct in some cases. In our case, it is not.
     * https://www.elastic.co/guide/en/elasticsearch/reference/7.13/paginate-search-results.html
     */
    search_after: searchAfter,
    sort: (0, _sort.createSort)({
      context,
      sort,
      plugins: fieldPlugins
    })
  };
};

exports.createElasticsearchBody = createElasticsearchBody;
//# sourceMappingURL=body.js.map