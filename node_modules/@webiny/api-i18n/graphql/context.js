"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _acceptLanguageParser = _interopRequireDefault(require("accept-language-parser"));

var _locales = _interopRequireDefault(require("./crud/locales.crud"));

var _system = _interopRequireDefault(require("./crud/system.crud"));

var _ContextPlugin = require("@webiny/handler/plugins/ContextPlugin");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

/**
 * Parses "x-i18n-locale" header value (e.g. "default:en-US;content:hr-HR;").
 */
const parseXI18NLocaleHeader = value => {
  if (parseXI18NLocaleHeader.cache[value]) {
    return parseXI18NLocaleHeader.cache[value];
  }
  /**
   * Parsing x-i18n-locale value (e.g. "default:en-US;content:hr-HR;").
   */


  parseXI18NLocaleHeader.cache[value] = value.split(";").filter(Boolean).map(item => item.split(":")).reduce((current, [context, locale]) => {
    current[context] = locale;
    return current;
  }, {});
  return parseXI18NLocaleHeader.cache[value];
};

parseXI18NLocaleHeader.cache = {};

const getLocaleFromHeaders = (http, localeContext = "default") => {
  if (!http) {
    return null;
  }

  const {
    headers = {}
  } = http.request;
  let acceptLanguageHeader, contextLocaleHeader;

  for (const key in headers) {
    if (headers.hasOwnProperty(key) === false) {
      continue;
    }

    const lcKey = key.toLowerCase();

    if (lcKey === "accept-language") {
      acceptLanguageHeader = headers[key];
    } else if (lcKey === "x-i18n-locale") {
      const parsed = parseXI18NLocaleHeader(headers[key]);
      contextLocaleHeader = parsed[localeContext];
    }

    if (acceptLanguageHeader && contextLocaleHeader) {
      break;
    }
  }

  return {
    acceptLanguageHeader,
    contextLocaleHeader
  };
};

const context = new _ContextPlugin.ContextPlugin(async context => {
  let locales = [];

  if (context.tenancy.getCurrentTenant()) {
    const plugin = context.plugins.byName("context-i18n-get-locales");

    if (!plugin) {
      throw new Error('Cannot load locales - missing "context-i18n-get-locales" plugin.');
    }

    locales = await plugin.resolve({
      context
    });
  }

  const {
    http,
    plugins
  } = context;
  const __i18n = {
    acceptLanguage: null,
    defaultLocale: null,
    locale: {},
    // Contains one or more locales - for multiple locale contexts.
    locales
  };

  const getDefaultLocale = () => {
    const allLocales = getLocales();
    return allLocales.find(item => item.default === true);
  };

  const getCurrentLocales = () => {
    const localeContexts = plugins.byType("i18n-locale-context");
    return localeContexts.map(plugin => {
      var _getCurrentLocale;

      return {
        context: plugin.context.name,
        locale: (_getCurrentLocale = getCurrentLocale(plugin.context.name)) === null || _getCurrentLocale === void 0 ? void 0 : _getCurrentLocale.code
      };
    });
  };

  const getCurrentLocale = (localeContext = "default") => {
    if (__i18n.locale[localeContext]) {
      return __i18n.locale[localeContext];
    }

    const allLocales = getLocales();
    let currentLocale;
    const {
      acceptLanguageHeader,
      contextLocaleHeader
    } = getLocaleFromHeaders(http, localeContext); // Try to select from received context locale.

    let localeFromHeaders = contextLocaleHeader;

    if (!localeFromHeaders && acceptLanguageHeader) {
      localeFromHeaders = _acceptLanguageParser.default.pick(allLocales.map(item => item.code), acceptLanguageHeader);
    }

    if (localeFromHeaders) {
      currentLocale = allLocales.find(item => item.code === localeFromHeaders);
    }

    if (!currentLocale) {
      currentLocale = getDefaultLocale();
    }

    __i18n.locale[localeContext] = currentLocale;
    return __i18n.locale[localeContext];
  };

  const getLocales = () => {
    return __i18n.locales;
  };

  const getLocale = code => {
    const item = __i18n.locales.find(locale => locale.code.toLowerCase() === code.toLowerCase());

    if (!item) {
      return null;
    }

    return item;
  };

  context.i18n = _objectSpread(_objectSpread({}, context.i18n), {}, {
    __i18n,
    getDefaultLocale,
    getCurrentLocales,
    getCurrentLocale,
    getLocales,
    getLocale
  });
});

var _default = () => [_locales.default, _system.default, context];

exports.default = _default;
//# sourceMappingURL=context.js.map