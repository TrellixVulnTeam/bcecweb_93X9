"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ElasticsearchFieldPlugin = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _plugins = require("@webiny/plugins");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

class ElasticsearchFieldPlugin extends _plugins.Plugin {
  get entity() {
    return this._entity;
  }

  get field() {
    return this._field;
  }

  get path() {
    return this._path;
  }

  get keyword() {
    return this._keyword;
  }

  get unmappedType() {
    return this._unmappedType;
  }

  get sortable() {
    return this._sortable;
  }

  get searchable() {
    return this._searchable;
  }

  constructor(params) {
    super();
    (0, _defineProperty2.default)(this, "_entity", void 0);
    (0, _defineProperty2.default)(this, "_field", void 0);
    (0, _defineProperty2.default)(this, "_path", void 0);
    (0, _defineProperty2.default)(this, "_keyword", void 0);
    (0, _defineProperty2.default)(this, "_unmappedType", void 0);
    (0, _defineProperty2.default)(this, "_sortable", void 0);
    (0, _defineProperty2.default)(this, "_searchable", void 0);
    this._entity = params.entity;
    this._field = params.field;
    this._path = params.path || params.field;
    this._keyword = params.keyword === undefined ? true : params.keyword;
    this._unmappedType = params.unmappedType;
    this._sortable = params.sortable === undefined ? true : params.sortable;
    this._searchable = params.searchable === undefined ? true : params.searchable;
  }
  /**
   * The default sort options. Extend in your own plugin if you want to add more options.
   */


  getSortOptions(order) {
    const options = {
      order
    };

    if (!this._unmappedType) {
      return options;
    }

    return _objectSpread(_objectSpread({}, options), {}, {
      unmapped_type: this._unmappedType
    });
  }
  /**
   * The default path generator. Extend in your own plugin if you want to add more options.
   * Field parameter is here because there is a possibility that this is the ALL field plugin, so we need to know which field are we working on.
   */


  getPath(field) {
    return `${this.getBasePath(field)}${this._keyword ? ".keyword" : ""}`;
  }
  /**
   * @see getPath
   *
   * This is the default base path generator. Basically it replaces ALL with given field name.
   */


  getBasePath(field) {
    if (this._path === this.constructor.ALL) {
      return field;
    }

    return this._path;
  }
  /**
   * The default transformer. Just returns the value by default.
   * Override to implement what ever is required.
   */


  toSearchValue(params) {
    return params.value;
  }

}

exports.ElasticsearchFieldPlugin = ElasticsearchFieldPlugin;
(0, _defineProperty2.default)(ElasticsearchFieldPlugin, "type", "elasticsearch.fieldDefinition");
(0, _defineProperty2.default)(ElasticsearchFieldPlugin, "ALL", "*");
//# sourceMappingURL=ElasticsearchFieldPlugin.js.map