{"version":3,"sources":["../../src/plugins/GzipCompression.ts"],"names":["gzip","input","options","Promise","resolve","reject","zlib","error","result","ungzip","gunzip","GZIP","TO_STORAGE_ENCODING","FROM_STORAGE_ENCODING","convertToBuffer","value","Buffer","from","GzipCompression","CompressionPlugin","canCompress","data","compression","console","log","compress","JSON","stringify","toString","canDecompress","decompress","buf","parse","ex"],"mappings":"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","sourcesContent":["import { CompressionPlugin } from \"~/plugins/definition/CompressionPlugin\";\nimport zlib from \"zlib\";\n\nexport const gzip = (input: zlib.InputType, options?: zlib.ZlibOptions): Promise<Buffer> => {\n    return new Promise(function (resolve, reject) {\n        zlib.gzip(input, options, function (error, result) {\n            if (!error) {\n                resolve(result);\n            } else {\n                reject(error);\n            }\n        });\n    });\n};\nexport const ungzip = (input: zlib.InputType, options?: zlib.ZlibOptions): Promise<Buffer> => {\n    return new Promise(function (resolve, reject) {\n        zlib.gunzip(input, options, function (error, result) {\n            if (!error) {\n                resolve(result);\n            } else {\n                reject(error);\n            }\n        });\n    });\n};\n\nconst GZIP = \"gzip\";\nconst TO_STORAGE_ENCODING = \"base64\";\nconst FROM_STORAGE_ENCODING = \"utf8\";\n\nconst convertToBuffer = value => {\n    if (typeof value === \"string\") {\n        return Buffer.from(value, TO_STORAGE_ENCODING);\n    }\n    return value;\n};\n\nexport interface CompressedData {\n    compression: string;\n    value: string;\n}\n\ninterface OriginalData {\n    [key: string]: any;\n}\n\nclass GzipCompression extends CompressionPlugin {\n    public canCompress(data: any): boolean {\n        /**\n         * If already compressed, skip this.\n         */\n        if (data.compression) {\n            if (data.compression !== \"GZIP\") {\n                console.log(`Data is already compressed with \"${data.compression}\".`);\n            }\n            return false;\n        }\n        return true;\n    }\n    public async compress(data) {\n        const value = await gzip(JSON.stringify(data));\n\n        return {\n            compression: GZIP,\n            value: value.toString(TO_STORAGE_ENCODING)\n        };\n    }\n\n    public canDecompress(data: CompressedData | Record<string, any>): boolean {\n        if (!data || !data.compression) {\n            return false;\n        } else if (data.compression !== GZIP) {\n            console.log(\n                `Could not decompress given data since its compression is not \"${GZIP}\". It is \"${data.compression}\".`\n            );\n            return false;\n        }\n        return true;\n    }\n\n    public async decompress(data: CompressedData): Promise<OriginalData | null> {\n        try {\n            const buf = await ungzip(convertToBuffer(data.value));\n            const value = buf.toString(FROM_STORAGE_ENCODING);\n            return JSON.parse(value);\n        } catch (ex) {\n            return null;\n        }\n    }\n}\n\nexport default () => {\n    return new GzipCompression();\n};\n"],"file":"GzipCompression.js"}