{"version":3,"sources":["../src/compression.ts"],"names":["getCompressionPlugins","context","plugins","byType","CompressionPlugin","type","reverse","compress","data","length","plugin","canCompress","decompress","canDecompress"],"mappings":";;;;;;;AACA;;AAEA;AACA;AACA;AACA,MAAMA,qBAAqB,GAAIC,OAAD,IAAoD;AAC9E,SAAOA,OAAO,CAACC,OAAR,CAAgBC,MAAhB,CAA0CC,qCAAkBC,IAA5D,EAAkEC,OAAlE,EAAP;AACH,CAFD;AAGA;AACA;AACA;;;AACO,MAAMC,QAAQ,GAAG,OACpBN,OADoB,EAEpBO,IAFoB,KAGW;AAC/B,QAAMN,OAAO,GAAGF,qBAAqB,CAACC,OAAD,CAArC;;AACA,MAAIC,OAAO,CAACO,MAAR,KAAmB,CAAvB,EAA0B;AACtB,WAAOD,IAAP;AACH;;AACD,OAAK,MAAME,MAAX,IAAqBR,OAArB,EAA8B;AAC1B,QAAIQ,MAAM,CAACC,WAAP,CAAmBH,IAAnB,MAA6B,KAAjC,EAAwC;AACpC;AACH;;AACD,WAAO,MAAME,MAAM,CAACH,QAAP,CAAgBC,IAAhB,CAAb;AACH;AACD;AACJ;AACA;;;AACI,SAAOA,IAAP;AACH,CAlBM;;;;AAoBA,MAAMI,UAAU,GAAG,OACtBX,OADsB,EAEtBO,IAFsB,KAGS;AAC/B,QAAMN,OAAO,GAAGF,qBAAqB,CAACC,OAAD,CAArC;;AACA,MAAIC,OAAO,CAACO,MAAR,KAAmB,CAAvB,EAA0B;AACtB,WAAOD,IAAP;AACH;;AACD,OAAK,MAAME,MAAX,IAAqBR,OAArB,EAA8B;AAC1B,QAAIQ,MAAM,CAACG,aAAP,CAAqBL,IAArB,MAA+B,KAAnC,EAA0C;AACtC;AACH;;AACD,WAAO,MAAME,MAAM,CAACE,UAAP,CAAkBJ,IAAlB,CAAb;AACH;AACD;AACJ;AACA;;;AACI,SAAOA,IAAP;AACH,CAlBM","sourcesContent":["import { ContextInterface } from \"@webiny/handler/types\";\nimport { CompressionPlugin } from \"~/plugins/definition/CompressionPlugin\";\n\n/**\n * Get the compression plugins, in reverse order, because we want to use the last one added - first.\n */\nconst getCompressionPlugins = (context: ContextInterface): CompressionPlugin[] => {\n    return context.plugins.byType<CompressionPlugin>(CompressionPlugin.type).reverse();\n};\n/**\n * Method to compress the elasticsearch data that is going to be stored into the DynamoDB table that is meant for elasticsearch.\n */\nexport const compress = async (\n    context: ContextInterface,\n    data: Record<string, any>\n): Promise<Record<string, any>> => {\n    const plugins = getCompressionPlugins(context);\n    if (plugins.length === 0) {\n        return data;\n    }\n    for (const plugin of plugins) {\n        if (plugin.canCompress(data) === false) {\n            continue;\n        }\n        return await plugin.compress(data);\n    }\n    /**\n     * Possibly no plugins that can compress, just return the data.\n     */\n    return data;\n};\n\nexport const decompress = async (\n    context: ContextInterface,\n    data: Record<string, any>\n): Promise<Record<string, any>> => {\n    const plugins = getCompressionPlugins(context);\n    if (plugins.length === 0) {\n        return data;\n    }\n    for (const plugin of plugins) {\n        if (plugin.canDecompress(data) === false) {\n            continue;\n        }\n        return await plugin.decompress(data);\n    }\n    /**\n     * Possibly no plugins that can decompress, just return the data.\n     */\n    return data;\n};\n"],"file":"compression.js"}