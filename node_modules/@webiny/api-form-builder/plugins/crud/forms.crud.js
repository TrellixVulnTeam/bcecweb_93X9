"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _mdbid = _interopRequireDefault(require("mdbid"));

var _slugify = _interopRequireDefault(require("slugify"));

var _pick = _interopRequireDefault(require("lodash/pick"));

var _nodeFetch = _interopRequireDefault(require("node-fetch"));

var _handlerGraphql = require("@webiny/handler-graphql");

var _apiSecurity = require("@webiny/api-security");

var utils = _interopRequireWildcard(require("./utils"));

var _defaults = _interopRequireDefault(require("./defaults"));

var models = _interopRequireWildcard(require("./forms.models"));

var _error = _interopRequireDefault(require("@webiny/error"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

const TYPE_FORM = "fb.form";
const TYPE_FORM_LATEST = "fb.form.latest";
const TYPE_FORM_LATEST_PUBLISHED = "fb.form.latestPublished";
const TYPE_FORM_SUBMISSION = "fb.formSubmission";

const getESDataForLatestRevision = (form, context) => ({
  __type: "fb.form",
  tenant: context.tenancy.getCurrentTenant().id,
  webinyVersion: context.WEBINY_VERSION,
  id: form.id,
  createdOn: form.createdOn,
  savedOn: form.savedOn,
  name: form.name,
  slug: form.slug,
  published: form.published,
  publishedOn: form.publishedOn,
  version: form.version,
  locked: form.locked,
  status: form.status,
  createdBy: form.createdBy,
  ownedBy: form.ownedBy,
  locale: context.i18nContent.locale.code
});

const zeroPad = version => `${version}`.padStart(4, "0");

var _default = {
  type: "context",

  apply(context) {
    const {
      db,
      i18nContent,
      elasticsearch,
      tenancy
    } = context;

    const PK_FORM = formId => `${utils.getPKPrefix(context)}F#${formId}`;

    const SK_FORM_REVISION = version => {
      return typeof version === "string" ? `REV#${version}` : `REV#${zeroPad(version)}`;
    };

    const SK_FORM_LATEST = () => "L";

    const SK_FORM_LATEST_PUBLISHED = () => "LP";

    const SK_SUBMISSION = submissionId => `FS#${submissionId}`;

    context.formBuilder = _objectSpread(_objectSpread({}, context.formBuilder), {}, {
      forms: {
        async getForm(id) {
          const permission = await utils.checkBaseFormPermissions(context, {
            rwd: "r"
          });
          const [uniqueId, version] = id.split("#");
          const [[form]] = await db.read(_objectSpread(_objectSpread({}, _defaults.default.db), {}, {
            query: {
              PK: PK_FORM(uniqueId),
              SK: SK_FORM_REVISION(version)
            }
          }));
          utils.checkOwnership(form, permission, context);
          return form;
        },

        async getFormStats(id) {
          // We don't need to check permissions here, as this method is only called
          // as a resolver to an `FbForm` GraphQL type, and we already check permissions
          // and ownership when resolving the form in `getForm`.
          const allRevisions = await this.getFormRevisions(id); // Then calculate the stats

          const stats = {
            submissions: 0,
            views: 0,
            conversionRate: 0
          };

          for (let i = 0; i < allRevisions.length; i++) {
            const revision = allRevisions[i];
            stats.views += revision.stats.views;
            stats.submissions += revision.stats.submissions;
          }

          let conversionRate = 0;

          if (stats.views > 0) {
            conversionRate = parseFloat((stats.submissions / stats.views * 100).toFixed(2));
          }

          return _objectSpread(_objectSpread({}, stats), {}, {
            conversionRate
          });
        },

        async listForms() {
          const permission = await utils.checkBaseFormPermissions(context, {
            rwd: "r"
          });
          const must = [{
            term: {
              "__type.keyword": "fb.form"
            }
          }, {
            term: {
              "locale.keyword": i18nContent.locale.code
            }
          }]; // Only get records which are owned by current user.

          if (permission.own === true) {
            const identity = context.security.getIdentity();
            must.push({
              term: {
                "ownedBy.id.keyword": identity.id
              }
            });
          } // When ES index is shared between tenants, we need to filter records by tenant ID


          const sharedIndex = process.env.ELASTICSEARCH_SHARED_INDEXES === "true";

          if (sharedIndex) {
            const tenant = tenancy.getCurrentTenant();
            must.push({
              term: {
                "tenant.keyword": tenant.id
              }
            });
          }

          const body = {
            query: {
              bool: {
                must
              }
            },
            sort: [{
              savedOn: {
                order: "desc",
                unmapped_type: "date"
              }
            }],
            size: 1000
          }; // Get "latest" form revisions from Elasticsearch.

          try {
            const response = await elasticsearch.search(_objectSpread(_objectSpread({}, _defaults.default.es(context)), {}, {
              body
            }));
            return response.body.hits.hits.map(item => item._source);
          } catch (ex) {
            throw new _error.default(ex.message || "Could not perform search.", ex.code || "ELASTICSEARCH_ERROR", {
              body
            });
          }
        },

        async getFormRevisions(id) {
          const permission = await utils.checkBaseFormPermissions(context, {
            rwd: "r"
          });
          const [uniqueId] = id.split("#");
          const [forms] = await db.read(_objectSpread(_objectSpread({}, _defaults.default.db), {}, {
            query: {
              PK: PK_FORM(uniqueId),
              SK: {
                $beginsWith: "REV#"
              },
              sort: {
                SK: -1
              }
            }
          }));
          utils.checkOwnership(forms[0], permission, context);
          return forms.sort((a, b) => b.version - a.version);
        },

        async getPublishedFormRevisionById(revisionId) {
          const [uniqueId, version] = revisionId.split("#");
          const [[form]] = await db.read(_objectSpread(_objectSpread({}, _defaults.default.db), {}, {
            query: {
              PK: PK_FORM(uniqueId),
              SK: SK_FORM_REVISION(version)
            }
          }));

          if (!form || !form.published) {
            throw new _handlerGraphql.NotFoundError(`Form "${revisionId}" was not found!`);
          }

          return form;
        },

        async getLatestPublishedFormRevision(formId) {
          // Make sure we have a unique form ID, and not a revision ID
          const [uniqueId] = formId.split("#");
          const [[latestPublishedItem]] = await db.read(_objectSpread(_objectSpread({}, _defaults.default.db), {}, {
            query: {
              PK: PK_FORM(uniqueId),
              SK: SK_FORM_LATEST_PUBLISHED()
            }
          }));

          if (!latestPublishedItem) {
            throw new _handlerGraphql.NotFoundError(`Form "${formId}" was not found!`);
          }

          const [[form]] = await db.read(_objectSpread(_objectSpread({}, _defaults.default.db), {}, {
            query: {
              PK: PK_FORM(uniqueId),
              SK: SK_FORM_REVISION(latestPublishedItem.version)
            }
          }));
          return form;
        },

        async createForm(data) {
          await utils.checkBaseFormPermissions(context, {
            rwd: "w"
          });
          const identity = context.security.getIdentity();
          await new models.FormCreateDataModel().populate(data).validate(); // Forms are identified by a common parent ID + Revision number

          const [uniqueId, version] = [(0, _mdbid.default)(), 1];
          const id = `${uniqueId}#${zeroPad(version)}`;
          const form = {
            id,
            locale: i18nContent.locale.code,
            tenant: tenancy.getCurrentTenant().id,
            savedOn: new Date().toISOString(),
            createdOn: new Date().toISOString(),
            createdBy: {
              id: identity.id,
              displayName: identity.displayName,
              type: identity.type
            },
            ownedBy: {
              id: identity.id,
              displayName: identity.displayName,
              type: identity.type
            },
            name: data.name,
            slug: [(0, _slugify.default)(data.name), uniqueId].join("-").toLowerCase(),
            version,
            locked: false,
            published: false,
            publishedOn: null,
            status: utils.getStatus({
              published: false,
              locked: false
            }),
            stats: {
              views: 0,
              submissions: 0
            },
            // Will be added via a "update"
            fields: [],
            layout: [],
            settings: await new models.FormSettingsModel().toJSON(),
            triggers: null
          };
          const FORM_PK = PK_FORM(uniqueId);
          await db.batch().create(_objectSpread(_objectSpread({}, _defaults.default.db), {}, {
            data: _objectSpread({
              PK: FORM_PK,
              SK: SK_FORM_REVISION(version),
              TYPE: TYPE_FORM
            }, form)
          })).create(_objectSpread(_objectSpread({}, _defaults.default.db), {}, {
            data: {
              PK: FORM_PK,
              SK: SK_FORM_LATEST(),
              TYPE: TYPE_FORM_LATEST,
              id,
              version
            }
          })).create(_objectSpread(_objectSpread({}, _defaults.default.esDb), {}, {
            data: {
              PK: FORM_PK,
              SK: SK_FORM_LATEST(),
              index: _defaults.default.es(context).index,
              data: getESDataForLatestRevision(form, context)
            }
          })).execute();
          return form;
        },

        async updateForm(id, data) {
          const permission = await utils.checkBaseFormPermissions(context, {
            rwd: "w"
          });
          const updateData = new models.FormUpdateDataModel().populate(data);
          await updateData.validate();
          const [uniqueId, version] = id.split("#");
          const FORM_PK = PK_FORM(uniqueId);
          const [[[form]], [[latestForm]]] = await db.batch().read(_objectSpread(_objectSpread({}, _defaults.default.db), {}, {
            query: {
              PK: FORM_PK,
              SK: SK_FORM_REVISION(version)
            }
          })).read(_objectSpread(_objectSpread({}, _defaults.default.db), {}, {
            query: {
              PK: FORM_PK,
              SK: SK_FORM_LATEST()
            }
          })).execute();

          if (!form) {
            throw new _handlerGraphql.NotFoundError(`Form "${id}" was not found!`);
          }

          (0, utils.checkOwnership)(form, permission, context);
          const newData = Object.assign(await updateData.toJSON({
            onlyDirty: true
          }), {
            savedOn: new Date().toISOString()
          });
          Object.assign(form, newData); // Finally save it to DB

          const batch = db.batch().update(_objectSpread(_objectSpread({}, _defaults.default.db), {}, {
            query: {
              PK: FORM_PK,
              SK: SK_FORM_REVISION(version)
            },
            data: form
          })); // Update form in "Elastic Search"

          if (latestForm.id === id) {
            batch.update(_objectSpread(_objectSpread({}, _defaults.default.esDb), {}, {
              query: {
                PK: FORM_PK,
                SK: SK_FORM_LATEST()
              },
              data: {
                PK: FORM_PK,
                SK: SK_FORM_LATEST(),
                index: _defaults.default.es(context).index,
                data: getESDataForLatestRevision(form, context)
              }
            }));
          }

          await batch.execute();
          return form;
        },

        async deleteForm(id) {
          const permission = await utils.checkBaseFormPermissions(context, {
            rwd: "d"
          });
          const [uniqueId] = id.split("#");
          const [items] = await db.read(_objectSpread(_objectSpread({}, _defaults.default.db), {}, {
            query: {
              PK: PK_FORM(uniqueId),
              SK: {
                $gt: " "
              }
            }
          }));

          if (!items.length) {
            throw new _handlerGraphql.NotFoundError(`Form ${id} was not found!`);
          }

          const form = items.find(item => item.TYPE === TYPE_FORM);
          (0, utils.checkOwnership)(form, permission, context); // Delete all items in batches of 25

          await utils.paginateBatch(items, 25, async items => {
            await db.batch().delete(...items.map(item => _objectSpread(_objectSpread({}, _defaults.default.db), {}, {
              query: {
                PK: item.PK,
                SK: item.SK
              }
            }))).execute();
          }); // Delete items from "Elastic Search"

          await db.delete(_objectSpread(_objectSpread({}, _defaults.default.esDb), {}, {
            query: {
              PK: PK_FORM(uniqueId),
              SK: SK_FORM_LATEST()
            }
          }));
          return true;
        },

        async deleteRevision(id) {
          const permission = await utils.checkBaseFormPermissions(context, {
            rwd: "d"
          });
          const [uniqueId, version] = id.split("#");
          const FORM_PK = PK_FORM(uniqueId); // Load form, latest form and latest published form records

          const [[[form]], [[lForm]], [[lpForm]]] = await db.batch().read(_objectSpread(_objectSpread({}, _defaults.default.db), {}, {
            query: {
              PK: FORM_PK,
              SK: SK_FORM_REVISION(version)
            }
          })).read(_objectSpread(_objectSpread({}, _defaults.default.db), {}, {
            query: {
              PK: FORM_PK,
              SK: SK_FORM_LATEST()
            }
          })).read(_objectSpread(_objectSpread({}, _defaults.default.db), {}, {
            query: {
              PK: FORM_PK,
              SK: SK_FORM_LATEST_PUBLISHED()
            }
          })).execute();

          if (!form) {
            throw new _handlerGraphql.NotFoundError(`Form "${id}" was not found!`);
          }

          (0, utils.checkOwnership)(form, permission, context);
          const batch = db.batch().delete(_objectSpread(_objectSpread({}, _defaults.default.db), {}, {
            query: {
              PK: FORM_PK,
              SK: SK_FORM_REVISION(version)
            }
          }));

          if (lForm.id === id || lpForm && lpForm.id === id) {
            // Get all form revisions
            const [revisions] = await db.read(_objectSpread(_objectSpread({}, _defaults.default.db), {}, {
              query: {
                PK: FORM_PK,
                SK: {
                  $beginsWith: "REV#"
                }
              },
              sort: {
                SK: -1
              }
            })); // Update or delete the "latest published" record

            if (lpForm && lpForm.id === id) {
              const publishedRevision = revisions.filter(rev => rev.id !== id && rev.publishedOn !== null).sort((a, b) => new Date(b.publishedOn).getTime() - new Date(a.publishedOn).getTime()).shift();

              if (publishedRevision) {
                batch.update(_objectSpread(_objectSpread({}, _defaults.default.db), {}, {
                  query: {
                    PK: FORM_PK,
                    SK: SK_FORM_LATEST_PUBLISHED()
                  },
                  data: {
                    PK: FORM_PK,
                    SK: SK_FORM_LATEST_PUBLISHED(),
                    TYPE: TYPE_FORM_LATEST_PUBLISHED,
                    id: publishedRevision.id,
                    version: publishedRevision.version
                  }
                }));
              } else {
                batch.delete(_objectSpread(_objectSpread({}, _defaults.default.db), {}, {
                  query: {
                    PK: FORM_PK,
                    SK: SK_FORM_LATEST_PUBLISHED()
                  }
                }));
              }
            }

            if (lForm.id === id) {
              // Find revision right before the one being deleted
              const prevRevision = revisions.filter(rev => rev.version < form.version).sort((a, b) => b.version - a.version).shift();

              if (!prevRevision && revisions.length === 1) {
                // Means we're deleting the last revision, so we need to delete the whole form.
                return this.deleteForm(uniqueId);
              }

              batch.update(_objectSpread(_objectSpread({}, _defaults.default.db), {}, {
                query: {
                  PK: FORM_PK,
                  SK: SK_FORM_LATEST()
                },
                data: {
                  PK: FORM_PK,
                  SK: SK_FORM_LATEST(),
                  TYPE: TYPE_FORM_LATEST,
                  id: prevRevision.id,
                  version: prevRevision.version
                }
              })).update(_objectSpread(_objectSpread({}, _defaults.default.esDb), {}, {
                query: {
                  PK: FORM_PK,
                  SK: SK_FORM_LATEST()
                },
                data: {
                  PK: FORM_PK,
                  SK: SK_FORM_LATEST(),
                  index: _defaults.default.es(context).index,
                  data: getESDataForLatestRevision(prevRevision, context)
                }
              }));
            }
          }

          await batch.execute();
          return true;
        },

        async publishForm(id) {
          const permission = await utils.checkBaseFormPermissions(context, {
            rwd: "r",
            pw: "p"
          });
          const [uniqueId, version] = id.split("#");
          const [[[form]], [[latestForm]]] = await db.batch().read(_objectSpread(_objectSpread({}, _defaults.default.db), {}, {
            query: {
              PK: PK_FORM(uniqueId),
              SK: SK_FORM_REVISION(version)
            }
          })).read(_objectSpread(_objectSpread({}, _defaults.default.db), {}, {
            query: {
              PK: PK_FORM(uniqueId),
              SK: SK_FORM_LATEST()
            }
          })).execute();

          if (!form) {
            throw new _handlerGraphql.NotFoundError(`Form "${id}" was not found!`);
          }

          (0, utils.checkOwnership)(form, permission, context);
          const savedOn = new Date().toISOString();
          const status = utils.getStatus({
            published: true,
            locked: true
          });
          Object.assign(form, {
            published: true,
            publishedOn: savedOn,
            locked: true,
            savedOn,
            status
          }); // Finally save it to DB

          const batch = db.batch().update(_objectSpread(_objectSpread({}, _defaults.default.db), {}, {
            query: {
              PK: PK_FORM(uniqueId),
              SK: SK_FORM_REVISION(version)
            },
            data: form
          })).update(_objectSpread(_objectSpread({}, _defaults.default.db), {}, {
            query: {
              PK: PK_FORM(uniqueId),
              SK: SK_FORM_LATEST_PUBLISHED()
            },
            data: {
              PK: PK_FORM(uniqueId),
              SK: SK_FORM_LATEST_PUBLISHED(),
              TYPE: TYPE_FORM_LATEST_PUBLISHED,
              id,
              version: form.version
            }
          })); // Update form in "Elastic Search"

          if (latestForm.id === id) {
            batch.update(_objectSpread(_objectSpread({}, _defaults.default.esDb), {}, {
              query: {
                PK: PK_FORM(uniqueId),
                SK: SK_FORM_LATEST()
              },
              data: {
                PK: PK_FORM(uniqueId),
                SK: SK_FORM_LATEST(),
                index: _defaults.default.es(context).index,
                data: getESDataForLatestRevision(form, context)
              }
            }));
          }

          await batch.execute();
          return form;
        },

        async unpublishForm(id) {
          const permission = await utils.checkBaseFormPermissions(context, {
            rwd: "r",
            pw: "u"
          });
          const [uniqueId, version] = id.split("#");
          const FORM_PK = PK_FORM(uniqueId);
          const [[[form]], [[latestForm]], [[latestPublishedForm]]] = await db.batch().read(_objectSpread(_objectSpread({}, _defaults.default.db), {}, {
            query: {
              PK: FORM_PK,
              SK: SK_FORM_REVISION(version)
            }
          })).read(_objectSpread(_objectSpread({}, _defaults.default.db), {}, {
            query: {
              PK: FORM_PK,
              SK: SK_FORM_LATEST()
            }
          })).read(_objectSpread(_objectSpread({}, _defaults.default.db), {}, {
            query: {
              PK: FORM_PK,
              SK: SK_FORM_LATEST_PUBLISHED()
            }
          })).execute();

          if (!form) {
            throw new _handlerGraphql.NotFoundError(`Form "${id}" was not found!`);
          }

          (0, utils.checkOwnership)(form, permission, context);
          const savedOn = new Date().toISOString();
          const status = utils.getStatus({
            published: false,
            locked: true
          });
          Object.assign(form, {
            published: false,
            savedOn,
            status
          }); // Update DB item

          const batch = db.batch().update(_objectSpread(_objectSpread({}, _defaults.default.db), {}, {
            query: {
              PK: FORM_PK,
              SK: SK_FORM_REVISION(version)
            },
            data: form
          })); // Update or delete "latest published" item from DB

          if (latestPublishedForm.id === id) {
            const [revisions] = await db.read(_objectSpread(_objectSpread({}, _defaults.default.db), {}, {
              query: {
                PK: FORM_PK,
                SK: {
                  $beginsWith: "REV#"
                }
              },
              sort: {
                SK: -1
              }
            })); // Find published revision with highest publishedOn data

            const publishedRevision = revisions.filter(rev => rev.id !== id && rev.publishedOn !== null).sort((a, b) => new Date(b.publishedOn).getTime() - new Date(a.publishedOn).getTime()).shift();

            if (publishedRevision) {
              batch.update(_objectSpread(_objectSpread({}, _defaults.default.db), {}, {
                query: {
                  PK: FORM_PK,
                  SK: SK_FORM_LATEST_PUBLISHED()
                },
                data: {
                  PK: FORM_PK,
                  SK: SK_FORM_LATEST_PUBLISHED(),
                  TYPE: TYPE_FORM_LATEST_PUBLISHED,
                  id: publishedRevision.id,
                  version: publishedRevision.version
                }
              }));
            } else {
              batch.delete(_objectSpread(_objectSpread({}, _defaults.default.db), {}, {
                query: {
                  PK: FORM_PK,
                  SK: SK_FORM_LATEST_PUBLISHED()
                }
              }));
            }
          } // Update form in "Elastic Search"


          if (latestForm.id === id) {
            batch.update(_objectSpread(_objectSpread({}, _defaults.default.esDb), {}, {
              query: {
                PK: PK_FORM(uniqueId),
                SK: SK_FORM_LATEST()
              },
              data: {
                PK: PK_FORM(uniqueId),
                SK: SK_FORM_LATEST(),
                index: _defaults.default.es(context).index,
                data: getESDataForLatestRevision(form, context)
              }
            }));
          }

          await batch.execute();
          return form;
        },

        async createFormRevision(sourceRevisionId) {
          await utils.checkBaseFormPermissions(context, {
            rwd: "w"
          });
          const batch = db.batch();
          const [uniqueId, version] = sourceRevisionId.split("#");
          const FORM_PK = PK_FORM(uniqueId);
          const [[[form]], [[latestForm]]] = await batch.read(_objectSpread(_objectSpread({}, _defaults.default.db), {}, {
            query: {
              PK: FORM_PK,
              SK: SK_FORM_REVISION(version)
            }
          })).read(_objectSpread(_objectSpread({}, _defaults.default.db), {}, {
            query: {
              PK: FORM_PK,
              SK: SK_FORM_LATEST()
            }
          })).execute();

          if (!form) {
            throw new _handlerGraphql.NotFoundError(`Form "${sourceRevisionId}" was not found!`);
          }

          const identity = context.security.getIdentity();
          const newVersion = latestForm.version + 1;
          const id = `${uniqueId}#${zeroPad(newVersion)}`;
          const newRevision = {
            id,
            locale: form.locale,
            savedOn: new Date().toISOString(),
            createdOn: new Date().toISOString(),
            createdBy: {
              id: identity.id,
              displayName: identity.displayName,
              type: identity.type
            },
            ownedBy: form.ownedBy,
            name: form.name,
            slug: form.slug,
            version: newVersion,
            locked: false,
            published: false,
            publishedOn: null,
            status: utils.getStatus({
              published: false,
              locked: false
            }),
            fields: form.fields,
            layout: form.layout,
            stats: {
              submissions: 0,
              views: 0
            },
            settings: form.settings,
            triggers: form.triggers,
            tenant: form.tenant
          }; // Store form to DB and update `latest revision` item

          await db.batch().create(_objectSpread(_objectSpread({}, _defaults.default.db), {}, {
            data: _objectSpread({
              PK: FORM_PK,
              SK: SK_FORM_REVISION(newVersion),
              TYPE: "fb.form"
            }, newRevision)
          })).update(_objectSpread(_objectSpread({}, _defaults.default.db), {}, {
            query: {
              PK: FORM_PK,
              SK: SK_FORM_LATEST()
            },
            data: {
              PK: FORM_PK,
              SK: SK_FORM_LATEST(),
              TYPE: TYPE_FORM_LATEST,
              id: newRevision.id,
              version: newRevision.version
            }
          })).update(_objectSpread(_objectSpread({}, _defaults.default.esDb), {}, {
            query: {
              PK: FORM_PK,
              SK: SK_FORM_LATEST()
            },
            data: {
              PK: FORM_PK,
              SK: SK_FORM_LATEST(),
              index: _defaults.default.es(context).index,
              data: getESDataForLatestRevision(newRevision, context)
            }
          })).execute();
          return newRevision;
        },

        async incrementFormViews(id) {
          const [uniqueId, version] = id.split("#");
          const FORM_PK = PK_FORM(uniqueId);
          const FORM_SK = SK_FORM_REVISION(version);
          const [[form]] = await db.read(_objectSpread(_objectSpread({}, _defaults.default.db), {}, {
            query: {
              PK: FORM_PK,
              SK: FORM_SK
            }
          }));

          if (!form) {
            throw new _handlerGraphql.NotFoundError(`Form "${id}" was not found!`);
          } // Increment views


          form.stats.views = form.stats.views + 1; // Update "form stats" in DB.

          await db.update(_objectSpread(_objectSpread({}, _defaults.default.db), {}, {
            query: {
              PK: FORM_PK,
              SK: FORM_SK
            },
            data: {
              stats: form.stats
            }
          }));
          return true;
        },

        async incrementFormSubmissions(id) {
          const [uniqueId, version] = id.split("#");
          const FORM_PK = PK_FORM(uniqueId);
          const FORM_SK = SK_FORM_REVISION(version);
          const [[form]] = await db.read(_objectSpread(_objectSpread({}, _defaults.default.db), {}, {
            query: {
              PK: FORM_PK,
              SK: FORM_SK
            }
          }));

          if (!form) {
            throw new _handlerGraphql.NotFoundError(`Form "${id}" was not found!`);
          } // Increment submissions


          form.stats.submissions++; // Update "form stats" in DB.

          await db.update(_objectSpread(_objectSpread({}, _defaults.default.db), {}, {
            query: {
              PK: FORM_PK,
              SK: FORM_SK
            },
            data: {
              stats: form.stats
            }
          }));
          return true;
        },

        async getSubmissionsByIds(formId, submissionIds) {
          const [uniqueId] = formId.split("#");
          const FORM_PK = PK_FORM(uniqueId);
          const batch = db.batch();
          batch.read(...submissionIds.map(submissionId => _objectSpread(_objectSpread({}, _defaults.default.db), {}, {
            query: {
              PK: FORM_PK,
              SK: `FS#${submissionId}`
            }
          })));
          const response = await batch.execute();
          return response.map(item => {
            const [[formSubmission]] = item;
            return formSubmission;
          }).filter(Boolean);
        },

        async listFormSubmissions(formId, options = {}) {
          const {
            submissions
          } = await utils.checkBaseFormPermissions(context);

          if (typeof submissions !== "undefined" && submissions !== true) {
            throw new _apiSecurity.NotAuthorizedError();
          }
          /**
           * Check if current identity is allowed to access this form.
           */


          await this.getForm(formId);
          const {
            sort = {
              createdOn: -1
            },
            after = null
          } = options;
          let {
            limit = 10
          } = options; // 10000 is a hard limit of ElasticSearch for `size` parameter.

          if (limit >= 10000) {
            limit = 9999;
          }

          const [uniqueId] = formId.split("#");
          const filter = [{
            term: {
              "__type.keyword": "fb.submission"
            }
          }, {
            term: {
              "locale.keyword": i18nContent.locale.code
            }
          }, // Load all form submissions no matter the revision
          {
            term: {
              "form.parent.keyword": uniqueId
            }
          }]; // When ES index is shared between tenants, we need to filter records by tenant ID

          const sharedIndex = process.env.ELASTICSEARCH_SHARED_INDEXES === "true";

          if (sharedIndex) {
            const tenant = tenancy.getCurrentTenant();
            filter.push({
              term: {
                "tenant.keyword": tenant.id
              }
            });
          }

          const body = {
            query: {
              bool: {
                filter
              }
            },
            size: limit + 1,
            sort: [{
              createdOn: {
                order: sort.createdOn > 0 ? "asc" : "desc"
              }
            }]
          };

          if (after) {
            body["search_after"] = utils.decodeCursor(after);
          }

          const response = await elasticsearch.search(_objectSpread(_objectSpread({}, _defaults.default.es(context)), {}, {
            body
          }));
          const {
            hits,
            total
          } = response.body.hits;
          const items = hits.map(item => item._source);
          const hasMoreItems = items.length > limit;

          if (hasMoreItems) {
            // Remove the last item from results, we don't want to include it.
            items.pop();
          } // Cursor is the `sort` value of the last item in the array.
          // https://www.elastic.co/guide/en/elasticsearch/reference/current/paginate-search-results.html#search-after


          const meta = {
            hasMoreItems,
            totalCount: total.value,
            cursor: items.length > 0 ? (0, utils.encodeCursor)(hits[items.length - 1].sort) : null
          };
          return [items, meta];
        },

        async createFormSubmission(formId, reCaptchaResponseToken, rawData, meta) {
          const {
            formBuilder
          } = context;
          const [uniqueId, version] = formId.split("#");
          const [[form]] = await db.read(_objectSpread(_objectSpread({}, _defaults.default.db), {}, {
            query: {
              PK: PK_FORM(uniqueId),
              SK: SK_FORM_REVISION(version)
            }
          }));

          if (!form) {
            throw new _handlerGraphql.NotFoundError(`Form "${formId}" was not found!`);
          }

          const settings = await formBuilder.settings.getSettings({
            auth: false
          });

          if (settings.reCaptcha && settings.reCaptcha.enabled) {
            if (!reCaptchaResponseToken) {
              throw new Error("Missing reCAPTCHA response token - cannot verify.");
            }

            const {
              secretKey
            } = settings.reCaptcha;
            const recaptchaResponse = await (0, _nodeFetch.default)("https://www.google.com/recaptcha/api/siteverify", {
              method: "POST",
              body: JSON.stringify({
                secret: secretKey,
                response: reCaptchaResponseToken
              })
            });
            let responseIsValid = false;

            try {
              const validationResponse = await recaptchaResponse.json();

              if (validationResponse.success) {
                responseIsValid = true;
              }
            } catch (e) {}

            if (!responseIsValid) {
              throw new Error("reCAPTCHA verification failed.");
            }
          } // Validate data


          const validatorPlugins = context.plugins.byType("fb-form-field-validator");
          const {
            fields
          } = form;
          const data = (0, _pick.default)(rawData, fields.map(field => field.fieldId));

          if (Object.keys(data).length === 0) {
            throw new Error("Form data cannot be empty.");
          }

          const invalidFields = {};

          for (let i = 0; i < fields.length; i++) {
            const field = fields[i];

            if (Array.isArray(field.validation)) {
              for (let j = 0; j < field.validation.length; j++) {
                const validator = field.validation[j];
                const validatorPlugin = validatorPlugins.find(item => item.validator.name === validator.name);

                if (!validatorPlugin) {
                  continue;
                }

                let isInvalid = true;

                try {
                  const result = await validatorPlugin.validator.validate(data[field.fieldId], validator);
                  isInvalid = result === false;
                } catch (e) {
                  isInvalid = true;
                }

                if (isInvalid) {
                  invalidFields[field.fieldId] = validator.message || "Invalid value";
                }
              }
            }
          }

          if (Object.keys(invalidFields).length > 0) {
            throw {
              message: "Form submission contains invalid fields.",
              data: {
                invalidFields
              }
            };
          } // Use model for data validation and default values.


          const submissionModel = new models.FormSubmissionCreateDataModel().populate({
            data,
            meta,
            form: {
              id: form.id,
              parent: uniqueId,
              name: form.name,
              version: form.version,
              fields: form.fields,
              layout: form.layout
            }
          });
          await submissionModel.validate();

          const submission = _objectSpread({
            id: (0, _mdbid.default)(),
            locale: form.locale,
            ownedBy: form.ownedBy
          }, await submissionModel.toJSON()); // Store submission to DB


          await db.batch().create(_objectSpread(_objectSpread({}, _defaults.default.db), {}, {
            data: _objectSpread({
              PK: PK_FORM(uniqueId),
              SK: SK_SUBMISSION(submission.id),
              TYPE: TYPE_FORM_SUBMISSION,
              tenant: form.tenant
            }, submission)
          })).create(_objectSpread(_objectSpread({}, _defaults.default.esDb), {}, {
            data: {
              PK: PK_FORM(uniqueId),
              SK: SK_SUBMISSION(submission.id),
              index: _defaults.default.es(context).index,
              data: _objectSpread({
                __type: "fb.submission",
                webinyVersion: context.WEBINY_VERSION,
                createdOn: new Date().toISOString(),
                tenant: context.tenancy.getCurrentTenant().id
              }, submission)
            }
          })).execute();
          submission.logs = [...(submission.logs || []), {
            type: "info",
            message: "Form submission created."
          }];

          try {
            // Execute triggers
            if (form.triggers) {
              const plugins = context.plugins.byType("form-trigger-handler");

              for (let i = 0; i < plugins.length; i++) {
                const plugin = plugins[i];

                if (form.triggers[plugin.trigger]) {
                  await plugin.handle({
                    form: form,
                    addLog: log => {
                      submission.logs = [...submission.logs, log];
                    },
                    data,
                    meta,
                    trigger: form.triggers[plugin.trigger]
                  });
                }
              }
            }

            submission.logs = [...submission.logs, {
              type: "success",
              message: "Form submitted successfully."
            }];
            await formBuilder.forms.incrementFormSubmissions(form.id);
          } catch (e) {
            submission.logs = [...submission.logs, {
              type: "error",
              message: e.message
            }];
          } finally {
            // Save submission to include the logs that were added during trigger processing.
            await formBuilder.forms.updateSubmission(form.id, submission);
          }

          return submission;
        },

        async updateSubmission(formId, data) {
          await new models.FormSubmissionUpdateDataModel().populate(data).validate();
          const [uniqueId] = formId.split("#"); // Finally save it to DB

          await db.update(_objectSpread(_objectSpread({}, _defaults.default.db), {}, {
            query: {
              PK: PK_FORM(uniqueId),
              SK: SK_SUBMISSION(data.id)
            },
            data: {
              logs: data.logs
            }
          }));
          return true;
        },

        async deleteSubmission(formId, submissionId) {
          const [uniqueId] = formId.split("#");
          await db.batch().delete(_objectSpread(_objectSpread({}, _defaults.default.db), {}, {
            query: {
              PK: PK_FORM(uniqueId),
              SK: SK_SUBMISSION(submissionId)
            }
          })).delete(_objectSpread(_objectSpread({}, _defaults.default.esDb), {}, {
            query: {
              PK: PK_FORM(uniqueId),
              SK: SK_SUBMISSION(submissionId)
            }
          })).execute();
          return true;
        }

      }
    });
  }

};
exports.default = _default;
//# sourceMappingURL=forms.crud.js.map