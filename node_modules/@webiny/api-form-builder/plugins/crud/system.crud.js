"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _error = _interopRequireDefault(require("@webiny/error"));

var _apiSecurity = require("@webiny/api-security");

var _apiUpgrade = require("@webiny/api-upgrade");

var _defaults = _interopRequireDefault(require("./defaults"));

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

var _default = {
  type: "context",

  apply(context) {
    const {
      tenancy
    } = context;

    const keys = () => ({
      PK: `T#${tenancy.getCurrentTenant().id}#SYSTEM`,
      SK: "FB"
    });

    context.formBuilder = _objectSpread(_objectSpread({}, context.formBuilder), {}, {
      system: {
        async getVersion() {
          const {
            db
          } = context;
          const [[system]] = await db.read(_objectSpread(_objectSpread({}, _defaults.default.db), {}, {
            query: keys()
          }));
          return system ? system.version : null;
        },

        async setVersion(version) {
          const {
            db
          } = context;
          const [[system]] = await db.read(_objectSpread(_objectSpread({}, _defaults.default.db), {}, {
            query: keys()
          }));

          if (system) {
            await db.update(_objectSpread(_objectSpread({}, _defaults.default.db), {}, {
              query: keys(),
              data: {
                version
              }
            }));
          } else {
            await db.create(_objectSpread(_objectSpread({}, _defaults.default.db), {}, {
              data: _objectSpread(_objectSpread({}, keys()), {}, {
                version
              })
            }));
          }
        },

        async install({
          domain
        }) {
          const {
            db,
            i18n,
            formBuilder,
            elasticsearch
          } = context;
          const version = await this.getVersion();

          if (version) {
            throw new _error.default("Form builder is already installed.", "FORM_BUILDER_INSTALL_ABORTED");
          } // Prepare "settings" data


          const data = {};

          if (domain) {
            data.domain = domain;
          }

          await formBuilder.settings.createSettings(data); // Create ES index if it doesn't already exist.

          try {
            const esIndex = _defaults.default.es(context);

            const {
              body: exists
            } = await elasticsearch.indices.exists(esIndex);

            if (!exists) {
              await elasticsearch.indices.create(_objectSpread(_objectSpread({}, esIndex), {}, {
                body: {
                  // need this part for sorting to work on text fields
                  settings: {
                    analysis: {
                      analyzer: {
                        lowercase_analyzer: {
                          type: "custom",
                          filter: ["lowercase", "trim"],
                          tokenizer: "keyword"
                        }
                      }
                    }
                  },
                  mappings: {
                    properties: {
                      property: {
                        type: "text",
                        fields: {
                          keyword: {
                            type: "keyword",
                            ignore_above: 256
                          }
                        },
                        analyzer: "lowercase_analyzer"
                      }
                    }
                  }
                }
              }));
            }
          } catch (err) {
            await db.delete(_objectSpread(_objectSpread({}, _defaults.default.db), {}, {
              query: {
                PK: `T#root#L#${i18n.getDefaultLocale().code}#FB#SETTINGS`,
                SK: "default"
              }
            }));
            throw new _error.default("Form builder failed to install!", "FORM_BUILDER_INSTALL_ABORTED", {
              reason: err.message
            });
          }

          await formBuilder.system.setVersion(context.WEBINY_VERSION);
        },

        async upgrade(version) {
          const identity = context.security.getIdentity();

          if (!identity) {
            throw new _apiSecurity.NotAuthorizedError();
          }

          const upgradePlugins = context.plugins.byType("api-upgrade").filter(pl => pl.app === "form-builder");
          const plugin = (0, _apiUpgrade.getApplicablePlugin)({
            deployedVersion: context.WEBINY_VERSION,
            installedAppVersion: await this.getVersion(),
            upgradePlugins,
            upgradeToVersion: version
          });
          await plugin.apply(context); // Store new app version

          await this.setVersion(version);
          return true;
        }

      }
    });
  }

};
exports.default = _default;
//# sourceMappingURL=system.crud.js.map