"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.paginateBatch = exports.decodeCursor = exports.encodeCursor = exports.checkOwnership = exports.getPKPrefix = exports.normalizeSortInput = exports.hasPW = exports.hasRwd = exports.getStatus = exports.getFormId = exports.checkBaseSettingsPermissions = exports.checkBaseFormPermissions = void 0;

var _apiSecurity = require("@webiny/api-security");

const checkBaseFormPermissions = async (context, check = {}) => {
  await context.i18nContent.checkI18NContentPermission();
  const permission = await context.security.getPermission("fb.form");

  if (!permission) {
    throw new _apiSecurity.NotAuthorizedError();
  }

  if (check.rwd && !hasRwd(permission, check.rwd)) {
    throw new _apiSecurity.NotAuthorizedError();
  }

  if (check.pw && !hasPW(permission, check.pw)) {
    throw new _apiSecurity.NotAuthorizedError();
  }

  return permission;
};

exports.checkBaseFormPermissions = checkBaseFormPermissions;

const checkBaseSettingsPermissions = async context => {
  const permission = await context.security.getPermission("fb.settings");

  if (!permission) {
    throw new _apiSecurity.NotAuthorizedError();
  }

  return permission;
};

exports.checkBaseSettingsPermissions = checkBaseSettingsPermissions;

const getFormId = form => {
  if (form.id.includes("#")) {
    return `${form.id.split("#")[0]}#${form.version}`;
  }

  return `${form.id}#${form.version}`;
};

exports.getFormId = getFormId;

const getStatus = params => {
  if (params.published) {
    return "published";
  }

  return params.locked ? "locked" : "draft";
}; // Has read/write/delete permissions?


exports.getStatus = getStatus;

const hasRwd = (permission, rwd) => {
  if (typeof permission.rwd !== "string") {
    return true;
  }

  return permission.rwd.includes(rwd);
}; // Has publishing workflow permissions?


exports.hasRwd = hasRwd;

const hasPW = (permission, pw) => {
  const isCustom = Object.keys(permission).length > 1; // "name" key is always present

  if (!isCustom) {
    // Means it's a "full-access" permission.
    return true;
  }

  if (typeof permission.pw !== "string") {
    return false;
  }

  return permission.pw.includes(pw);
};

exports.hasPW = hasPW;

const normalizeSortInput = sort => {
  const [[key, value]] = Object.entries(sort);
  const shouldUseKeyword = ["name"];

  if (shouldUseKeyword.includes(key)) {
    return {
      [`${key}.keyword`]: {
        order: value === -1 ? "desc" : "asc"
      }
    };
  }

  return {
    [key]: {
      order: value === -1 ? "desc" : "asc"
    }
  };
};

exports.normalizeSortInput = normalizeSortInput;

const getPKPrefix = context => {
  const {
    tenancy,
    i18nContent
  } = context;

  if (!tenancy.getCurrentTenant()) {
    throw new Error("Tenant missing.");
  }

  if (!i18nContent.getLocale()) {
    throw new Error("Locale missing.");
  }

  return `T#${tenancy.getCurrentTenant().id}#L#${i18nContent.getLocale().code}#FB#`;
};

exports.getPKPrefix = getPKPrefix;

const checkOwnership = (form, permission, context) => {
  if (permission.own === true) {
    const identity = context.security.getIdentity();

    if (form.ownedBy.id !== identity.id) {
      throw new _apiSecurity.NotAuthorizedError();
    }
  }
};

exports.checkOwnership = checkOwnership;

const encodeCursor = cursor => {
  if (!cursor) {
    return null;
  }

  return Buffer.from(JSON.stringify(cursor)).toString("base64");
};

exports.encodeCursor = encodeCursor;

const decodeCursor = cursor => {
  if (!cursor) {
    return null;
  }

  return JSON.parse(Buffer.from(cursor, "base64").toString("ascii"));
};

exports.decodeCursor = decodeCursor;

const paginateBatch = async (items, perPage, execute) => {
  const pages = Math.ceil(items.length / perPage);

  for (let i = 0; i < pages; i++) {
    await execute(items.slice(i * perPage, i * perPage + perPage));
  }
};

exports.paginateBatch = paginateBatch;
//# sourceMappingURL=utils.js.map