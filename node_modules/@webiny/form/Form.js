import _toConsumableArray from "@babel/runtime/helpers/toConsumableArray";
import _objectSpread from "@babel/runtime/helpers/objectSpread2";
import _asyncToGenerator from "@babel/runtime/helpers/asyncToGenerator";
import _classCallCheck from "@babel/runtime/helpers/classCallCheck";
import _createClass from "@babel/runtime/helpers/createClass";
import _assertThisInitialized from "@babel/runtime/helpers/assertThisInitialized";
import _inherits from "@babel/runtime/helpers/inherits";
import _createSuper from "@babel/runtime/helpers/createSuper";
import _defineProperty from "@babel/runtime/helpers/defineProperty";
import _isFunction from "lodash/isFunction";
import _keys from "lodash/keys";
import _get from "lodash/get";
import _has from "lodash/has";
import _each from "lodash/each";
import _isPlainObject from "lodash/isPlainObject";
import _cloneDeep from "lodash/cloneDeep";
import _isEqual from "lodash/isEqual";
import _regeneratorRuntime from "@babel/runtime/regenerator";
import * as React from "react";
import set from "lodash/fp/set";
import { createBind } from "./Bind";
import { linkState } from "./linkState";
import ValidationError from "./ValidationError";
export var Form = /*#__PURE__*/function (_React$Component) {
  _inherits(Form, _React$Component);

  var _super = _createSuper(Form);

  function Form() {
    var _this;

    _classCallCheck(this, Form);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    _defineProperty(_assertThisInitialized(_this), "state", {
      data: _this.props.data || {},
      originalData: _this.props.data || {},
      wasSubmitted: false,
      validation: {}
    });

    _defineProperty(_assertThisInitialized(_this), "isValid", null);

    _defineProperty(_assertThisInitialized(_this), "inputs", {});

    _defineProperty(_assertThisInitialized(_this), "lastRender", []);

    _defineProperty(_assertThisInitialized(_this), "validateFns", {});

    _defineProperty(_assertThisInitialized(_this), "onChangeFns", {});

    _defineProperty(_assertThisInitialized(_this), "Bind", createBind(_assertThisInitialized(_this)));

    _defineProperty(_assertThisInitialized(_this), "onInvalid", function () {
      if (typeof _this.props.onInvalid === "function") {
        _this.props.onInvalid();
      }
    });

    _defineProperty(_assertThisInitialized(_this), "submit", function (event) {
      // If event is present - prevent default behaviour
      if (event && event.preventDefault) {
        event.preventDefault();
      }

      _this.setState({
        wasSubmitted: true
      });

      return _this.validate().then(function (valid) {
        if (valid) {
          var _data = _this.state.data; // Make sure all current inputs have a value in the model (defaultValues do not exist in form data)

          var inputNames = Object.keys(_this.inputs);
          inputNames.forEach(function (name) {
            var defaultValue = _this.inputs[name].defaultValue;

            if (!_has(_data, name) && typeof defaultValue !== "undefined") {
              _data = set(name, defaultValue, _data);
            }
          });

          if (_this.props.onSubmit) {
            return _this.props.onSubmit(_data, _assertThisInitialized(_this));
          }

          return;
        }

        return _this.onInvalid();
      });
    });

    _defineProperty(_assertThisInitialized(_this), "validate", /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {
      var _this$state, _this$state$data, data, _this$state$validatio, validation, promises, results;

      return _regeneratorRuntime.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              _this$state = _this.state, _this$state$data = _this$state.data, data = _this$state$data === void 0 ? {} : _this$state$data, _this$state$validatio = _this$state.validation, validation = _this$state$validatio === void 0 ? {} : _this$state$validatio;
              promises = Object.keys(_this.inputs).map( /*#__PURE__*/function () {
                var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(name) {
                  var validators, hasValue, isInputValid, shouldValidate, result;
                  return _regeneratorRuntime.wrap(function _callee$(_context) {
                    while (1) {
                      switch (_context.prev = _context.next) {
                        case 0:
                          validators = _this.inputs[name].validators;

                          if (!(!validators || validators.length === 0)) {
                            _context.next = 3;
                            break;
                          }

                          return _context.abrupt("return", true);

                        case 3:
                          hasValue = !!data[name];
                          isInputValid = validation[name] ? validation[name].isValid : undefined;
                          shouldValidate = !hasValue || hasValue && isInputValid !== true;

                          if (shouldValidate) {
                            _context.next = 8;
                            break;
                          }

                          return _context.abrupt("return", true);

                        case 8:
                          if (!isInputValid) {
                            _context.next = 10;
                            break;
                          }

                          return _context.abrupt("return", true);

                        case 10:
                          _context.next = 12;
                          return _this.validateInput(name);

                        case 12:
                          result = _context.sent;

                          if (!(result === false)) {
                            _context.next = 15;
                            break;
                          }

                          return _context.abrupt("return", false);

                        case 15:
                          return _context.abrupt("return", true);

                        case 16:
                        case "end":
                          return _context.stop();
                      }
                    }
                  }, _callee);
                }));

                return function (_x) {
                  return _ref2.apply(this, arguments);
                };
              }());
              _context2.next = 4;
              return Promise.all(promises);

            case 4:
              results = _context2.sent;
              return _context2.abrupt("return", results.every(function (value) {
                return value === true;
              }));

            case 6:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2);
    })));

    _defineProperty(_assertThisInitialized(_this), "validateInput", /*#__PURE__*/function () {
      var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(name) {
        var value, validators, hasValidators, formData;
        return _regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                _context3.next = 2;
                return new Promise(function (res) {
                  return setTimeout(res, 10);
                });

              case 2:
                if (!(_this.props.validateOnFirstSubmit && !_this.state.wasSubmitted || !_this.inputs[name])) {
                  _context3.next = 4;
                  break;
                }

                return _context3.abrupt("return", Promise.resolve(null));

              case 4:
                value = _get(_this.state.data, name, _this.inputs[name].defaultValue);
                validators = _this.inputs[name].validators;
                hasValidators = _keys(validators).length; // Validate input

                formData = {
                  inputs: _this.inputs,
                  data: _objectSpread({}, _this.state.data)
                };

                _this.setState(function (state) {
                  return _objectSpread(_objectSpread({}, state), {}, {
                    validation: _objectSpread(_objectSpread({}, state.validation), {}, _defineProperty({}, name, _objectSpread(_objectSpread({}, state.validation[name]), {}, {
                      isValidating: true
                    })))
                  });
                });

                return _context3.abrupt("return", Promise.resolve(Form.executeValidators(value, validators, formData)).then(function (validationResults) {
                  var isValid = hasValidators ? value === null ? null : true : null;

                  _this.setState(function (state) {
                    return _objectSpread(_objectSpread({}, state), {}, {
                      validation: _objectSpread(_objectSpread({}, state.validation), {}, _defineProperty({}, name, {
                        isValid: isValid,
                        message: null,
                        results: validationResults
                      }))
                    });
                  });

                  return validationResults;
                }).catch(function (validationError) {
                  // Set component state to reflect validation error
                  _this.setState(function (state) {
                    return _objectSpread(_objectSpread({}, state), {}, {
                      validation: _objectSpread(_objectSpread({}, state.validation), {}, _defineProperty({}, name, {
                        isValid: false,
                        message: validationError.getMessage(),
                        results: false
                      }))
                    });
                  });

                  return false;
                }));

              case 10:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3);
      }));

      return function (_x2) {
        return _ref3.apply(this, arguments);
      };
    }());

    _defineProperty(_assertThisInitialized(_this), "getOnChangeFn", function (_ref4) {
      var name = _ref4.name,
          beforeChange = _ref4.beforeChange,
          afterChange = _ref4.afterChange;

      if (!_this.onChangeFns[name]) {
        var linkStateChange = linkState(_assertThisInitialized(_this), "data.".concat(name));

        var baseOnChange = function baseOnChange(newValue, cb) {
          // When linkState is done processing the value change...
          return linkStateChange(newValue, cb).then(function (value) {
            // call the Form onChange with updated data
            if (typeof _this.props.onChange === "function") {
              _this.props.onChange(_objectSpread({}, _this.state.data), _assertThisInitialized(_this));
            } // Execute onAfterChange


            afterChange && afterChange(value, _assertThisInitialized(_this));
            return value;
          });
        };

        var onChange = beforeChange ? function (newValue) {
          return beforeChange(newValue, baseOnChange);
        } : baseOnChange;
        _this.onChangeFns[name] = onChange;
      }

      return _this.onChangeFns[name];
    });

    _defineProperty(_assertThisInitialized(_this), "getValidateFn", function (name) {
      if (!_this.validateFns[name]) {
        _this.validateFns[name] = function () {
          return _this.validateInput(name);
        };
      }

      return _this.validateFns[name];
    });

    _defineProperty(_assertThisInitialized(_this), "setValue", function (name, value) {
      _this.onChangeFns[name](value);
    });

    _defineProperty(_assertThisInitialized(_this), "reset", function () {
      _this.setState({
        data: _cloneDeep(_this.state.originalData)
      });
    });

    _defineProperty(_assertThisInitialized(_this), "__onKeyDown", function (e) {
      var _this$props$submitOnE = _this.props.submitOnEnter,
          submitOnEnter = _this$props$submitOnE === void 0 ? false : _this$props$submitOnE;

      if ((submitOnEnter || e.metaKey || e.ctrlKey) && e.key === "Enter" && !e.isDefaultPrevented()) {
        // Need to blur current target in case of input fields to trigger validation
        // @ts-ignore
        e.target && e.target.blur();
        e.preventDefault();
        e.stopPropagation(); // Fire submit with a small delay to allow input validation to complete.
        // Not an ideal solution but works fine at this point. Will revisit this later.

        setTimeout(function () {
          return _this.submit();
        }, 100);
      }
    });

    return _this;
  }

  _createClass(Form, [{
    key: "data",
    get: function get() {
      return this.state.data;
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate() {
      var _this2 = this;

      Object.keys(this.inputs).forEach(function (name) {
        if (!_this2.lastRender.includes(name)) {
          delete _this2.inputs[name];

          _this2.setState(function (state) {
            var validation = _objectSpread({}, state.validation);

            delete validation[name];
            return {
              validation: validation
            };
          });
        }
      });
    }
  }, {
    key: "render",
    value: function render() {
      var children = this.props.children;

      if (!_isFunction(children)) {
        throw new Error("Form must have a function as its only child!");
      }

      this.lastRender = [];
      return /*#__PURE__*/React.createElement("webiny-form-container", {
        onKeyDown: this.__onKeyDown
      }, children({
        data: _cloneDeep(this.state.data),
        setValue: this.setValue,
        form: this,
        submit: this.submit,
        Bind: this.Bind
      }));
    }
  }], [{
    key: "getDerivedStateFromProps",
    value: function getDerivedStateFromProps(_ref5, state) {
      var data = _ref5.data,
          _ref5$invalidFields = _ref5.invalidFields,
          invalidFields = _ref5$invalidFields === void 0 ? {} : _ref5$invalidFields;

      // If we received new `data`, overwrite current `data` in the state
      if (!_isEqual(state.originalData, data)) {
        return {
          data: data,
          originalData: data,
          validation: {}
        };
      } // Check for validation errors


      var validation = _cloneDeep(state.validation);

      if (_isPlainObject(invalidFields) && Object.keys(invalidFields).length) {
        _each(invalidFields, function (message, name) {
          validation = _objectSpread(_objectSpread({}, validation), {}, _defineProperty({}, name, {
            isValid: false,
            message: message
          }));
        });
      } // Return new state only if something has changed


      return !_isEqual(validation, state.validation) ? {
        validation: validation
      } : null;
    }
  }]);

  return Form;
}(React.Component);

_defineProperty(Form, "defaultProps", {
  data: {},
  disabled: false,
  validateOnFirstSubmit: false,
  onSubmit: null
});

_defineProperty(Form, "executeValidators", /*#__PURE__*/function () {
  var _ref6 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(value, validators) {
    var formData,
        results,
        _loop,
        i,
        _args5 = arguments;

    return _regeneratorRuntime.wrap(function _callee4$(_context5) {
      while (1) {
        switch (_context5.prev = _context5.next) {
          case 0:
            formData = _args5.length > 2 && _args5[2] !== undefined ? _args5[2] : {};
            validators = Array.isArray(validators) ? _toConsumableArray(validators) : [validators];
            results = {};
            _loop = /*#__PURE__*/_regeneratorRuntime.mark(function _loop(i) {
              var validator;
              return _regeneratorRuntime.wrap(function _loop$(_context4) {
                while (1) {
                  switch (_context4.prev = _context4.next) {
                    case 0:
                      validator = validators[i];
                      _context4.prev = 1;
                      _context4.next = 4;
                      return Promise.resolve(validator(value, formData)).then(function (result) {
                        if (result instanceof Error) {
                          throw result;
                        }

                        results[i] = result;
                      }).catch(function (e) {
                        throw new ValidationError(e.message, value);
                      });

                    case 4:
                      _context4.next = 9;
                      break;

                    case 6:
                      _context4.prev = 6;
                      _context4.t0 = _context4["catch"](1);
                      throw new ValidationError(_context4.t0.message, value);

                    case 9:
                    case "end":
                      return _context4.stop();
                  }
                }
              }, _loop, null, [[1, 6]]);
            });
            i = 0;

          case 5:
            if (!(i < validators.length)) {
              _context5.next = 10;
              break;
            }

            return _context5.delegateYield(_loop(i), "t0", 7);

          case 7:
            i++;
            _context5.next = 5;
            break;

          case 10:
            return _context5.abrupt("return", results);

          case 11:
          case "end":
            return _context5.stop();
        }
      }
    }, _callee4);
  }));

  return function (_x3, _x4) {
    return _ref6.apply(this, arguments);
  };
}());
//# sourceMappingURL=Form.js.map