"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _renderUrl = _interopRequireDefault(require("./renderUrl"));

var _path = _interopRequireDefault(require("path"));

var _s = _interopRequireDefault(require("aws-sdk/clients/s3"));

var _getStorageName = _interopRequireDefault(require("./../utils/getStorageName"));

var _getStorageFolder = _interopRequireDefault(require("./../utils/getStorageFolder"));

var _getDbNamespace = _interopRequireDefault(require("./../utils/getDbNamespace"));

var _getRenderUrl = _interopRequireDefault(require("./../utils/getRenderUrl"));

var _getTagUrlLinkPKSK = _interopRequireDefault(require("./../utils/getTagUrlLinkPKSK"));

var _types = require("../types");

var _defaults = _interopRequireDefault(require("./../utils/defaults"));

var _omit = _interopRequireDefault(require("lodash/omit"));

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

const sleep = () => new Promise(resolve => setTimeout(resolve, 1000));

const s3 = new _s.default({
  region: process.env.AWS_REGION
});

const storeFile = ({
  key,
  contentType,
  body,
  storageName
}) => {
  return s3.putObject({
    Bucket: storageName,
    Key: key,
    ACL: "public-read",
    ContentType: contentType,
    CacheControl: "max-age=30",
    Body: body
  }).promise();
};

var _default = configuration => ({
  type: "handler",

  async handle(context) {
    const {
      invocationArgs
    } = context;
    const handlerArgs = Array.isArray(invocationArgs) ? invocationArgs : [invocationArgs];
    const handlerHookPlugins = context.plugins.byType("ps-render-hook");
    console.log("Received args: ", JSON.stringify(invocationArgs));

    try {
      await sleep();

      for (let i = 0; i < handlerArgs.length; i++) {
        var _newIndexHtml$meta;

        const args = handlerArgs[i];

        for (let j = 0; j < handlerHookPlugins.length; j++) {
          const plugin = handlerHookPlugins[j];

          if (typeof plugin.beforeRender === "function") {
            await plugin.beforeRender({
              context,
              configuration,
              args
            });
          }
        }

        const dbNamespace = (0, _getDbNamespace.default)(args, configuration);
        const storageName = (0, _getStorageName.default)(args, configuration);
        const storageFolder = (0, _getStorageFolder.default)(args, configuration);
        const url = (0, _getRenderUrl.default)(args, configuration); // Check if render data for given URL already exists. If so, delete it.

        const PK = [dbNamespace, "PS", "RENDER"].filter(Boolean).join("#");
        const [[currentRenderData]] = await context.db.read(_objectSpread(_objectSpread({}, _defaults.default.db), {}, {
          query: {
            PK,
            SK: url
          }
        })); // TODO: will need to add flushing of all files created in the render process.

        const [files] = await (0, _renderUrl.default)(url, {
          context,
          configuration,
          args
        });

        for (let j = 0; j < files.length; j++) {
          const file = files[j];

          const key = _path.default.join(storageFolder, file.name);

          console.log(`Storing file "${key}" to storage "${storageName}".`);
          await storeFile({
            storageName,
            key,
            body: file.body,
            contentType: file.type
          });
        }

        const data = {
          PK,
          SK: url,
          TYPE: _types.TYPE.DbRender,
          url,
          args,
          configuration,
          files: files.map(item => (0, _omit.default)(item, ["body"]))
        };
        await context.db.create(_objectSpread(_objectSpread({}, _defaults.default.db), {}, {
          data
        })); // Let's delete existing tag / URL links.
        // TODO: improve - no need to do any DB calls if tags didn't change. So, let's
        // TODO: compare tags in `currentIndexHtml` and `newIndexHtml`.

        console.log("Checking if there are existing tag / URL links to remove...");

        if (currentRenderData) {
          var _currentIndexHtml$met;

          // Get currently stored tags and delete all tag-URL links.
          const currentIndexHtml = currentRenderData.files.find(item => item.name.endsWith(".html"));
          const currentIndexHtmlTags = currentIndexHtml === null || currentIndexHtml === void 0 ? void 0 : (_currentIndexHtml$met = currentIndexHtml.meta) === null || _currentIndexHtml$met === void 0 ? void 0 : _currentIndexHtml$met.tags;

          if (Array.isArray(currentIndexHtmlTags) && currentIndexHtmlTags.length) {
            console.log("There are existing tag / URL links to be deleted...", currentIndexHtmlTags);
            const batch = context.db.batch();

            for (let k = 0; k < currentIndexHtmlTags.length; k++) {
              const tag = currentIndexHtmlTags[k];
              const [PK, SK] = (0, _getTagUrlLinkPKSK.default)({
                tag,
                url,
                dbNamespace
              });

              if (PK && SK) {
                batch.delete({
                  query: {
                    PK,
                    SK
                  }
                });
              }
            }

            await batch.execute();
            console.log("Existing tag / URL links deleted.");
          } else {
            console.log("There are no existing tag / URL links to delete.");
          }
        } // Let's save tags - we link each distinct tag with the URL.


        console.log("Checking if there are new tag / URL links to save...");
        const newIndexHtml = files.find(item => item.name.endsWith(".html"));
        const newIndexHtmlTags = newIndexHtml === null || newIndexHtml === void 0 ? void 0 : (_newIndexHtml$meta = newIndexHtml.meta) === null || _newIndexHtml$meta === void 0 ? void 0 : _newIndexHtml$meta.tags;

        if (Array.isArray(newIndexHtmlTags) && newIndexHtmlTags.length) {
          console.log("There are new tag / URL links to be saved...", newIndexHtmlTags);
          const batch = context.db.batch();

          for (let k = 0; k < newIndexHtmlTags.length; k++) {
            const tag = newIndexHtmlTags[k];
            const [PK, SK] = (0, _getTagUrlLinkPKSK.default)({
              tag,
              url,
              dbNamespace
            });

            if (PK && SK) {
              const data = {
                PK,
                SK,
                TYPE: _types.TYPE.DbTagUrlLink,
                url,
                key: tag.key,
                value: tag.value
              };
              batch.create(_objectSpread(_objectSpread({}, _defaults.default.db), {}, {
                data
              }));
            }
          }

          await batch.execute();
          console.log("New tag / URL links saved.");
        } else {
          console.log("There are no new tag / URL links to save.");
        }

        for (let j = 0; j < handlerHookPlugins.length; j++) {
          const plugin = handlerHookPlugins[j];

          if (typeof plugin.afterRender === "function") {
            await plugin.afterRender({
              context,
              configuration,
              args
            });
          }
        }
      }

      return {
        data: null,
        error: null
      };
    } catch (e) {
      console.log("An error occurred while prerendering...", e);
      console.log(JSON.stringify(e.message));
      return {
        data: null,
        error: e
      };
    }
  }

});

exports.default = _default;
//# sourceMappingURL=index.js.map