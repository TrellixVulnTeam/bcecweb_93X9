"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.defaultRenderUrlFunction = exports.default = void 0;

var _chromeAwsLambda = _interopRequireDefault(require("chrome-aws-lambda"));

var _posthtml = _interopRequireDefault(require("posthtml"));

var _posthtmlNoopener = require("posthtml-noopener");

var _posthtmlPluginLinkPreload = _interopRequireDefault(require("posthtml-plugin-link-preload"));

var _injectApolloState = _interopRequireDefault(require("./injectApolloState"));

var _injectRenderId = _interopRequireDefault(require("./injectRenderId"));

var _injectRenderTs = _interopRequireDefault(require("./injectRenderTs"));

var _injectTenantLocale = _interopRequireDefault(require("./injectTenantLocale"));

var _injectNotFoundPageFlag = _interopRequireDefault(require("./injectNotFoundPageFlag"));

var _getPsTags = _interopRequireDefault(require("./getPsTags"));

var _shortid = _interopRequireDefault(require("shortid"));

const windowSet = (page, name, value) => {
  page.evaluateOnNewDocument(`
    Object.defineProperty(window, '${name}', {
      get() {
        return '${value}'
      }
    })`);
};

var _default = async (url, args) => {
  const id = _shortid.default.generate();

  const ts = new Date().getTime();
  console.log(`Rendering "${url}" (render ID: ${id})...`);
  const renderUrl = typeof args.renderUrlFunction === "function" ? args.renderUrlFunction : defaultRenderUrlFunction;
  const render = await renderUrl(url, args); // Process HTML.
  // TODO: should be plugins (will also eliminate lower @ts-ignore instructions).

  console.log("Processing HTML..."); // TODO: regular text processing plugins...

  {
    const regex = /<script (src="\/static\/js\/)/gm;
    const subst = `<script data-link-preload data-link-preload-type="markup" src="/static/js/`;
    render.content = render.content.replace(regex, subst);
  }
  {
    const regex = /<link href="\/static\/css\//gm;
    const subst = `<link data-link-preload data-link-preload-type="markup" href="/static/css/`;
    render.content = render.content.replace(regex, subst);
  }
  const allArgs = {
    render,
    args,
    url,
    id,
    ts
  };
  const {
    html
  } = await (0, _posthtml.default)([(0, _posthtmlNoopener.noopener)(), (0, _posthtmlPluginLinkPreload.default)(), // @ts-ignore
  (0, _injectRenderId.default)(allArgs), // @ts-ignore
  (0, _injectRenderTs.default)(allArgs), // @ts-ignore
  (0, _injectApolloState.default)(allArgs), // @ts-ignore
  (0, _injectTenantLocale.default)(allArgs), // @ts-ignore
  (0, _injectNotFoundPageFlag.default)(allArgs)]).process(render.content);
  console.log("Processing HTML done.");
  console.log(`Rendering "${url}" completed.`); // TODO: should be plugins.

  return [[{
    name: "index.html",
    body: html,
    type: "text/html",
    meta: {
      tags: (0, _getPsTags.default)(html)
    }
  }, {
    name: "graphql.json",
    body: JSON.stringify(render.meta.gqlCache),
    type: "application/json",
    meta: {}
  }], allArgs];
};

exports.default = _default;
let browser;

const defaultRenderUrlFunction = async (url, args) => {
  var _args$args, _args$args$configurat, _args$args$configurat2, _args$args2, _args$args2$configura, _args$args2$configura2, _args$args3, _args$args3$configura, _args$args3$configura2;

  if (!browser) {
    browser = await _chromeAwsLambda.default.puppeteer.launch({
      args: _chromeAwsLambda.default.args,
      defaultViewport: _chromeAwsLambda.default.defaultViewport,
      executablePath: await _chromeAwsLambda.default.executablePath,
      headless: _chromeAwsLambda.default.headless,
      ignoreHTTPSErrors: true
    });
  }

  const browserPage = await browser.newPage(); // Can be used to add additional logic - e.g. skip a GraphQL query to be made when in pre-rendering process.

  windowSet(browserPage, "__PS_RENDER__", true);
  const tenant = args === null || args === void 0 ? void 0 : (_args$args = args.args) === null || _args$args === void 0 ? void 0 : (_args$args$configurat = _args$args.configuration) === null || _args$args$configurat === void 0 ? void 0 : (_args$args$configurat2 = _args$args$configurat.meta) === null || _args$args$configurat2 === void 0 ? void 0 : _args$args$configurat2.tenant;

  if (tenant) {
    console.log("Setting tenant (__PS_RENDER_TENANT__) to window object....");
    windowSet(browserPage, "__PS_RENDER_TENANT__", tenant);
  }

  const locale = args === null || args === void 0 ? void 0 : (_args$args2 = args.args) === null || _args$args2 === void 0 ? void 0 : (_args$args2$configura = _args$args2.configuration) === null || _args$args2$configura === void 0 ? void 0 : (_args$args2$configura2 = _args$args2$configura.meta) === null || _args$args2$configura2 === void 0 ? void 0 : _args$args2$configura2.locale;

  if (locale) {
    console.log("Setting locale (__PS_RENDER_LOCALE__) to window object....");
    windowSet(browserPage, "__PS_RENDER_LOCALE__", locale);
  }

  const notFoundPage = args === null || args === void 0 ? void 0 : (_args$args3 = args.args) === null || _args$args3 === void 0 ? void 0 : (_args$args3$configura = _args$args3.configuration) === null || _args$args3$configura === void 0 ? void 0 : (_args$args3$configura2 = _args$args3$configura.meta) === null || _args$args3$configura2 === void 0 ? void 0 : _args$args3$configura2.notFoundPage;

  if (notFoundPage) {
    console.log("Setting locale (__PS_NOT_FOUND_PAGE__) to window object....");
    windowSet(browserPage, "__PS_NOT_FOUND_PAGE__", true);
  } // Don't load these resources during prerender.


  const skipResources = ["image", "stylesheet"];
  await browserPage.setRequestInterception(true);
  const gqlCache = [];
  browserPage.on("request", request => {
    if (skipResources.includes(request.resourceType())) {
      request.abort();
    } else {
      request.continue();
    }
  }); // TODO: should be a plugin.

  browserPage.on("response", async response => {
    const request = response.request();
    const url = request.url();

    if (url.includes("/graphql") && request.method() === "POST") {
      const responses = await response.json();
      const postData = JSON.parse(request.postData());
      const operations = Array.isArray(postData) ? postData : [postData];

      for (let i = 0; i < operations.length; i++) {
        const {
          operationName,
          query,
          variables
        } = operations[i]; // TODO: Should be handled via a plugin.

        const operationsAllowedToCached = ["PbGetPublishedPage", "PbPageListResponse"];

        if (operationsAllowedToCached.includes(operationName)) {
          gqlCache.push({
            query,
            variables,
            data: responses[i].data
          });
        }
      }

      return;
    }
  }); // Load URL and wait for all network requests to settle.

  await browserPage.goto(url, {
    waitUntil: "networkidle0"
  });
  const apolloState = await browserPage.evaluate(() => {
    // @ts-ignore
    return window.getApolloState();
  });
  return {
    content: await browserPage.content(),
    // TODO: ideally, meta should be assigned here in a more "plugins style" way, not hardcoded.
    meta: {
      gqlCache,
      apolloState
    }
  };
};

exports.defaultRenderUrlFunction = defaultRenderUrlFunction;
//# sourceMappingURL=renderUrl.js.map