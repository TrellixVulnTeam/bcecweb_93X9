{"version":3,"sources":["../../../src/queue/process/index.ts"],"names":["IS_TEST","process","env","NODE_ENV","log","args","console","configuration","type","handle","context","stats","jobs","unique","retrieved","renderAll","handlerHookPlugins","plugins","byType","j","length","plugin","beforeProcess","allJobs","db","read","defaults","query","PK","SK","$gte","data","error","i","delete","renderAllJobs","uniqueJobsObject","job","render","path","dbNamespace","namespace","Object","values","uniqueJobs","filter","push","uniqueDbNamespaces","uniqueJobsPerOperationPerDbNamespace","flush","uniqueJob","JSON","stringify","tag","url","Boolean","join","renderData","endsWith","value","$beginsWith","tagUrlLinks","k","tagUrlLink","renderJobsCount","keys","jobsForDbNamespace","chunks","current","handlerClient","invoke","name","handlers","await","payload","afterProcess","e"],"mappings":"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","sourcesContent":["import { HandlerPlugin, ProcessHookPlugin } from \"./types\";\nimport { DbQueueJob, DbRender, DbTagUrlLink } from \"../../types\";\nimport { HandlerResponse } from \"../../types\";\nimport defaults from \"../../utils/defaults\";\nimport getTagUrlLinkPKSK from \"../../utils/getTagUrlLinkPKSK\";\nimport hash from \"object-hash\";\nimport chunk from \"lodash/chunk\";\nimport pluralize from \"pluralize\";\n\nconst IS_TEST = process.env.NODE_ENV === \"test\";\nconst log = (...args) => {\n    if (IS_TEST) {\n        return;\n    }\n\n    return console.log(...args);\n};\n\ntype Configuration = {\n    handlers: {\n        render: string;\n        flush: string;\n    };\n};\n\ntype Stats = {\n    jobs: {\n        unique: number;\n        retrieved: number;\n        renderAll: number;\n    };\n};\n\nexport default (configuration: Configuration): HandlerPlugin => ({\n    type: \"handler\",\n    async handle(context): Promise<HandlerResponse<{ stats: Stats }>> {\n        const stats: Stats = {\n            jobs: {\n                unique: 0,\n                retrieved: 0,\n                renderAll: 0\n            }\n        };\n\n        try {\n            const handlerHookPlugins =\n                context.plugins.byType<ProcessHookPlugin>(\"ps-queue-process-hook\");\n\n            for (let j = 0; j < handlerHookPlugins.length; j++) {\n                const plugin = handlerHookPlugins[j];\n                if (typeof plugin.beforeProcess === \"function\") {\n                    await plugin.beforeProcess({\n                        context\n                    });\n                }\n            }\n\n            log(\"Fetching all of the jobs added to the queue...\");\n            const [allJobs] = await context.db.read<DbQueueJob>({\n                ...defaults.db,\n                query: {\n                    PK: \"PS#Q#JOB\",\n                    SK: { $gte: \" \" }\n                }\n            });\n\n            stats.jobs.retrieved = allJobs.length;\n            log(`Fetched ${allJobs.length} ${pluralize(\"job\", allJobs.length)}.`);\n\n            if (allJobs.length === 0) {\n                log(\"No queue jobs to process. Exiting...\");\n                return { data: { stats }, error: null };\n            }\n\n            log(`Deleting all jobs from the database so they don't get executed again...`);\n            for (let i = 0; i < allJobs.length; i++) {\n                const { PK, SK } = allJobs[i];\n                await context.db.delete({\n                    ...defaults.db,\n                    query: {\n                        PK,\n                        SK\n                    }\n                });\n            }\n\n            log(`Deleted ${allJobs.length} ${pluralize(\"job\", allJobs.length)} from the database.`);\n            log(\"Eliminating duplicate jobs (no need to run the same job twice, right?).\");\n\n            // Let's also note all render-all-pages jobs (path: \"*\").\n            const renderAllJobs: Record<string, DbQueueJob> = {};\n\n            const uniqueJobsObject = {};\n            for (let i = 0; i < allJobs.length; i++) {\n                const job = allJobs[i];\n                // If job doesn't have args (which should not happen), just ignore the job.\n                if (!job.args) {\n                    continue;\n                }\n\n                uniqueJobsObject[hash(job.args)] = job;\n                if (job.args.render) {\n                    const { path, configuration } = job.args.render;\n                    if (path === \"*\") {\n                        const dbNamespace = configuration?.db?.namespace || \"\";\n                        renderAllJobs[dbNamespace] = job;\n                    }\n                }\n\n                // TODO: Ideally, we'd want to add support for processing `flush` jobs as well.\n            }\n\n            log(\n                `Detected ${\n                    Object.values(renderAllJobs).length\n                } render-all-pages (path: *) ${pluralize(\n                    \"job\",\n                    Object.values(renderAllJobs).length\n                )}.`\n            );\n\n            stats.jobs.renderAll = Object.values(renderAllJobs).length;\n\n            let uniqueJobs = Object.values<DbQueueJob>(uniqueJobsObject);\n\n            // Now, if we have something in the \"renderAllJobs\" array, let's remove all\n            // jobs for every dbNamespace that is listed in it.\n            if (Object.values(renderAllJobs).length > 0) {\n                uniqueJobs = uniqueJobs.filter(job => {\n                    const render = job?.args?.render;\n                    if (!render) {\n                        return true;\n                    }\n\n                    const dbNamespace = render?.configuration?.db?.namespace || \"\";\n                    if (renderAllJobs[dbNamespace]) {\n                        return false;\n                    }\n\n                    return true;\n                });\n\n                // TODO: Ideally, we'd want to add support for processing `flush` jobs as well.\n            }\n\n            // Once we've removed all jobs for dbNamespaces that have the render-all-pages job,\n            // let's add these jobs back so they actually get performed below.\n\n            uniqueJobs.push(...Object.values(renderAllJobs));\n\n            stats.jobs.unique = uniqueJobs.length;\n\n            log(\n                `Ended up with ${uniqueJobs.length} unique ${pluralize(\n                    \"job\",\n                    uniqueJobs.length\n                )} that need to be processed.`\n            );\n            log(`Starting processing...Gathering a list of all URLs that need to be processed...`);\n\n            const uniqueDbNamespaces: Record<string, any> = {};\n            const uniqueJobsPerOperationPerDbNamespace: {\n                flush: Record<string, any>;\n                render: Record<string, any>;\n            } = { flush: {}, render: {} };\n\n            for (let i = 0; i < uniqueJobs.length; i++) {\n                const uniqueJob = uniqueJobs[i];\n                log(\"Processing unique job.\", JSON.stringify(uniqueJob));\n                const { args } = uniqueJob;\n\n                // TODO: Ideally, we'd want to add support for processing `flush` jobs as well.\n                const { render /*flush*/ } = args;\n\n                if (render) {\n                    const { tag, path, url, configuration } = render;\n\n                    const dbNamespace = configuration?.db?.namespace || \"\";\n                    if (!uniqueDbNamespaces[dbNamespace]) {\n                        uniqueDbNamespaces[dbNamespace] = uniqueDbNamespaces;\n                    }\n\n                    if (!uniqueJobsPerOperationPerDbNamespace.render[dbNamespace]) {\n                        uniqueJobsPerOperationPerDbNamespace.render[dbNamespace] = {};\n                    }\n\n                    if (url) {\n                        uniqueJobsPerOperationPerDbNamespace.render[dbNamespace][url] = {\n                            url,\n                            configuration\n                        };\n                    }\n\n                    if (typeof path === \"string\") {\n                        if (path === \"*\") {\n                            // We must re-render all pages.\n                            const PK = [dbNamespace, \"PS\", \"RENDER\"].filter(Boolean).join(\"#\");\n                            const [renderData] = await context.db.read<DbRender>({\n                                ...defaults.db,\n                                query: {\n                                    PK,\n                                    SK: { $gte: \" \" }\n                                }\n                            });\n\n                            for (let j = 0; j < renderData.length; j++) {\n                                const { url, args } = renderData[j];\n                                // We just need the `args` of the `renderData`.\n                                uniqueJobsPerOperationPerDbNamespace.render[dbNamespace][url] =\n                                    args;\n                            }\n                        } else if (path.endsWith(\"*\")) {\n                            // Future feature - ability to search by prefix, e.g. \"/en/*\" or \"/categories/books/*\".\n                        } else {\n                            uniqueJobsPerOperationPerDbNamespace.render[dbNamespace][url] = {\n                                path,\n                                configuration\n                            };\n                        }\n                    }\n\n                    if (tag) {\n                        // If we must render all pages with a specific tag, let's gather all URLs that contain it.\n                        // TODO: improve - paginate instead of just naively executing read (all).\n                        const [PK] = getTagUrlLinkPKSK({\n                            tag,\n                            dbNamespace\n                        });\n\n                        if (PK) {\n                            // A) For tags like { key: \"pb-page\", value: \"abc123\" }, we need to use\n                            // `$beginsWith: tag.value` for SK condition. SK is always in `TAG-VALUE#URL` format.\n                            // B) For tags like { key: \"pb-page\" }, we don't care about tag value (value in SK\n                            // column), so we don't send anything as the SK condition.\n                            const SK = tag.value ? { $beginsWith: tag.value + \"#\" } : { $gte: \" \" };\n\n                            // SK ready - let's execute the query.\n                            const [tagUrlLinks] = await context.db.read<DbTagUrlLink>({\n                                ...defaults.db,\n                                query: { PK, SK }\n                            });\n\n                            // TODO: improve - call reads in batches, instead of 1-by-1.\n                            // TODO: Or maybe store a copy of needed data in the link itself?\n                            for (let k = 0; k < tagUrlLinks.length; k++) {\n                                const tagUrlLink = tagUrlLinks[k];\n                                const PK = [dbNamespace, \"PS\", \"RENDER\"].filter(Boolean).join(\"#\");\n                                const url = tagUrlLink.url;\n\n                                const [[renderData]] = await context.db.read<DbRender>({\n                                    ...defaults.db,\n                                    query: {\n                                        PK,\n                                        SK: url\n                                    }\n                                });\n\n                                if (renderData) {\n                                    // We just need the `args` of the `renderData`.\n                                    uniqueJobsPerOperationPerDbNamespace.render[dbNamespace][url] =\n                                        renderData.args;\n                                }\n                            }\n                        }\n                    }\n                }\n\n                log(\"Processing unique job done, moving on to the next.\");\n            }\n\n            let renderJobsCount = 0;\n            for (const dbNamespace in uniqueJobsPerOperationPerDbNamespace.render) {\n                renderJobsCount += Object.keys(\n                    uniqueJobsPerOperationPerDbNamespace.render[dbNamespace]\n                ).length;\n            }\n\n            log(\n                `Done iterating over ${uniqueJobs.length} unique ${pluralize(\n                    \"job\",\n                    uniqueJobs.length\n                )}. There is a total of ${renderJobsCount} render and 0 flush jobs to be processed, across ${\n                    Object.keys(uniqueDbNamespaces).length\n                } DB ${pluralize(\"namespace\", Object.keys(uniqueDbNamespaces).length)}.`\n            );\n\n            log(\"Issuing render and flush jobs...\");\n\n            log(\"Started with render jobs...\");\n            if (Object.keys(uniqueJobsPerOperationPerDbNamespace.render).length === 0) {\n                log(\"There are no render jobs to issue. Moving on...\");\n            } else {\n                for (const dbNamespace in uniqueJobsPerOperationPerDbNamespace.render) {\n                    const jobsForDbNamespace =\n                        uniqueJobsPerOperationPerDbNamespace.render[dbNamespace];\n\n                    const chunks = chunk(Object.values(jobsForDbNamespace), 10);\n\n                    if (chunks.length === 0) {\n                        log(\n                            `There is nothing to issue for \"${dbNamespace}\" DB namespace. Continuing with the next one.`\n                        );\n                        continue;\n                    }\n\n                    log(\n                        `Splat render jobs for \"${dbNamespace}\" DB namespace into ${\n                            chunks.length\n                        } ${pluralize(\n                            \"chunk\",\n                            chunks.length\n                        )} (10 items per chunk). Issuing render jobs...`\n                    );\n\n                    for (let j = 0; j < chunks.length; j++) {\n                        const current = chunks[j];\n\n                        await context.handlerClient.invoke({\n                            name: configuration.handlers.render,\n                            await: false,\n                            payload: current\n                        });\n                    }\n\n                    log(\n                        `Issued render jobs for \"${dbNamespace}\" DB namespace. Render handler was invoked ${\n                            chunks.length\n                        } ${pluralize(\"time\", chunks.length)}.`\n                    );\n                }\n\n                log(\"All render jobs issued. Moving on with issuing flush jobs.\");\n            }\n\n            log(\"Started with flush jobs...\");\n            if (Object.keys(uniqueJobsPerOperationPerDbNamespace.flush).length === 0) {\n                log(\"There are no flush jobs to issue. Moving on...\");\n            } else {\n                // TODO: probably a good amount of code can be copied from above render processing.\n            }\n\n            log(`All queue jobs processed, triggering \"afterProcess\" hook...`);\n\n            for (let j = 0; j < handlerHookPlugins.length; j++) {\n                const plugin = handlerHookPlugins[j];\n                if (typeof plugin.afterProcess === \"function\") {\n                    await plugin.afterProcess({\n                        context\n                    });\n                }\n            }\n\n            return { data: { stats }, error: null };\n        } catch (e) {\n            log(\"An error occurred while trying to add to prerendering queue...\", e);\n            return { data: { stats }, error: e };\n        }\n    }\n});\n"],"file":"index.js"}