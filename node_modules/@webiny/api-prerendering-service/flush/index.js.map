{"version":3,"sources":["../../src/flush/index.ts"],"names":["s3","S3","region","process","env","AWS_REGION","deleteFile","key","storageName","deleteObject","Bucket","Key","promise","configuration","type","handle","context","log","console","invocationArgs","handlerArgs","Array","isArray","handlerHookPlugins","plugins","byType","promises","JSON","stringify","i","length","args","push","Promise","resolve","dbNamespace","url","PK","filter","Boolean","join","currentRenderData","db","read","defaults","query","SK","j","plugin","beforeFlush","render","storageFolder","files","file","path","name","currentIndexHtml","find","item","endsWith","currentIndexHtmlTags","meta","tags","batch","k","tag","delete","execute","afterFlush","all","data","error","e"],"mappings":";;;;;;;;;;;AAAA;;AACA;;AACA;;AACA;;AACA;;AAGA;;AACA;;AACA;;;;;;AAEA,MAAMA,EAAE,GAAG,IAAIC,UAAJ,CAAO;AAAEC,EAAAA,MAAM,EAAEC,OAAO,CAACC,GAAR,CAAYC;AAAtB,CAAP,CAAX;;AAEA,MAAMC,UAAU,GAAG,CAAC;AAAEC,EAAAA,GAAF;AAAOC,EAAAA;AAAP,CAAD,KAA0B;AACzC,SAAOR,EAAE,CACJS,YADE,CACW;AACVC,IAAAA,MAAM,EAAEF,WADE;AAEVG,IAAAA,GAAG,EAAEJ;AAFK,GADX,EAKFK,OALE,EAAP;AAMH,CAPD;;eASgBC,aAAD,KAAmD;AAC9DC,EAAAA,IAAI,EAAE,SADwD;;AAE9D,QAAMC,MAAN,CAAaC,OAAb,EAAgD;AAC5C,UAAMC,GAAG,GAAGC,OAAO,CAACD,GAApB;AACA,UAAM;AAAEE,MAAAA;AAAF,QAAqBH,OAA3B;AACA,UAAMI,WAAW,GAAGC,KAAK,CAACC,OAAN,CAAcH,cAAd,IAAgCA,cAAhC,GAAiD,CAACA,cAAD,CAArE;AACA,UAAMI,kBAAkB,GAAGP,OAAO,CAACQ,OAAR,CAAgBC,MAAhB,CAAwC,eAAxC,CAA3B;AAEA,UAAMC,QAAQ,GAAG,EAAjB;AAEAT,IAAAA,GAAG,CAAC,iBAAD,EAAoBU,IAAI,CAACC,SAAL,CAAeT,cAAf,CAApB,CAAH;;AAEA,QAAI;AACA,WAAK,IAAIU,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGT,WAAW,CAACU,MAAhC,EAAwCD,CAAC,EAAzC,EAA6C;AACzC,cAAME,IAAI,GAAGX,WAAW,CAACS,CAAD,CAAxB;AAEAH,QAAAA,QAAQ,CAACM,IAAT,CACI,IAAIC,OAAJ,CAAY,MAAOC,OAAP,IAAyB;AACjC,gBAAMC,WAAW,GAAG,6BAAeJ,IAAf,EAAqBlB,aAArB,CAApB;AACA,gBAAMuB,GAAG,GAAG,2BAAaL,IAAb,EAAmBlB,aAAnB,CAAZ;AACA,gBAAMwB,EAAE,GAAG,CAACF,WAAD,EAAc,IAAd,EAAoB,QAApB,EAA8BG,MAA9B,CAAqCC,OAArC,EAA8CC,IAA9C,CAAmD,GAAnD,CAAX;AACA,gBAAM,CAAC,CAACC,iBAAD,CAAD,IAAwB,MAAMzB,OAAO,CAAC0B,EAAR,CAAWC,IAAX,iCAC7BC,kBAASF,EADoB;AAEhCG,YAAAA,KAAK,EAAE;AACHR,cAAAA,EADG;AAEHS,cAAAA,EAAE,EAAEV;AAFD;AAFyB,aAApC;;AAQA,eAAK,IAAIW,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGxB,kBAAkB,CAACO,MAAvC,EAA+CiB,CAAC,EAAhD,EAAoD;AAChD,kBAAMC,MAAM,GAAGzB,kBAAkB,CAACwB,CAAD,CAAjC;;AACA,gBAAI,OAAOC,MAAM,CAACC,WAAd,KAA8B,UAAlC,EAA8C;AAC1C,oBAAMD,MAAM,CAACC,WAAP,CAAmB;AACrBhC,gBAAAA,GADqB;AAErBD,gBAAAA,OAFqB;AAGrBH,gBAAAA,aAHqB;AAIrBkB,gBAAAA,IAJqB;AAKrBmB,gBAAAA,MAAM,EAAET;AALa,eAAnB,CAAN;AAOH;AACJ;;AAED,cAAIA,iBAAJ,EAAuB;AACnB,kBAAMjC,WAAW,GAAG,6BAChBiC,iBAAiB,CAACV,IADF,EAEhBU,iBAAiB,CAAC5B,aAFF,CAApB;AAIA,kBAAMsC,aAAa,GAAG,+BAClBV,iBAAiB,CAACV,IADA,EAElBU,iBAAiB,CAAC5B,aAFA,CAAtB;;AAKA,gBAAIQ,KAAK,CAACC,OAAN,CAAcmB,iBAAiB,CAACW,KAAhC,CAAJ,EAA4C;AAAA;;AACxC,mBAAK,IAAIL,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGN,iBAAiB,CAACW,KAAlB,CAAwBtB,MAA5C,EAAoDiB,CAAC,EAArD,EAAyD;AACrD,sBAAMM,IAAI,GAAGZ,iBAAiB,CAACW,KAAlB,CAAwBL,CAAxB,CAAb;;AACA,sBAAMxC,GAAG,GAAG+C,cAAKd,IAAL,CAAUW,aAAV,EAAyBE,IAAI,CAACE,IAA9B,CAAZ;;AACA,sBAAMjD,UAAU,CAAC;AAAEC,kBAAAA,GAAF;AAAOC,kBAAAA;AAAP,iBAAD,CAAhB;AACH,eALuC,CAOxC;;;AACAS,cAAAA,GAAG,CAAC,6DAAD,CAAH,CARwC,CAUxC;;AACA,oBAAMuC,gBAAgB,GAAGf,iBAAiB,CAACW,KAAlB,CAAwBK,IAAxB,CAA6BC,IAAI,IACtDA,IAAI,CAACH,IAAL,CAAUI,QAAV,CAAmB,OAAnB,CADqB,CAAzB;AAIA,oBAAMC,oBAAoB,GAAGJ,gBAAH,aAAGA,gBAAH,gDAAGA,gBAAgB,CAAEK,IAArB,0DAAG,sBAAwBC,IAArD;;AACA,kBACIzC,KAAK,CAACC,OAAN,CAAcsC,oBAAd,KACAA,oBAAoB,CAAC9B,MAFzB,EAGE;AACEb,gBAAAA,GAAG,CACC,qDADD,EAEC2C,oBAFD,CAAH;AAIA,sBAAMG,KAAK,GAAG/C,OAAO,CAAC0B,EAAR,CAAWqB,KAAX,EAAd;;AAEA,qBAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGJ,oBAAoB,CAAC9B,MAAzC,EAAiDkC,CAAC,EAAlD,EAAsD;AAClD,wBAAMC,GAAG,GAAGL,oBAAoB,CAACI,CAAD,CAAhC;AACA,wBAAM,CAAC3B,EAAD,EAAKS,EAAL,IAAW,gCAAkB;AAC/BmB,oBAAAA,GAD+B;AAE/B7B,oBAAAA,GAF+B;AAG/BD,oBAAAA;AAH+B,mBAAlB,CAAjB;;AAMA,sBAAIE,EAAE,IAAIS,EAAV,EAAc;AACViB,oBAAAA,KAAK,CAACG,MAAN,CAAa;AAAErB,sBAAAA,KAAK,EAAE;AAAER,wBAAAA,EAAF;AAAMS,wBAAAA;AAAN;AAAT,qBAAb;AACH;AACJ;;AAED,sBAAMiB,KAAK,CAACI,OAAN,EAAN;AACAlD,gBAAAA,GAAG,CAAC,mCAAD,CAAH;AACH,eAzBD,MAyBO;AACHA,gBAAAA,GAAG,CAAC,kDAAD,CAAH;AACH;AACJ;AACJ;;AAED,gBAAMD,OAAO,CAAC0B,EAAR,CAAWwB,MAAX,iCACCtB,kBAASF,EADV;AAEFG,YAAAA,KAAK,EAAE;AACHR,cAAAA,EAAE,EAAEI,iBAAiB,CAACJ,EADnB;AAEHS,cAAAA,EAAE,EAAEL,iBAAiB,CAACK;AAFnB;AAFL,aAAN;;AAQA,eAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGxB,kBAAkB,CAACO,MAAvC,EAA+CiB,CAAC,EAAhD,EAAoD;AAChD,kBAAMC,MAAM,GAAGzB,kBAAkB,CAACwB,CAAD,CAAjC;;AACA,gBAAI,OAAOC,MAAM,CAACoB,UAAd,KAA6B,UAAjC,EAA6C;AACzC,oBAAMpB,MAAM,CAACoB,UAAP,CAAkB;AACpBnD,gBAAAA,GADoB;AAEpBD,gBAAAA,OAFoB;AAGpBH,gBAAAA,aAHoB;AAIpBkB,gBAAAA,IAJoB;AAKpBmB,gBAAAA,MAAM,EAAET;AALY,eAAlB,CAAN;AAOH;AACJ;;AAEDP,UAAAA,OAAO;AACV,SAxGD,CADJ;AA2GH;;AAED,YAAMD,OAAO,CAACoC,GAAR,CAAY3C,QAAZ,CAAN;AAEA,aAAO;AAAE4C,QAAAA,IAAI,EAAE,IAAR;AAAcC,QAAAA,KAAK,EAAE;AAArB,OAAP;AACH,KApHD,CAoHE,OAAOC,CAAP,EAAU;AACRvD,MAAAA,GAAG,CAAC,yCAAD,EAA4CuD,CAA5C,CAAH;AACA,aAAO;AAAEF,QAAAA,IAAI,EAAE,IAAR;AAAcC,QAAAA,KAAK,EAAEC;AAArB,OAAP;AACH;AACJ;;AApI6D,CAAnD,C","sourcesContent":["import S3 from \"aws-sdk/clients/s3\";\nimport getStorageName from \"./../utils/getStorageName\";\nimport getStorageFolder from \"./../utils/getStorageFolder\";\nimport getDbNamespace from \"./../utils/getDbNamespace\";\nimport getRenderUrl from \"./../utils/getRenderUrl\";\nimport { HandlerPlugin, Configuration, FlushHookPlugin } from \"./types\";\nimport { HandlerResponse, DbRender } from \"../types\";\nimport defaults from \"./../utils/defaults\";\nimport path from \"path\";\nimport getTagUrlLinkPKSK from \"./../utils/getTagUrlLinkPKSK\";\n\nconst s3 = new S3({ region: process.env.AWS_REGION });\n\nconst deleteFile = ({ key, storageName }) => {\n    return s3\n        .deleteObject({\n            Bucket: storageName,\n            Key: key\n        })\n        .promise();\n};\n\nexport default (configuration?: Configuration): HandlerPlugin => ({\n    type: \"handler\",\n    async handle(context): Promise<HandlerResponse> {\n        const log = console.log;\n        const { invocationArgs } = context;\n        const handlerArgs = Array.isArray(invocationArgs) ? invocationArgs : [invocationArgs];\n        const handlerHookPlugins = context.plugins.byType<FlushHookPlugin>(\"ps-flush-hook\");\n\n        const promises = [];\n\n        log(\"Received args: \", JSON.stringify(invocationArgs));\n\n        try {\n            for (let i = 0; i < handlerArgs.length; i++) {\n                const args = handlerArgs[i];\n\n                promises.push(\n                    new Promise(async (resolve?: any) => {\n                        const dbNamespace = getDbNamespace(args, configuration);\n                        const url = getRenderUrl(args, configuration);\n                        const PK = [dbNamespace, \"PS\", \"RENDER\"].filter(Boolean).join(\"#\");\n                        const [[currentRenderData]] = await context.db.read<DbRender>({\n                            ...defaults.db,\n                            query: {\n                                PK,\n                                SK: url\n                            }\n                        });\n\n                        for (let j = 0; j < handlerHookPlugins.length; j++) {\n                            const plugin = handlerHookPlugins[j];\n                            if (typeof plugin.beforeFlush === \"function\") {\n                                await plugin.beforeFlush({\n                                    log,\n                                    context,\n                                    configuration,\n                                    args,\n                                    render: currentRenderData\n                                });\n                            }\n                        }\n\n                        if (currentRenderData) {\n                            const storageName = getStorageName(\n                                currentRenderData.args,\n                                currentRenderData.configuration\n                            );\n                            const storageFolder = getStorageFolder(\n                                currentRenderData.args,\n                                currentRenderData.configuration\n                            );\n\n                            if (Array.isArray(currentRenderData.files)) {\n                                for (let j = 0; j < currentRenderData.files.length; j++) {\n                                    const file = currentRenderData.files[j];\n                                    const key = path.join(storageFolder, file.name);\n                                    await deleteFile({ key, storageName });\n                                }\n\n                                // Let's delete existing tag / URL links.\n                                log(\"Checking if there are existing tag / URL links to remove...\");\n\n                                // Get currently stored tags and delete all tag-URL links.\n                                const currentIndexHtml = currentRenderData.files.find(item =>\n                                    item.name.endsWith(\".html\")\n                                );\n\n                                const currentIndexHtmlTags = currentIndexHtml?.meta?.tags;\n                                if (\n                                    Array.isArray(currentIndexHtmlTags) &&\n                                    currentIndexHtmlTags.length\n                                ) {\n                                    log(\n                                        \"There are existing tag / URL links to be deleted...\",\n                                        currentIndexHtmlTags\n                                    );\n                                    const batch = context.db.batch();\n\n                                    for (let k = 0; k < currentIndexHtmlTags.length; k++) {\n                                        const tag = currentIndexHtmlTags[k];\n                                        const [PK, SK] = getTagUrlLinkPKSK({\n                                            tag,\n                                            url,\n                                            dbNamespace\n                                        });\n\n                                        if (PK && SK) {\n                                            batch.delete({ query: { PK, SK } });\n                                        }\n                                    }\n\n                                    await batch.execute();\n                                    log(\"Existing tag / URL links deleted.\");\n                                } else {\n                                    log(\"There are no existing tag / URL links to delete.\");\n                                }\n                            }\n                        }\n\n                        await context.db.delete({\n                            ...defaults.db,\n                            query: {\n                                PK: currentRenderData.PK,\n                                SK: currentRenderData.SK\n                            }\n                        });\n\n                        for (let j = 0; j < handlerHookPlugins.length; j++) {\n                            const plugin = handlerHookPlugins[j];\n                            if (typeof plugin.afterFlush === \"function\") {\n                                await plugin.afterFlush({\n                                    log,\n                                    context,\n                                    configuration,\n                                    args,\n                                    render: currentRenderData\n                                });\n                            }\n                        }\n\n                        resolve();\n                    })\n                );\n            }\n\n            await Promise.all(promises);\n\n            return { data: null, error: null };\n        } catch (e) {\n            log(\"An error occurred while prerendering...\", e);\n            return { data: null, error: e };\n        }\n    }\n});\n"],"file":"index.js"}