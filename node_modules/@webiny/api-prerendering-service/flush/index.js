"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _s = _interopRequireDefault(require("aws-sdk/clients/s3"));

var _getStorageName = _interopRequireDefault(require("./../utils/getStorageName"));

var _getStorageFolder = _interopRequireDefault(require("./../utils/getStorageFolder"));

var _getDbNamespace = _interopRequireDefault(require("./../utils/getDbNamespace"));

var _getRenderUrl = _interopRequireDefault(require("./../utils/getRenderUrl"));

var _defaults = _interopRequireDefault(require("./../utils/defaults"));

var _path = _interopRequireDefault(require("path"));

var _getTagUrlLinkPKSK = _interopRequireDefault(require("./../utils/getTagUrlLinkPKSK"));

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

const s3 = new _s.default({
  region: process.env.AWS_REGION
});

const deleteFile = ({
  key,
  storageName
}) => {
  return s3.deleteObject({
    Bucket: storageName,
    Key: key
  }).promise();
};

var _default = configuration => ({
  type: "handler",

  async handle(context) {
    const log = console.log;
    const {
      invocationArgs
    } = context;
    const handlerArgs = Array.isArray(invocationArgs) ? invocationArgs : [invocationArgs];
    const handlerHookPlugins = context.plugins.byType("ps-flush-hook");
    const promises = [];
    log("Received args: ", JSON.stringify(invocationArgs));

    try {
      for (let i = 0; i < handlerArgs.length; i++) {
        const args = handlerArgs[i];
        promises.push(new Promise(async resolve => {
          const dbNamespace = (0, _getDbNamespace.default)(args, configuration);
          const url = (0, _getRenderUrl.default)(args, configuration);
          const PK = [dbNamespace, "PS", "RENDER"].filter(Boolean).join("#");
          const [[currentRenderData]] = await context.db.read(_objectSpread(_objectSpread({}, _defaults.default.db), {}, {
            query: {
              PK,
              SK: url
            }
          }));

          for (let j = 0; j < handlerHookPlugins.length; j++) {
            const plugin = handlerHookPlugins[j];

            if (typeof plugin.beforeFlush === "function") {
              await plugin.beforeFlush({
                log,
                context,
                configuration,
                args,
                render: currentRenderData
              });
            }
          }

          if (currentRenderData) {
            const storageName = (0, _getStorageName.default)(currentRenderData.args, currentRenderData.configuration);
            const storageFolder = (0, _getStorageFolder.default)(currentRenderData.args, currentRenderData.configuration);

            if (Array.isArray(currentRenderData.files)) {
              var _currentIndexHtml$met;

              for (let j = 0; j < currentRenderData.files.length; j++) {
                const file = currentRenderData.files[j];

                const key = _path.default.join(storageFolder, file.name);

                await deleteFile({
                  key,
                  storageName
                });
              } // Let's delete existing tag / URL links.


              log("Checking if there are existing tag / URL links to remove..."); // Get currently stored tags and delete all tag-URL links.

              const currentIndexHtml = currentRenderData.files.find(item => item.name.endsWith(".html"));
              const currentIndexHtmlTags = currentIndexHtml === null || currentIndexHtml === void 0 ? void 0 : (_currentIndexHtml$met = currentIndexHtml.meta) === null || _currentIndexHtml$met === void 0 ? void 0 : _currentIndexHtml$met.tags;

              if (Array.isArray(currentIndexHtmlTags) && currentIndexHtmlTags.length) {
                log("There are existing tag / URL links to be deleted...", currentIndexHtmlTags);
                const batch = context.db.batch();

                for (let k = 0; k < currentIndexHtmlTags.length; k++) {
                  const tag = currentIndexHtmlTags[k];
                  const [PK, SK] = (0, _getTagUrlLinkPKSK.default)({
                    tag,
                    url,
                    dbNamespace
                  });

                  if (PK && SK) {
                    batch.delete({
                      query: {
                        PK,
                        SK
                      }
                    });
                  }
                }

                await batch.execute();
                log("Existing tag / URL links deleted.");
              } else {
                log("There are no existing tag / URL links to delete.");
              }
            }
          }

          await context.db.delete(_objectSpread(_objectSpread({}, _defaults.default.db), {}, {
            query: {
              PK: currentRenderData.PK,
              SK: currentRenderData.SK
            }
          }));

          for (let j = 0; j < handlerHookPlugins.length; j++) {
            const plugin = handlerHookPlugins[j];

            if (typeof plugin.afterFlush === "function") {
              await plugin.afterFlush({
                log,
                context,
                configuration,
                args,
                render: currentRenderData
              });
            }
          }

          resolve();
        }));
      }

      await Promise.all(promises);
      return {
        data: null,
        error: null
      };
    } catch (e) {
      log("An error occurred while prerendering...", e);
      return {
        data: null,
        error: e
      };
    }
  }

});

exports.default = _default;
//# sourceMappingURL=index.js.map