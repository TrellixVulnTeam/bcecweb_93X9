"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.LocalesStorageOperations = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _error = _interopRequireDefault(require("@webiny/error"));

var _table = _interopRequireDefault(require("../../definitions/table"));

var _localeEntity = _interopRequireDefault(require("../../definitions/localeEntity"));

var _query = require("@webiny/db-dynamodb/utils/query");

var _filter = require("@webiny/db-dynamodb/utils/filter");

var _sort = require("@webiny/db-dynamodb/utils/sort");

var _listResponse = require("@webiny/db-dynamodb/utils/listResponse");

var _cleanup = require("@webiny/db-dynamodb/utils/cleanup");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

const DEFAULT_SORT_KEY = "default";

class LocalesStorageOperations {
  get partitionKey() {
    const tenant = this._context.tenancy.getCurrentTenant();

    if (!tenant) {
      throw new _error.default("Tenant missing.", "TENANT_NOT_FOUND");
    }

    return `T#${tenant.id}#I18N#L`;
  }

  get defaultPartitionKey() {
    return `${this.partitionKey}#D`;
  }

  constructor({
    context
  }) {
    (0, _defineProperty2.default)(this, "_context", void 0);
    (0, _defineProperty2.default)(this, "_table", void 0);
    (0, _defineProperty2.default)(this, "_entity", void 0);
    this._context = context;
    this._table = (0, _table.default)({
      context
    });
    this._entity = (0, _localeEntity.default)({
      context,
      table: this._table
    });
  }

  async getDefault() {
    try {
      const locale = await this._entity.get({
        PK: this.defaultPartitionKey,
        SK: DEFAULT_SORT_KEY
      });

      if (!locale || !locale.Item) {
        return null;
      }

      return (0, _cleanup.cleanupItem)(this._entity, locale.Item);
    } catch (ex) {
      throw new _error.default(ex.message || "Could not fetch the I18N locale.", ex.code || "GET_DEFAULT_LOCALE_ERROR");
    }
  }

  async get(code) {
    try {
      const locale = await this._entity.get({
        PK: this.partitionKey,
        SK: code
      });

      if (!locale || !locale.Item) {
        return null;
      }

      return (0, _cleanup.cleanupItem)(this._entity, locale.Item);
    } catch (ex) {
      throw new _error.default(ex.message || "Could not fetch the I18N locale.", ex.code || "GET_LOCALE_ERROR");
    }
  }

  async create({
    locale
  }) {
    const keys = {
      PK: this.partitionKey,
      SK: this.getSortKey(locale)
    };

    try {
      await this._entity.put(_objectSpread(_objectSpread({}, locale), keys));
      return locale;
    } catch (ex) {
      throw new _error.default(ex.message || "Cannot create I18N locale.", ex.code || "CREATE_LOCALE_ERROR", {
        locale,
        keys
      });
    }
  }

  async update({
    locale
  }) {
    const keys = {
      PK: this.partitionKey,
      SK: this.getSortKey(locale)
    };

    try {
      await this._entity.put(_objectSpread(_objectSpread({}, locale), keys));
      return locale;
    } catch (ex) {
      throw new _error.default(ex.message || "Cannot update I18N locale.", ex.code || "UPDATE_LOCALE_ERROR", {
        locale,
        keys
      });
    }
  }

  async updateDefault({
    previous,
    locale
  }) {
    /**
     * Set the locale as the default one.
     */
    const batch = [_objectSpread(_objectSpread({}, locale), {}, {
      PK: this.partitionKey,
      SK: this.getSortKey(locale)
    }), _objectSpread(_objectSpread({}, locale), {}, {
      PK: this.defaultPartitionKey,
      SK: DEFAULT_SORT_KEY
    })];
    /**
     * Set the previous locale not to be default in its data.
     */

    if (previous) {
      batch.push(_objectSpread(_objectSpread({}, previous), {}, {
        default: false,
        PK: this.partitionKey,
        SK: this.getSortKey(previous)
      }));
    }

    try {
      await this._table.batchWrite(batch.map(item => this._entity.putBatch(item)));
      return locale;
    } catch (ex) {
      throw new _error.default(ex.message || "Cannot update I18N locale.", ex.code || "UPDATE_LOCALE_ERROR", {
        locale,
        previous,
        batch
      });
    }
  }

  async delete({
    locale
  }) {
    const keys = {
      PK: this.partitionKey,
      SK: this.getSortKey(locale)
    };

    try {
      await this._entity.delete(keys);
    } catch (ex) {
      throw new _error.default(ex.message || "Cannot delete I18N locale.", ex.code || "DELETE_LOCALE_ERROR", {
        locale,
        keys
      });
    }
  }

  async list(params) {
    const {
      where: initialWhere,
      after,
      limit,
      sort
    } = params;

    const where = _objectSpread({}, initialWhere || {});

    const queryAllParams = this.createQueryAllParamsOptions(_objectSpread(_objectSpread({}, params), {}, {
      where
    }));
    let results = [];

    try {
      results = await (0, _query.queryAll)(queryAllParams);
    } catch (ex) {
      throw new _error.default(ex.message || "Cannot list I18N locales.", ex.code || "LIST_LOCALES_ERROR", params);
    }
    /**
     * Filter the read items via the code.
     * It will build the filters out of the where input and transform the values it is using.
     */


    const filteredFiles = (0, _filter.filterItems)({
      items: results,
      where,
      context: this._context
    });
    const totalCount = filteredFiles.length;
    /**
     * Sorting is also done via the code.
     * It takes the sort input and sorts by it via the lodash sortBy method.
     */

    const sortedFiles = (0, _sort.sortItems)({
      context: this._context,
      items: filteredFiles,
      sort,
      // TODO: add possibility to add more fields via plugins
      fields: ["code", "createdBy", "createdOn"]
    });
    /**
     * Use the common db-dynamodb method to create the required response.
     */

    return (0, _listResponse.createListResponse)({
      items: (0, _cleanup.cleanupItems)(this._entity, sortedFiles),
      after,
      totalCount,
      limit
    });
  }

  getSortKey(locale) {
    if (!locale.code) {
      throw new _error.default("Missing locale code.", "CODE_ERROR", {
        locale
      });
    }

    return locale.code;
  }

  createQueryAllParamsOptions(params) {
    const {
      where
    } = params;
    let partitionKey = this.partitionKey;

    if (where.default === true) {
      partitionKey = this.defaultPartitionKey;
      delete where.default;
    }

    return {
      entity: this._entity,
      partitionKey,
      options: {}
    };
  }

}

exports.LocalesStorageOperations = LocalesStorageOperations;
//# sourceMappingURL=LocalesStorageOperations.js.map